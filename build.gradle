import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import org.gradle.plugins.ide.eclipse.model.AccessRule

plugins {
	id "com.github.johnrengelman.shadow" version "8.1.1"
	id "com.google.osdetector" version "1.7.3"
	// The OpenJFX plugin does not work before Java 11, so we apply it conditionally in an if block further below.
	id "org.openjfx.javafxplugin" version "0.0.14" apply false
}

apply plugin: 'application'
apply plugin: 'eclipse'

project.group = "de.hhu.stups"
project.version = "1.2.1-SNAPSHOT"
final isSnapshot = project.version.endsWith("-SNAPSHOT")

if (project != rootProject) {
	throw new GradleException(
		"""\
		The prob2-ui Gradle build cannot be included as a subproject.
		If you are writing a plugin and need to reference the prob2-ui code as a dependency, replace the include statement in your settings.gradle with an includeBuild statement:
		
			includeBuild "${rootProject.relativePath(project.projectDir)}"
		
		And replace the project(":prob2-ui") dependency in your build.gradle with a compileOnly dependency:
		
			dependencies {
				compileOnly group: "${project.group}", name: "${project.name}", version: "${project.version}"
			}
		""".stripIndent()
	)
}

test {
	useJUnitPlatform()
	systemProperty("logback.configurationFile", "de/prob/logging/production.xml")
	testLogging {
		exceptionFormat = 'full'
	}
}



repositories {
	mavenCentral()
	if (isSnapshot) {
		maven {
			name "sonatype snapshots"
			url "https://oss.sonatype.org/content/repositories/snapshots"
		}
	}
}

java {
	sourceCompatibility = JavaVersion.VERSION_1_8
	targetCompatibility = JavaVersion.VERSION_1_8
}

// Module export/open declarations for Java 9+
def exports = []
def opens = []

// Required by centerdevice-nsmenufx (as of version 2.1.6; see https://github.com/codecentric/NSMenuFX/issues/29)
exports += [
	"javafx.controls/com.sun.javafx.scene.control",
	"javafx.graphics/com.sun.glass.ui",
	"javafx.graphics/com.sun.javafx.menu",
	"javafx.graphics/com.sun.javafx.tk",
	"javafx.base/com.sun.javafx.collections",
	// Uncomment when getting WebView console messages with com.sun.javafx.webkit.WebConsoleListener
	// (see the corresponding commented out code in de.prob2.ui.visb.VisBView).
	//"javafx.web/com.sun.javafx.webkit",
]
opens += [
	"javafx.graphics/com.sun.glass.ui.mac",
	"javafx.graphics/com.sun.javafx.tk.quantum",
]

// Required by controlsfx, because we are still using the Java 8-compatible version.
// This has been fixed as of ControlsFX 11.0.0 (see https://github.com/controlsfx/controlsfx/issues/1100), but that release is only compatible with Java 11.
exports += [
	"javafx.graphics/com.sun.javafx.css",
]

exports += [
	"javafx.base/com.sun.javafx.event",
]

application {
	// Our actual application class is de.prob2.ui.ProB2.
	// See the Javadoc of de.prob2.ui.Main for an explanation of why this extra class is necessary.
	mainClass = "de.prob2.ui.Main"

	if (JavaVersion.current().java9Compatible) {
		applicationDefaultJvmArgs += exports.collect {"--add-exports=${it}=ALL-UNNAMED".toString()}
		applicationDefaultJvmArgs += opens.collect {"--add-opens=${it}=ALL-UNNAMED".toString()}
	}
}

tasks.withType(JavaCompile) {
	options.encoding = "UTF-8"
}

configurations {
	javafxAllPlatforms
}

configurations.all {
	resolutionStrategy.cacheChangingModulesFor(0, 'seconds')
	resolutionStrategy.cacheDynamicVersionsFor(0, 'seconds')
}

dependencies {
	implementation group: "ch.qos.logback", name: "logback-classic", version: "1.3.8"
	implementation group: "com.fatboyindustrial.gson-javatime-serialisers", name: "gson-javatime-serialisers", version: "1.1.2"
	implementation group: "com.google.code.gson", name: "gson", version: "2.10.1"
	implementation group: "com.google.guava", name: "guava", version: "32.0.1-jre"
	implementation group: "com.googlecode.java-diff-utils", name: "diffutils", version: "1.3.0"
	implementation group: "commons-cli", name: "commons-cli", version: "1.5.0"
	implementation group: "de.codecentric.centerdevice", name: "centerdevice-nsmenufx", version: "2.1.7"
	implementation group: "de.hhu.stups", name: "de.prob2.kernel", version: "4.12.2-SNAPSHOT"
	implementation group: "de.hhu.stups", name: "voparser", version: "0.2.0"
	implementation group: "net.harawata", name: "appdirs", version: "1.2.1"
	implementation group: "org.controlsfx", name: "controlsfx", version: "8.40.18"
	implementation group: "org.fxmisc.richtext", name: "richtextfx", version: "0.10.8"
	implementation group: "org.pf4j", name: "pf4j", version: "3.9.0"
	implementation group: "se.sawano.java", name: "alphanumeric-comparator", version: "1.4.1"
	implementation group: 'org.apache.commons', name: 'commons-math3', version: '3.6.1'
	implementation group: 'org.apache.velocity', name: 'velocity-engine-core', version: '2.3'
	testImplementation platform('org.junit:junit-bom:5.9.3')
	testImplementation 'org.junit.jupiter:junit-jupiter'
	testImplementation 'org.assertj:assertj-core:3.24.2'
	testImplementation group: 'org.testfx', name: 'testfx-core', version: '4.0.16-alpha'
	testImplementation group: 'org.testfx', name: 'testfx-junit', version: '4.0.15-alpha'
	testImplementation group: 'org.mockito', name: 'mockito-core', version: '4.11.0'
	testImplementation group: 'org.mockito', name: 'mockito-inline', version: '4.11.0'
	testImplementation 'org.awaitility:awaitility:4.2.0'
}

if (!project.hasProperty("javafxVersion")) {
	if (System.getProperty("os.arch") == "aarch64") {
		ext.javafxVersion = "17.0.7"
	} else {
		ext.javafxVersion = "11.0.2"
	}
}

// Split off everything starting at the first non-digit (e. g. "11.0.2" -> "11", "17" -> "17", "18-ea+12" -> "18").
// Used when creating a multi-release jar below (multiPlatformShadowJar) -
// the major version of OpenJFX is equal to its minimum required Java version.
final javafxMajorVersion = javafxVersion.split(/\D/, 2)[0]

final javafxModules = [
	"javafx.base",
	"javafx.controls",
	"javafx.fxml",
	"javafx.graphics",
	"javafx.media",
	"javafx.swing",
	"javafx.web",
]

if (JavaVersion.current().java11Compatible) {
	apply plugin: "org.openjfx.javafxplugin"
	javafx {
		version = javafxVersion
		modules = javafxModules
	}
}

["win", "mac", "linux"].each {platform ->
	javafxModules.each {module ->
		dependencies.javafxAllPlatforms(group: "org.openjfx", name: module.replace("javafx.", "javafx-"), version: javafxVersion, classifier: platform)
	}
}

eclipse.classpath.file.whenMerged {classpath ->
	classpath.entries.findResult { entry ->
		if (entry.kind == 'con' && entry.path.contains('org.eclipse.jdt.launching.JRE_CONTAINER')) {
			entry.accessRules.add(new AccessRule('accessible', 'javafx/**'))
			entry.accessRules.add(new AccessRule('accessible', 'netscape/**'))
		}
	}
}

final generatedResourcesDir = new File(project.buildDir, "generated-src/main/resources")

sourceSets {
	main {
		resources {
			srcDir(generatedResourcesDir)
		}
	}
}

final helpSourceDir = file("src/main/helpsources")
final helpSourceFiles = fileTree(dir: helpSourceDir, include: ["**/*.md"])
final helpOutputDir = new File(generatedResourcesDir, "de/prob2/ui/helpsystem/helppages")
final helpFilterLuaScript = "pandoc_links_to_html.lua"
task createHelp {
	inputs.file(helpFilterLuaScript)
	inputs.files(helpSourceFiles)
	outputs.dir(helpOutputDir)

	doLast {
		delete(helpOutputDir)
		helpSourceFiles.each {inputFile ->
			final title = inputFile.name.replaceAll(/\.md$/, '')
			final relativePath = helpSourceDir.toPath().relativize(inputFile.toPath())
			final relativePathWithNewExtension = relativePath.parent.resolve(relativePath.fileName.toString().replaceAll(/\.md$/, ".html"))
			final outputFile = helpOutputDir.toPath().resolve(relativePathWithNewExtension).toFile()
			outputFile.parentFile.mkdirs()
			exec {
				executable = "pandoc"
				args = [
					"--from=gfm",
					"--to=html",
					"--metadata=title=${title}",
					"--standalone",
					"--lua-filter=${helpFilterLuaScript}",
					"--output=${outputFile}",
					"${inputFile}",
				]
			}
		}
	}
}
processResources.dependsOn(createHelp)

def readCurrentGitCommit() {
	def proc = ["git", "rev-parse", "HEAD"].execute(null, project.projectDir)
	def exitCode = proc.waitFor()
	if (exitCode != 0) {
		throw new IllegalStateException("git rev-parse command exited with status code ${exitCode}:\n" + proc.err.readLines().join("\n"))
	}
	return proc.in.readLines()[0]
}

processResources {
	filesMatching("de/prob2/ui/build.properties") {
		expand(version: project.version, commit: readCurrentGitCommit())
	}
}

jar {
	manifest {
		attributes([
			"Add-Exports": exports.join(" "),
			"Add-Opens": opens.join(" "),
		])
	}
}

final probBinariesByOs = [
	"windows": "win64",
	"osx": "macos",
	"linux": "linux64",
].collectEntries {k, v -> [(k): "de/prob/cli/binaries/probcli_${v}.zip".toString()]}

shadowJar {
	// Set the classifier depending on the current OS to make it clear that this jar is platform-specific.
	// The mapping converts the OS names to the format used by the OpenJFX Maven artifacts (this isn't necessary, but it's more consistent this way).
	archiveClassifier = ["windows": "win", "osx": "mac", "linux": "linux"][osdetector.os]

	// Exclude all probcli zips that are not for the current platform.
	// It's safer to do this with an exclude rule that lists all resources that we know we don't want.
	// This way nothing will break if ProB 2 adds new resources that shouldn't be excluded.
	exclude(probBinariesByOs.findAll {k, v -> k != osdetector.os}.values())
}

task multiPlatformShadowJar(type: ShadowJar) {
	manifest {
		inheritFrom(jar.manifest)
		attributes([
			"Main-Class": application.mainClass.get(),
			"Multi-Release": "true",
		])
	}

	archiveClassifier = "multi"
	from(sourceSets.main.output)
	configurations = [
		project.configurations.runtimeClasspath,
	]

	// Java 11 and newer normally don't have JavaFX preinstalled,
	// so include OpenJFX 11 for these Java versions so they can run the jar.
	// We don't bundle OpenJFX for older Java versions,
	// because they usually have JavaFX preinstalled,
	// and there are no easily usable standalone versions of OpenJFX < 11 that we could use anyway.
	into("META-INF/versions/${javafxMajorVersion}") {
		from(project.configurations.javafxAllPlatforms.collect {zipTree(it)})
	}
}

if (project.hasProperty("probHome")) {
	allprojects {
		tasks.withType(JavaForkOptions) {
			delegate.systemProperties["prob.home"] = project.probHome
		}
	}
}

// Assumes that the correct version of jpackage is on the PATH.
// This task does not respect JAVA_HOME or other non-default JDK locations!
task jpackage(type: Exec) {
	// Use single-platform shadowJar
	dependsOn 'shadowJar'

	// Show jpackage --verbose output only if running Gradle with --info (or higher)
	logging.captureStandardOutput(LogLevel.INFO)

	final applicationName = "ProB 2 UI"
	final applicationNameNoSpaces = "ProB2-UI"

	final jpackageFilesDir = file("src/main/jpackage")
	final jpackageIconsDir = new File(jpackageFilesDir, "icons")
	final jpackageLaunchersDir = new File(jpackageFilesDir, "launchers")
	final shadowJarFile = shadowJar.archiveFile.get().asFile
	executable = "jpackage"
	args = [
		"--verbose",
		"--dest", project.distsDirectory.get().asFile,
		"--input", shadowJarFile.parent,
		"--main-jar", shadowJarFile.name, // file name given to --main-jar is relative to the path given to --input
		'--main-class', application.mainClass.get(),
		// When targetting Linux, jpackage doesn't handle spaces in the application name correctly.
		"--name", osdetector.os == "linux" ? applicationNameNoSpaces : applicationName,
		// Some platforms (Windows, macOS) require that versions follow a strict x.y.z format and don't allow string components like SNAPSHOT.
		"--app-version", project.version.replaceAll(/-SNAPSHOT/, ""),
		"--copyright", "Heinrich-Heine-University, Institut für Softwaretechnik und Programmiersprachen 2023",
		"--vendor", "Heinrich-Heine-University, Institut für Softwaretechnik und Programmiersprachen",
		"--license-file", "LICENSE",
	]

	if (osdetector.os == "windows") {
		args += [
			"--icon", new File(jpackageIconsDir, "prob2-ui.ico"),
			"--win-dir-chooser",
			"--win-menu",
			"--win-menu-group", applicationName,
			"--win-upgrade-uuid", "9e004b84-41c5-4c95-8aca-32ac44063ef9",
			// The Windows application by default runs without a console,
			// which makes it impossible to see stdout/stderr output
			// (even when launched from an existing console window).
			// There is an option to make the launcher a console application,
			// which make stdout/stderr visible,
			// but this also makes a console window appear when the application is launched from the GUI,
			// which is usually not the desired behavior.
			// So we leave the main launcher as a non-console application
			// and add an alternative console launcher that can be used to see stdout/stderr output.
			"--add-launcher", "${applicationName} (with console)=" + new File(jpackageLaunchersDir, "windows_console.properties"),
		]
	} else if (osdetector.os == "osx") {
		args += [
			//"--mac-sign", "--mac-signing-key-user-name", "Michael Leuschel (794LFG5T52)",
			//"--mac-package-signing-prefix", "de.prob2.ui",
			"--icon", new File(jpackageIconsDir, "prob2-ui.icns")
		]
	} else if (osdetector.os == "linux") {
		args += [
			"--icon", new File(jpackageIconsDir, "prob2-ui.png"),
			// This corresponds to the Categories key in the generated .desktop file.
			// For a list of standard categories, see:
			// https://specifications.freedesktop.org/menu-spec/latest/apa.html
			"--linux-menu-group", "ComputerScience;Development;IDE;Java;Science;",
			"--linux-deb-maintainer", "Michael.Leuschel@hhu.de",
		]
	} else {
		throw new GradleException("Unsupported OS: ${osdetector.os} (expected windows, osx, or linux)")
	}
}
