import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import java.nio.file.Files

plugins {
	id "java"
	id "application"

	id "com.gradleup.shadow" version "8.3.9"
	id "com.google.osdetector" version "1.7.3"
	id "org.openjfx.javafxplugin" version "0.1.0"
}

project.group = "de.hhu.stups"
project.version = "1.4.0-SNAPSHOT"
final isSnapshot = project.version.endsWith("-SNAPSHOT")

if (project != rootProject) {
	throw new GradleException(
		"""\
		The prob2-ui Gradle build cannot be included as a subproject.
		If you are writing a plugin and need to reference the prob2-ui code as a dependency, replace the include statement in your settings.gradle with an includeBuild statement:
		
			includeBuild "${rootProject.relativePath(project.projectDir)}"
		
		And replace the project(":prob2-ui") dependency in your build.gradle with a compileOnly dependency:
		
			dependencies {
				compileOnly group: "${project.group}", name: "${project.name}", version: "${project.version}"
			}
		""".stripIndent()
	)
}

test {
	useJUnitPlatform()
	systemProperty("logback.configurationFile", "de/prob/logging/production.xml")
	testLogging {
		exceptionFormat = 'full'
	}
}

final snapshotsRepoUrl = "https://central.sonatype.com/repository/maven-snapshots/"
repositories {
	mavenCentral()
	if (isSnapshot) {
		maven {
			name = "Sonatype snapshots"
			url = snapshotsRepoUrl
		}
	}
}

java {
	sourceCompatibility = JavaVersion.VERSION_21
}

// Module export/open declarations for Java 9+
def exports = [
	// So the documentation generator Velocity templates can call JavaFX collection methods
	"javafx.base/com.sun.javafx.collections",
]
def opens = []

// Uncomment when getting WebView console messages with com.sun.javafx.webkit.WebConsoleListener
// (see the corresponding commented out code in StageManager.initWebView).
//exports += ["javafx.web/com.sun.javafx.webkit"]

application {
	// Our actual application class is de.prob2.ui.ProB2.
	// See the Javadoc of de.prob2.ui.Main for an explanation of why this extra class is necessary.
	mainClass = "de.prob2.ui.Main"

	applicationDefaultJvmArgs += exports.collect { "--add-exports=${it}=ALL-UNNAMED".toString() }
	applicationDefaultJvmArgs += opens.collect { "--add-opens=${it}=ALL-UNNAMED".toString() }
}

tasks.withType(JavaCompile) {
	options.encoding = "UTF-8"
	options.release = Integer.parseInt(java.sourceCompatibility.toString())
}

configurations.all {
	resolutionStrategy.cacheChangingModulesFor(0, 'seconds')
	resolutionStrategy.cacheDynamicVersionsFor(0, 'seconds')
}

dependencies {
	implementation("ch.qos.logback:logback-classic:1.3.15")
	implementation("com.google.guava:guava:33.5.0-jre")
	implementation("io.github.java-diff-utils:java-diff-utils:4.16")
	implementation("commons-cli:commons-cli:1.11.0")
	implementation(platform("de.hhu.stups:prob-java-bom:4.15.2-SNAPSHOT"))
	implementation("de.hhu.stups:de.prob2.kernel")
	implementation("de.hhu.stups:voparser:0.3.0")
	implementation("de.hhu.stups:xml2b:1.1.0")
	implementation("jakarta.annotation:jakarta.annotation-api:3.0.0")
	implementation("org.controlsfx:controlsfx:11.2.3")
	implementation("org.fxmisc.richtext:richtextfx:0.11.4")
	implementation("se.sawano.java:alphanumeric-comparator:2.0.0")
	implementation("org.apache.commons:commons-csv:1.14.1")
	implementation("org.apache.commons:commons-math3:3.6.1")
	implementation("org.apache.velocity:velocity-engine-core:2.4.1")
	implementation("com.fasterxml.jackson.datatype:jackson-datatype-guava")

	// for plugins
	implementation("org.pf4j:pf4j:3.14.1")
	annotationProcessor("org.pf4j:pf4j:3.14.1")

	// nsmenufx indirectly requires the jna:5.9.0:jpms dependency
	// appdirs 1.2.2+ indirectly requires jna:5.13+, but the jpms classifier does not exist for jna 5.13+
	// so we manually fix that
	implementation("net.harawata:appdirs:1.5.0") {
		exclude(group: "net.java.dev.jna")
	}
	implementation("de.jangassen:nsmenufx:3.1.0") {
		exclude(group: "net.java.dev.jna")
	}
	implementation("net.java.dev.jna:jna-platform:5.18.1")

	testImplementation(platform("org.junit:junit-bom:5.14.2"))
	testImplementation("org.junit.jupiter:junit-jupiter")
	testRuntimeOnly("org.junit.platform:junit-platform-launcher")
	testImplementation("org.mockito:mockito-core:5.21.0")

	testImplementation("org.assertj:assertj-core:3.27.6")
}

final osArch = System.getProperty("os.arch")

javafx {
	version = "23.0.2"
	modules = [
		"javafx.base",
		"javafx.controls",
		"javafx.fxml",
		"javafx.graphics",
		"javafx.swing",
		"javafx.web",
	]
}

final generatedResourcesDir = layout.buildDirectory.dir("generated-src/main/resources").get().asFile

sourceSets {
	main {
		resources {
			srcDir(generatedResourcesDir)
		}
	}
}

// This is the shortest recommended way to access ExecOperations.exec :(
// The other alternative is to create a dedicated class for each task that needs exec,
// which is even less convenient...
// https://docs.gradle.org/current/userguide/service_injection.html#execoperations
interface InjectedExecOperations {
	@Inject
	ExecOperations getExecOperations()
}
final execOperations = objects.newInstance(InjectedExecOperations).execOperations

final helpSourceDir = file("src/main/helpsources")
final helpSourceFiles = fileTree(dir: helpSourceDir, include: ["**/*.md"])
final helpOutputDir = new File(generatedResourcesDir, "de/prob2/ui/helpsystem/helppages")
final helpFilterLuaScript = "pandoc_links_to_html.lua"
task createHelp {
	inputs.file(helpFilterLuaScript)
	inputs.files(helpSourceFiles)
	outputs.dir(helpOutputDir)

	doLast {
		delete(helpOutputDir)
		helpSourceFiles.each {inputFile ->
			final title = inputFile.name.replaceAll(/\.md$/, '')
			final relativePath = helpSourceDir.toPath().relativize(inputFile.toPath())
			final relativePathWithNewExtension = relativePath.parent.resolve(relativePath.fileName.toString().replaceAll(/\.md$/, ".html"))
			final outputFile = helpOutputDir.toPath().resolve(relativePathWithNewExtension).toFile()
			outputFile.parentFile.mkdirs()
			execOperations.exec {
				executable = "pandoc"
				args = [
					"--from=gfm",
					"--to=html",
					"--metadata=title=${title}",
					"--standalone",
					"--lua-filter=${helpFilterLuaScript}",
					"--output=${outputFile}",
					"${inputFile}",
				]
			}
		}
	}
}
processResources.dependsOn(createHelp)

final firstLineOfProcessOutput = {ExecOutput execOutput ->
	return execOutput.standardOutput.asText.map {it.split('\n')[0]}
}

processResources {
	inputs.property("version", project.version)
	inputs.property("currentGitBranch", firstLineOfProcessOutput(providers.exec {
		executable = "git"
		args = ["rev-parse", "--abbrev-ref", "HEAD"]
	}))
	inputs.property("currentGitCommit", firstLineOfProcessOutput(providers.exec {
		executable = "git"
		args = ["rev-parse", "HEAD"]
	}))

	filesMatching("de/prob2/ui/build.properties") {
		expand(
			version: inputs.properties["version"],
			branch: inputs.properties["currentGitBranch"],
			commit: inputs.properties["currentGitCommit"],
		)
	}
}

jar {
	manifest {
		attributes([
			"Add-Exports": exports.join(" "),
			"Add-Opens": opens.join(" "),
		])
	}
}

final probBinariesByOs = [
	"windows": "windows64",
	"osx": "macos",
	"linux": "linux64",
].collectEntries {k, v -> [(k): "de/prob/cli/binaries/probcli_${v}.zip".toString()]}

shadowJar {
	// Set the classifier depending on the current OS to make it clear that this jar is platform-specific.
	// This code converts the OS names to the format used by the OpenJFX Maven artifacts (this isn't necessary, but it's more consistent this way).
	if (osdetector.os == "osx") {
		// Include architecture for Mac builds to distinguish x86_64 and aarch64.
		archiveClassifier = "mac-" + osArch
	} else if (osdetector.os == "windows") {
		archiveClassifier = "win"
	} else {
		archiveClassifier = osdetector.os
	}

	// Exclude all probcli zips that are not for the current platform.
	// It's safer to do this with an exclude rule that lists all resources that we know we don't want.
	// This way nothing will break if ProB 2 adds new resources that shouldn't be excluded.
	exclude(probBinariesByOs.findAll {k, v -> k != osdetector.os}.values())
}

if (project.hasProperty("probHome")) {
	allprojects {
		tasks.withType(JavaForkOptions) {
			delegate.systemProperties["prob.home"] = project.probHome
		}
	}
}

// Assumes that the correct version of jpackage is on the PATH.
// This task does not respect JAVA_HOME or other non-default JDK locations!
task jpackage(type: Exec) {
	dependsOn 'shadowJar'

	// Show jpackage --verbose output only if running Gradle with --info (or higher)
	logging.captureStandardOutput(LogLevel.INFO)

	final applicationName = "ProB2-UI"
	// Some platforms (Windows, macOS) require that versions follow a strict x.y.z format and don't allow string components like SNAPSHOT.
	final applicationVersion = project.version.replaceAll(/-SNAPSHOT/, "")

	final jpackageFilesDir = file("src/main/jpackage")
	final jpackageIconsDir = new File(jpackageFilesDir, "icons")
	final jpackageLaunchersDir = new File(jpackageFilesDir, "launchers")
	final shadowJarFile = shadowJar.archiveFile.get().asFile
	final destinationDir = base.distsDirectory.get().asFile
	executable = "jpackage"
	args = [
		"--verbose",
		"--dest", destinationDir,
		"--input", shadowJarFile.parent,
		"--main-jar", shadowJarFile.name, // file name given to --main-jar is relative to the path given to --input
		'--main-class', application.mainClass.get(),
		"--name", applicationName,
		"--app-version", applicationVersion,
		"--copyright", "Heinrich Heine University D端sseldorf, Lehrstuhl f端r Softwaretechnik und Programmiersprachen 2025",
		"--vendor", "Heinrich Heine University D端sseldorf, Lehrstuhl f端r Softwaretechnik und Programmiersprachen",
		"--license-file", "LICENSE",
	]

	if (osdetector.os == "windows") {
		args += [
			"--icon", new File(jpackageIconsDir, "prob2-ui.ico"),
			"--win-dir-chooser",
			"--win-menu",
			"--win-menu-group", applicationName,
			"--win-upgrade-uuid", "9e004b84-41c5-4c95-8aca-32ac44063ef9",
			// The Windows application by default runs without a console,
			// which makes it impossible to see stdout/stderr output
			// (even when launched from an existing console window).
			// There is an option to make the launcher a console application,
			// which make stdout/stderr visible,
			// but this also makes a console window appear when the application is launched from the GUI,
			// which is usually not the desired behavior.
			// So we leave the main launcher as a non-console application
			// and add an alternative console launcher that can be used to see stdout/stderr output.
			"--add-launcher", "${applicationName} (with console)=" + new File(jpackageLaunchersDir, "windows_console.properties"),
		]
	} else if (osdetector.os == "osx") {
		args += [
			//"--mac-sign", "--mac-signing-key-user-name", "Michael Leuschel (794LFG5T52)",
			//"--mac-package-signing-prefix", "de.prob2.ui",
			"--icon", new File(jpackageIconsDir, "prob2-ui.icns")
		]

		doLast {
			// Include architecture in file name for Mac builds to distinguish x86_64 and aarch64.
			// This needs to be done manually afterwards,
			// because jpackage doesn't allow changing the output file name without also changing the displayed application name.
			final originalPath = destinationDir.toPath().resolve("${applicationName}-${applicationVersion}.dmg")
			final renamedPath = originalPath.resolveSibling("${applicationName}-${osArch}-${applicationVersion}.dmg")
			Files.move(originalPath, renamedPath)
		}
	} else if (osdetector.os == "linux") {
		args += [
			"--icon", new File(jpackageIconsDir, "prob2-ui.png"),
			// This corresponds to the Categories key in the generated .desktop file.
			// For a list of standard categories, see:
			// https://specifications.freedesktop.org/menu-spec/latest/apa.html
			"--linux-menu-group", "ComputerScience;Development;IDE;Java;Science;",
			"--linux-deb-maintainer", "Michael.Leuschel@hhu.de",
		]
	} else {
		throw new GradleException("Unsupported OS: ${osdetector.os} (expected windows, osx, or linux)")
	}
}
