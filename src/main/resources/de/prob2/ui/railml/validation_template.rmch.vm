/*@generated */
RULES_MACHINE $validationMachineName
REFERENCES $dataMachineName
DEFINITIONS
    ignoreDirection(Relation) == dom({ r, cr | cr : Relation & r = prj1(prj1(cr)) |-> prj1(prj2(cr)) });
    inverseDirectedRelation(Relation) == dom({ ir, r | r : Relation & ir = prj1(prj2(r)) |-> oppositeDirection(prj2(prj2(r))) |-> (prj1(prj1(r)) |-> oppositeDirection(prj2(prj1(r)))) });
    inverseDirectedPair(Pair) == prj1(Pair) |-> oppositeDirection(prj2(Pair));
    inverseSwitchPosition(pos) == IF pos = position_left THEN position_right ELSE position_left END;
    oppositeDirection(dir) == IF dir = direction_normal THEN direction_reverse ELSE direction_normal END;
    distanceBetweenPositionsOnRelation(Pos1, Pos2, Relation) ==
        SIGMA(bl, begin).( begin : dom(Relation) & begin /: ran(Relation) & bl = prj1(prj1(begin)) & RailML3_IS_NET_ELEMENT_LENGTHS(bl) /= -1.0 | RailML3_IS_NET_ELEMENT_LENGTHS(bl) )
        + SIGMA(bl, begin, end).( begin : dom(Relation) & begin /: ran(Relation) & end /: dom(Relation) & end : ran(Relation) & bl : dom(dom(ran(Relation))) - dom(dom({begin,end})) & RailML3_IS_NET_ELEMENT_LENGTHS(bl) /= -1.0 | RailML3_IS_NET_ELEMENT_LENGTHS(bl) )
        + SIGMA(bl, end).( end /: dom(Relation) & end : ran(Relation) & bl = prj1(prj1(end)) & RailML3_IS_NET_ELEMENT_LENGTHS(bl) /= -1.0 | RailML3_IS_NET_ELEMENT_LENGTHS(bl) );    
    distanceBetween(a,b) ==
        min(
            dom({ l, nxt | #r.(r = ( railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1[{a}] /\ railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1~[{b}] ) \/ {a, b}
                & nxt = r <| RailML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS |> r
                //& nxt : dom(RailML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS) >+> ran(RailML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS)
                //& a |-> b : closure1(nxt)
                & l = SIGMA(c).( c : nxt & prj1(prj1(prj1(c))) = prj1(prj1(prj2(c))) & prj1(prj1(prj1(c))) : dom(RailML3_IS_NET_ELEMENT_LENGTHS) & RailML3_IS_NET_ELEMENT_LENGTHS(prj1(prj1(prj1(c)))) /= -1.0 | RABS(prj2(prj1(prj1(c))) - prj2(prj1(prj2(c)))) * RailML3_IS_NET_ELEMENT_LENGTHS(prj1(prj1(prj1(c)))) )
            )})
        );

    elementOfId(Set, eId) == MU( { e | e : Set & eId = MU(e'Id)} );

    "CHOOSE.def";
    "LibraryMath.def";
    "LibraryMeta.def";
    "LibraryReals.def";
    "LibraryStrings.def";
    "SORT.def";
    SET_PREF_MEMOIZE_FUNCTIONS == TRUE;
    SET_PREF_optimize_enum_set_elems == TRUE;

    EBO_maximum_speed_per_curve_radius(radius, superelevation) ==
        RSQRT(RABS(radius)/11.8 * (superelevation + 130.0)); // http://www.gesetze-im-internet.de/ebo/__40.html, "Ueberhoehungsfehlbetrag" here chosen as 130 mm
OPERATIONS
    RULE EBO_CheckSwitchSpeeds
    BODY
        RULE_FORALL
            e_sw, b_lb, b_lj, b_rb, b_rj//, b_s, b_t
        WHERE
            e_sw : RailML3_switchIS
            // left branch, branching speed, if available
            & b_lb = bool( #(left, r_l, bs_l).( IF card(e_sw'leftBranch) = 1 THEN left = MU(e_sw'leftBranch) ELSE 1=1 END
                    & IF card(left'radius) = 1 THEN r_l = MU(left'radius) ELSE 1=1 END
                    & IF card(left'branchingSpeed) = 1 THEN bs_l = MU(left'branchingSpeed) ELSE 1=1 END
                    & (r_l = 0.0 or bs_l <= EBO_maximum_speed_per_curve_radius(r_l,0.0)) ) )
            // left branch, joining speed, if available
            & b_lj = bool( #(left, r_l, js_l).( IF card(e_sw'leftBranch) = 1 THEN left = MU(e_sw'leftBranch) ELSE 1=1 END
                    & IF card(left'radius) = 1 THEN r_l = MU(left'radius) ELSE 1=1 END
                    & IF card(left'joiningSpeed) = 1 THEN js_l = MU(left'joiningSpeed) ELSE 1=1 END
                    & (r_l = 0.0 or js_l <= EBO_maximum_speed_per_curve_radius(r_l,0.0)) ) )
            // right branch, branching speed, if available
            & b_rb = bool( #(right, r_r, bs_r).( IF card(e_sw'rightBranch) = 1 THEN right = MU(e_sw'rightBranch) ELSE 1=1 END
                    & IF card(right'radius) = 1 THEN r_r = MU(right'radius) ELSE 1=1 END
                    & IF card(right'branchingSpeed) = 1 THEN bs_r = MU(right'branchingSpeed) ELSE 1=1 END
                    & (r_r = 0.0 or bs_r <= EBO_maximum_speed_per_curve_radius(r_r,0.0)) ) )
            // right branch, joining speed, if available
            & b_rj = bool( #(right, r_r, js_r).( IF card(e_sw'rightBranch) = 1 THEN right = MU(e_sw'rightBranch) ELSE 1=1 END
                    & IF card(right'radius) = 1 THEN r_r = MU(right'radius) ELSE 1=1 END
                    & IF card(right'joiningSpeed) = 1 THEN js_r = MU(right'joiningSpeed) ELSE 1=1 END
                    & (r_r = 0.0 or js_r <= EBO_maximum_speed_per_curve_radius(r_r,0.0)) ) )
        EXPECT
            b_lb = TRUE & b_lj = TRUE & b_rb = TRUE & b_rj = TRUE
        COUNTEREXAMPLE
            "[EBO_CheckSwitchSpeeds] Switch id "^MU(e_sw'Id)^" has invalid speed(s):"^
            IF b_lb = FALSE
                THEN STRING_FORMAT(" [branching speed of left branch is ~w, but expected <= ~w] ", MU(MU(e_sw'leftBranch)'branchingSpeed), EBO_maximum_speed_per_curve_radius(MU(MU(e_sw'leftBranch)'radius),0.0))
                ELSE ""
            END
            ^
            IF b_lj = FALSE
                THEN STRING_FORMAT(" [joining speed of left branch is ~w, but expected <= ~w] ", MU(MU(e_sw'leftBranch)'joiningSpeed), EBO_maximum_speed_per_curve_radius(MU(MU(e_sw'leftBranch)'radius),0.0))
                ELSE ""
            END
            ^
            IF b_rb = FALSE
                THEN STRING_FORMAT(" [branching speed of right branch is ~w, but expected <= ~w] ", MU(MU(e_sw'rightBranch)'branchingSpeed), EBO_maximum_speed_per_curve_radius(MU(MU(e_sw'rightBranch)'radius),0.0))
                ELSE ""
            END
            ^
            IF b_rj = FALSE
                THEN STRING_FORMAT(" [joining speed of right branch is ~w, but expected <= ~w] ", MU(MU(e_sw'rightBranch)'joiningSpeed), EBO_maximum_speed_per_curve_radius(MU(MU(e_sw'rightBranch)'radius),0.0))
                ELSE ""
            END
        END
    END;
    RULE MinDistanceOfTDEs // requires all netElements to have an attribute length
    BODY
        RULE_FORALL i_tde1, i_tde2, sloc1, sloc2, dist
            WHERE {i_tde1, i_tde2} <: allIdsOfType("trainDetectionElement") & i_tde1 /= i_tde2
                & sloc1 : RailML3_IS_SPOT_LOCATIONS(i_tde1) & sloc2 : RailML3_IS_SPOT_LOCATIONS(i_tde2) & sloc1 |-> sloc2 : railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1
                & !i_ne.(i_ne : dom(RailML3_IS_NET_ELEMENT_LENGTHS) /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL => RailML3_IS_NET_ELEMENT_LENGTHS(i_ne) /= -1.0)
                & not(#(i_tde3, sloc3).(i_tde3 : allIdsOfType("trainDetectionElement") & sloc3 : RailML3_IS_SPOT_LOCATIONS(i_tde3) & sloc1 |-> sloc3 : railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1 & sloc3 |-> sloc2 : railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1))
                & dist = distanceBetween(sloc1, sloc2)
            EXPECT dist > 21.0
        COUNTEREXAMPLE
            STRING_FORMAT("Distance between trainDetectionElements ~w and ~w is ~w (<= 21.0)", i_tde1, i_tde2, dist)
        END
    END
END
