DEFINITIONS
    SET_PREF_DOT_NODE_FONT_SIZE == 5;
    SET_PREF_DOT_EDGE_FONT_SIZE == 5;

    INCH_FACTOR == 2.54;    

    BALISES(DISPLAY_BALISES) == IF DISPLAY_BALISES = TRUE THEN allIdsOfType("balise") ELSE {} END;
    BORDERS(DISPLAY_BORDERS) == IF DISPLAY_BORDERS = TRUE THEN RailML3_IS_OPENEND_IDS ELSE {} END;
    BUFFERSTOPS(DISPLAY_BUFFERSTOPS) == IF DISPLAY_BUFFERSTOPS = TRUE THEN allIdsOfType("bufferStop") ELSE {} END;
    CROSSINGS(DISPLAY_CROSSINGS) == IF DISPLAY_CROSSINGS = TRUE THEN allIdsOfType("crossing") ELSE {} END;
    DERAILERS(DISPLAY_DERAILERS) == IF DISPLAY_DERAILERS = TRUE THEN allIdsOfType("derailerIS") ELSE {} END;
    LEVELCROSSINGS(DISPLAY_LEVELCROSSINGS) == IF DISPLAY_LEVELCROSSINGS = TRUE THEN allIdsOfType("levelCrossingIS") ELSE {} END;
    OPERATIONALPOINTS(DISPLAY_OPERATIONALPOINTS) == IF DISPLAY_OPERATIONALPOINTS = TRUE THEN allIdsOfType("operationalPoint") ELSE {} END;
    SIGNALS(DISPLAY_SIGNALS) == IF DISPLAY_SIGNALS = TRUE THEN allIdsOfType("signalIS") ELSE {} END;
    SWITCHES(DISPLAY_SWITCHES) == IF DISPLAY_SWITCHES = TRUE THEN RailML3_IS_SWITCH_IDS ELSE {} END;
    TRAINDETECTIONELEMENTS(DISPLAY_TRAINDETECTIONELEMENTS) == IF DISPLAY_TRAINDETECTIONELEMENTS = TRUE THEN allIdsOfType("trainDetectionElement") ELSE {} END;
    TVDSECTIONS(DISPLAY_TVDSECTIONS) == IF DISPLAY_TVDSECTIONS = TRUE THEN allIdsOfType("tvdSection") ELSE {} END;

    D4R_customGraph(DISPLAY_BALISES, DISPLAY_BUFFERSTOPS, DISPLAY_BORDERS, DISPLAY_CROSSINGS, DISPLAY_DERAILERS, DISPLAY_OPERATIONALPOINTS,
           DISPLAY_LEVELCROSSINGS, DISPLAY_SIGNALS, DISPLAY_SWITCHES, DISPLAY_TRAINDETECTIONELEMENTS, DISPLAY_TVDSECTIONS, DISPLAY_NAMES,
           SCALING_FACTOR, LANGUAGE, DOT_ENGINE, USE_CURVED_SPLINES) == rec(
        layout: "neato",
        directed: FALSE,
        overlap: "true",
        `size`: "16,9!",
        scale: TO_STRING(SCALING_FACTOR), // default: 0.004
        splines: "false",
        
        // Bufferstops, Crossings, Openends, TDEs, Signals, Switches:
        nodes1:
            UNION(i_e, e_sep).(i_e : BALISES(DISPLAY_BALISES) \/ BORDERS(DISPLAY_BORDERS) \/ BUFFERSTOPS(DISPLAY_BUFFERSTOPS) \/ CROSSINGS(DISPLAY_CROSSINGS)
            		\/ DERAILERS(DISPLAY_DERAILERS) \/ LEVELCROSSINGS(DISPLAY_LEVELCROSSINGS) \/ SIGNALS(DISPLAY_SIGNALS) \/ SWITCHES(DISPLAY_SWITCHES) \/ TRAINDETECTIONELEMENTS(DISPLAY_TRAINDETECTIONELEMENTS)
                & e_sep : RailML_spotElementProjection & i_e = MU(e_sep'refersToElement) |
                    {rec(shape: "point", nodes: i_e, `id`: i_e, xlabel: IF DISPLAY_NAMES = TRUE & i_e |-> LANGUAGE : dom(RailML3_CO_NAMES) THEN i_e^" ("^RailML3_CO_NAMES(i_e,LANGUAGE)^")" ELSE i_e END,
                        pos: TO_STRING(STRING_TO_REAL(MU(MU(e_sep'coordinate)'x))/INCH_FACTOR)^","^TO_STRING(-STRING_TO_REAL(MU(MU(e_sep'coordinate)'y))/INCH_FACTOR)^"!",
                        height: IF i_e : RailML3_IS_MOVABLE_CROSSING_IDS \/ SWITCHES(DISPLAY_SWITCHES) THEN "0.075" ELSIF i_e : DERAILERS(DISPLAY_DERAILERS) \/ RailML3_IL_SIGNAL_CONTROLLED THEN "0.05" ELSE "0.025" END,
                        width: IF i_e : RailML3_IS_MOVABLE_CROSSING_IDS \/ SWITCHES(DISPLAY_SWITCHES) THEN "0.075" ELSIF i_e : DERAILERS(DISPLAY_DERAILERS) \/ RailML3_IL_SIGNAL_CONTROLLED THEN "0.05" ELSE "0.025" END,
                        fontsize: IF i_e : RailML3_IS_MOVABLE_CROSSING_IDS \/ DERAILERS(DISPLAY_DERAILERS) \/ RailML3_IL_SIGNAL_CONTROLLED \/ SWITCHES(DISPLAY_SWITCHES) THEN "5" ELSE "4" END)}
                )
            \/
            UNION(i_e).(i_e : BALISES(DISPLAY_BALISES) \/ BORDERS(DISPLAY_BORDERS) \/ BUFFERSTOPS(DISPLAY_BUFFERSTOPS) \/ CROSSINGS(DISPLAY_CROSSINGS)
                    \/ DERAILERS(DISPLAY_DERAILERS) \/ LEVELCROSSINGS(DISPLAY_LEVELCROSSINGS) \/ SIGNALS(DISPLAY_SIGNALS) \/ SWITCHES(DISPLAY_SWITCHES) \/ TRAINDETECTIONELEMENTS(DISPLAY_TRAINDETECTIONELEMENTS)
                & !e_sep.(e_sep : RailML_spotElementProjection => i_e /= MU(e_sep'refersToElement)) |
                    {rec(shape:"point", nodes: i_e, `id`: i_e, xlabel: IF DISPLAY_NAMES = TRUE & i_e |-> LANGUAGE : dom(RailML3_CO_NAMES) THEN i_e^" ("^RailML3_CO_NAMES(i_e,LANGUAGE)^")" ELSE i_e END,
                    pos: "",
                    height: IF i_e : RailML3_IS_MOVABLE_CROSSING_IDS \/ SWITCHES(DISPLAY_SWITCHES) THEN "0.075" ELSIF i_e : DERAILERS(DISPLAY_DERAILERS) \/ RailML3_IL_SIGNAL_CONTROLLED THEN "0.05" ELSE "0.025" END,
                    width: IF i_e : RailML3_IS_MOVABLE_CROSSING_IDS \/ SWITCHES(DISPLAY_SWITCHES) THEN "0.075" ELSIF i_e : DERAILERS(DISPLAY_DERAILERS) \/ RailML3_IL_SIGNAL_CONTROLLED THEN "0.05" ELSE "0.025" END,
                    fontsize: IF i_e : RailML3_IS_MOVABLE_CROSSING_IDS \/ DERAILERS(DISPLAY_DERAILERS) \/ RailML3_IL_SIGNAL_CONTROLLED \/ SWITCHES(DISPLAY_SWITCHES) THEN "5" ELSE "4" END)}
                ),
        // Virtual nodes for netElements (only available with exact position):
        nodes2:
            UNION(i_e, e_lep, e_coord).(e_lep : RailML_linearElementProjection & e_coord : e_lep'coordinates & i_e = MU(e_lep'refersToElement)^"_"^TO_STRING(e_coord'recId) |
                {rec(shape:"point", nodes: i_e, `id`: i_e, pos: TO_STRING(STRING_TO_REAL(MU(e_coord'x))/INCH_FACTOR)^","^TO_STRING(-STRING_TO_REAL(MU(e_coord'y))/INCH_FACTOR)^"!", width:"0")}
            ),
        // Labels for tvd sections:
        nodes3:
            UNION(i_e, e_sep).(i_e : TVDSECTIONS(DISPLAY_TVDSECTIONS)
                & e_sep : RailML_spotElementProjection & i_e = MU(e_sep'refersToElement) |
                    {rec(shape: "point", nodes: i_e, xlabel: IF DISPLAY_NAMES = TRUE & i_e |-> LANGUAGE : dom(RailML3_CO_NAMES) THEN i_e^" ("^RailML3_CO_NAMES(i_e,LANGUAGE)^")" ELSE i_e END, `id`: i_e, pos: TO_STRING(STRING_TO_REAL(MU(MU(e_sep'coordinate)'x))/INCH_FACTOR)^","^TO_STRING(-STRING_TO_REAL(MU(MU(e_sep'coordinate)'y))/INCH_FACTOR)^"!", width:"0")}
            ),
        // Nodes for operational points (only for labelling)
        nodes4:
            UNION(i_op, e_sep, e_coord).(i_op : OPERATIONALPOINTS(DISPLAY_OPERATIONALPOINTS) & e_sep : RailML_spotElementProjection & i_op = MU(e_sep'refersToElement) & e_coord = MU(e_sep'coordinate) |
                {rec(shape:"plaintext", nodes: i_op, `id`: i_op, label: IF DISPLAY_NAMES = TRUE & i_op |-> LANGUAGE : dom(RailML3_CO_NAMES) THEN i_op^" ("^RailML3_CO_NAMES(i_op,LANGUAGE)^")"ELSE i_op END, fontsize: "12", pos: TO_STRING(STRING_TO_REAL(MU(e_coord'x))/INCH_FACTOR)^","^TO_STRING(-STRING_TO_REAL(MU(e_coord'y))/INCH_FACTOR)^"!")}
            ),

        // netElement paths with exact positions:
        edges1:
            UNION(i_ne, f, t).(i_ne : dom(RailML3_VIS_NET_ELEMENT_COORDINATES) & f |-> t : RailML3_VIS_NET_ELEMENT_COORDINATES(i_ne) |
                {rec(label: IF DISPLAY_NAMES = TRUE & i_ne |-> LANGUAGE : dom(RailML3_CO_NAMES) THEN i_ne^" ("^RailML3_CO_NAMES(i_ne,LANGUAGE)^")" ELSE i_ne END, `id`:f^"edge", style:"filled", colour:"green", penwidth: IF #(trc,lloc,ane).(trc : RailML3_track & MU(trc'type) = track_mainTrack & lloc : RailML3_linearLocation & lloc'refersTo = MU(trc'Id) & ane : lloc'associatedNetElements & i_ne = MU(ane'netElementRef)) THEN "2.0" ELSE "1.5" END, from: f, to: t) }
            )
        );

    DOT_customGraph(DISPLAY_BALISES, DISPLAY_BUFFERSTOPS, DISPLAY_BORDERS, DISPLAY_CROSSINGS, DISPLAY_DERAILERS, DISPLAY_OPERATIONALPOINTS,
			DISPLAY_LEVELCROSSINGS, DISPLAY_SIGNALS, DISPLAY_SWITCHES, DISPLAY_TRAINDETECTIONELEMENTS, DISPLAY_TVDSECTIONS, DISPLAY_NAMES,
			SCALING_FACTOR, LANGUAGE, DOT_ENGINE, USE_CURVED_SPLINES) == rec(
        layout: DOT_ENGINE,
        `size`: "16,9!",
        rankdir: "LR",
        mode: "sgd", // if DOT_ENGINE = neato
        overlap: "false",
        directed: FALSE,
        splines: USE_CURVED_SPLINES,
        ratio: "compress",
        
        // Bufferstops, Crossings, Openends, TDEs, Signals, Switches:
        nodes1:
            UNION(i_e).(i_e : BUFFERSTOPS(DISPLAY_BUFFERSTOPS) \/ CROSSINGS(DISPLAY_CROSSINGS) \/ BORDERS(DISPLAY_BORDERS) \/ SWITCHES(DISPLAY_SWITCHES)//\/ DERAILERS \/ SIGNALS \/ TRAINDETECTIONELEMENTS
                | //& i_e /: dom(RailML3_IS_LINEAR_COORDINATES) |
                {rec(shape:"point", nodes: i_e, `id`: i_e, xlabel: IF DISPLAY_NAMES = TRUE & i_e |-> LANGUAGE : dom(RailML3_CO_NAMES) THEN i_e^" ("^RailML3_CO_NAMES(i_e,LANGUAGE)^")" ELSE i_e END, height: IF i_e : RailML3_IS_MOVABLE_CROSSING_IDS \/ SWITCHES(DISPLAY_SWITCHES) THEN "0.075" ELSE "0.025" END, fontsize: IF i_e : RailML3_IS_MOVABLE_CROSSING_IDS \/ SWITCHES(DISPLAY_SWITCHES) THEN "5" ELSE "4" END)}
            ),
        // netElements that are endpoints of tracks
        nodes2:
            UNION(i_ne, i_trc, i_ne2).(i_ne : allIdsOfType("netElement") & i_trc : allIdsOfType("track") & ((i_ne = RailML3_IS_TRACK_BEGIN(i_trc) & i_ne2 = prj1(prj1(RailML3_IS_NET_RELATION(inverseDirectedPair(RailML3_IS_TRACK_BEGIN_NET_ELEMENT(i_trc)))))) or (i_ne = RailML3_IS_TRACK_END(i_trc) & i_ne2 = prj1(prj1(RailML3_IS_NET_RELATION(RailML3_IS_TRACK_END_NET_ELEMENT(i_trc)))))) |
                {rec(shape:"point", nodes: STRING_CONC(SORT({i_ne,i_ne2})), `id`: STRING_CONC(SORT({i_ne,i_ne2})), width: "0.0")}
            ),
        // Nodes for netRelations (only if no position available):
        nodes3:
            UNION(i_r, r, e1, e2).(r : union(ran(RailML3_IS_TRACKS)) & e1 = prj1(r) & e2 = prj2(r) & {e1, e2} /\ (BUFFERSTOPS(DISPLAY_BUFFERSTOPS) \/ CROSSINGS(DISPLAY_CROSSINGS) \/ BORDERS(DISPLAY_BORDERS) \/ SWITCHES(DISPLAY_SWITCHES)) = {} & i_r = STRING_CONC(SORT({e1,e2})) |
                {rec(shape:"point", nodes: i_r, `id`: i_r, width: "0.0")}
            ),

        // netElement paths without exact positions:
        // track begin and end are functional infrastructure
        edges1:
            UNION(i_ne, i_trc, f, t, f_, t_).(i_ne : allIdsOfType("netElement") & {f, t} <: RailML3_IS_TRACKS(i_trc) & f /= t & i_ne = prj2(f) & i_ne = prj1(t)
                & IF TRUE : RailML3_IS_LINEAR_LOCATION_KEEPS_ORIENTATION(i_trc)[{i_ne}] THEN
                    IF prj1(f) : BUFFERSTOPS(DISPLAY_BUFFERSTOPS) \/ CROSSINGS(DISPLAY_CROSSINGS) \/ BORDERS(DISPLAY_BORDERS) \/ SWITCHES(DISPLAY_SWITCHES) THEN f_ = prj1(f)
                    ELSE f_ = STRING_CONC(SORT({prj1(f),prj2(f)})) END
                    & IF prj2(t) : BUFFERSTOPS(DISPLAY_BUFFERSTOPS) \/ CROSSINGS(DISPLAY_CROSSINGS) \/ BORDERS(DISPLAY_BORDERS) \/ SWITCHES(DISPLAY_SWITCHES) THEN t_ = prj2(t)
                    ELSE t_ = STRING_CONC(SORT({prj1(t),prj2(t)})) END
                ELSE
                    IF prj1(f) : BUFFERSTOPS(DISPLAY_BUFFERSTOPS) \/ CROSSINGS(DISPLAY_CROSSINGS) \/ BORDERS(DISPLAY_BORDERS) \/ SWITCHES(DISPLAY_SWITCHES) THEN t_ = prj1(f)
                    ELSE t_ = STRING_CONC(SORT({prj1(f),prj2(f)})) END
                    & IF prj2(t) : BUFFERSTOPS(DISPLAY_BUFFERSTOPS) \/ CROSSINGS(DISPLAY_CROSSINGS) \/ BORDERS(DISPLAY_BORDERS) \/ SWITCHES(DISPLAY_SWITCHES) THEN f_ = prj2(t)
                    ELSE f_ = STRING_CONC(SORT({prj1(t),prj2(t)})) END
                END
                // Add minlen to each edge definition: visualisation respects netElement length
                //& IF elementOfId(RailML3_netElement, i_ne)'length /= -1.0 THEN minlen = elementOfId(RailML3_netElement, i_ne)'length*SCALING_FACTOR ELSE minlen = 1.0 END
                |
                    {rec(label: IF DISPLAY_NAMES = TRUE & i_ne |-> LANGUAGE : dom(RailML3_CO_NAMES) THEN i_ne^" ("^RailML3_CO_NAMES(i_ne,LANGUAGE)^")" ELSE i_ne END, `id`: i_ne, style:"filled", colour:"green", penwidth:"1.5", from: f_, to: t_) } //, minlen: minlen) }
            ),
        // track end is an netElement
        edges2:
            UNION(i_ne, i_trc, f, f_, t_).(i_ne : allIdsOfType("netElement") & f : RailML3_IS_TRACKS(i_trc) & i_ne = prj2(f) & i_trc : allIdsOfType("track") & i_ne = RailML3_IS_TRACK_END(i_trc)
                & IF prj1(f) : allIdsOfType("netElement") THEN prj1(f) /= RailML3_IS_TRACK_BEGIN(i_trc) ELSE btrue END
                & IF TRUE : RailML3_IS_LINEAR_LOCATION_KEEPS_ORIENTATION(i_trc)[{i_ne}] THEN
                    IF prj1(f) : BUFFERSTOPS(DISPLAY_BUFFERSTOPS) \/ CROSSINGS(DISPLAY_CROSSINGS) \/ BORDERS(DISPLAY_BORDERS) \/ SWITCHES(DISPLAY_SWITCHES) THEN f_ = prj1(f) ELSE f_ = STRING_CONC(SORT({i_ne, prj1(f)})) END
                    & t_ = STRING_CONC(SORT({i_ne,prj1(prj1(RailML3_IS_NET_RELATION(RailML3_IS_TRACK_END_NET_ELEMENT(i_trc))))}))
                ELSE
                    IF prj1(f) : BUFFERSTOPS(DISPLAY_BUFFERSTOPS) \/ CROSSINGS(DISPLAY_CROSSINGS) \/ BORDERS(DISPLAY_BORDERS) \/ SWITCHES(DISPLAY_SWITCHES) THEN t_ = prj1(f) ELSE t_ = STRING_CONC(SORT({i_ne, prj1(f)})) END
                    & f_ = STRING_CONC(SORT({i_ne,prj1(prj1(RailML3_IS_NET_RELATION(RailML3_IS_TRACK_END_NET_ELEMENT(i_trc))))}))
                END
                //& IF elementOfId(RailML3_netElement, i_ne)'length /= -1.0 THEN minlen = elementOfId(RailML3_netElement, i_ne)'length*SCALING_FACTOR ELSE minlen = 1.0 END
                |
                    {rec(label: IF DISPLAY_NAMES = TRUE & i_ne |-> LANGUAGE : dom(RailML3_CO_NAMES) THEN i_ne^" ("^RailML3_CO_NAMES(i_ne,LANGUAGE)^")" ELSE i_ne END, `id`: i_ne, style:"filled", colour:"green", penwidth:"1.5", from: f_, to: t_) } //, minlen: minlen) }
            ),
        // track begin is an netElement
        edges3:
            UNION(i_ne, i_trc, f, f_, t_).(i_ne : allIdsOfType("netElement") & f : RailML3_IS_TRACKS(i_trc) & i_ne = prj1(f) & i_trc : allIdsOfType("track") & i_ne = RailML3_IS_TRACK_BEGIN(i_trc)
                & IF prj2(f) : allIdsOfType("netElement") THEN prj2(f) /= RailML3_IS_TRACK_END(i_trc) ELSE btrue END
                & IF TRUE : RailML3_IS_LINEAR_LOCATION_KEEPS_ORIENTATION(i_trc)[{i_ne}] THEN
                    f_ = STRING_CONC(SORT({i_ne,prj1(prj1(RailML3_IS_NET_RELATION(inverseDirectedPair(RailML3_IS_TRACK_BEGIN_NET_ELEMENT(i_trc)))))}))
                    & IF prj2(f) : BUFFERSTOPS(DISPLAY_BUFFERSTOPS) \/ CROSSINGS(DISPLAY_CROSSINGS) \/ BORDERS(DISPLAY_BORDERS) \/ SWITCHES(DISPLAY_SWITCHES) THEN t_ = prj2(f) ELSE t_ = STRING_CONC(SORT({i_ne, prj2(f)})) END
                ELSE
                    t_ = STRING_CONC(SORT({i_ne,prj1(prj1(RailML3_IS_NET_RELATION(inverseDirectedPair(RailML3_IS_TRACK_BEGIN_NET_ELEMENT(i_trc)))))})) 
                    & IF prj2(f) : BUFFERSTOPS(DISPLAY_BUFFERSTOPS) \/ CROSSINGS(DISPLAY_CROSSINGS) \/ BORDERS(DISPLAY_BORDERS) \/ SWITCHES(DISPLAY_SWITCHES) THEN f_ = prj2(f) ELSE f_ = STRING_CONC(SORT({i_ne, prj2(f)})) END
                END
                //& IF elementOfId(RailML3_netElement, i_ne)'length /= -1.0 THEN minlen = elementOfId(RailML3_netElement, i_ne)'length*SCALING_FACTOR ELSE minlen = 1.0 END
                |
                    {rec(label: IF DISPLAY_NAMES = TRUE & i_ne |-> LANGUAGE : dom(RailML3_CO_NAMES) THEN i_ne^" ("^RailML3_CO_NAMES(i_ne,LANGUAGE)^")" ELSE i_ne END, `id`: i_ne, style:"filled", colour:"green", penwidth:"1.5", from: f_, to: t_) } //, minlen: minlen) }
            ),
        // track begin and end are netElements and it is the same netElement
        edges4:
            UNION(i_ne, i_ne2, i_trc, f_, t_).({i_ne, i_ne2} <: allIdsOfType("netElement") & i_trc : allIdsOfType("track") & card(RailML3_IS_TRACKS(i_trc)) = 0
                & i_ne = RailML3_IS_TRACK_BEGIN(i_trc) & i_ne2 = RailML3_IS_TRACK_END(i_trc) & i_ne = i_ne2
                & IF TRUE : RailML3_IS_LINEAR_LOCATION_KEEPS_ORIENTATION(i_trc)[{i_ne}] THEN
                    f_ = STRING_CONC(SORT({i_ne,prj1(prj1(RailML3_IS_NET_RELATION(inverseDirectedPair(RailML3_IS_TRACK_BEGIN_NET_ELEMENT(i_trc)))))}))
                    & t_ = STRING_CONC(SORT({i_ne2,prj1(prj1(RailML3_IS_NET_RELATION(RailML3_IS_TRACK_END_NET_ELEMENT(i_trc))))}))
                ELSE 
                    t_ = STRING_CONC(SORT({i_ne,prj1(prj1(RailML3_IS_NET_RELATION(inverseDirectedPair(RailML3_IS_TRACK_BEGIN_NET_ELEMENT(i_trc)))))}))
                    & f_ = STRING_CONC(SORT({i_ne2,prj1(prj1(RailML3_IS_NET_RELATION(RailML3_IS_TRACK_END_NET_ELEMENT(i_trc))))}))
                END
                //& IF elementOfId(RailML3_netElement, i_ne)'length /= -1.0 THEN minlen = elementOfId(RailML3_netElement, i_ne)'length*SCALING_FACTOR ELSE minlen = 1.0 END
                |
                    {rec(label: IF DISPLAY_NAMES = TRUE & i_ne |-> LANGUAGE : dom(RailML3_CO_NAMES) THEN i_ne^" ("^RailML3_CO_NAMES(i_ne,LANGUAGE)^")" ELSE i_ne END, `id`: i_ne, style:"filled", colour:"green", penwidth:"1.5", from: f_, to: t_) } //, minlen: minlen) }
            ),
        // track begin and end are netElements and there are two netElement (i.e. only one relation)
        edges5:
            UNION(i_ne, i_ne2, i_trc, edge, label).({i_ne, i_ne2} <: allIdsOfType("netElement") & i_trc : allIdsOfType("track") & card(RailML3_IS_TRACKS(i_trc)) = 1
                & i_ne = RailML3_IS_TRACK_BEGIN(i_trc) & i_ne2 = RailML3_IS_TRACK_END(i_trc)
                & (IF TRUE : RailML3_IS_LINEAR_LOCATION_KEEPS_ORIENTATION(i_trc)[{i_ne}] THEN
                    label = i_ne & edge = STRING_CONC(SORT({i_ne,prj1(prj1(RailML3_IS_NET_RELATION(inverseDirectedPair(RailML3_IS_TRACK_BEGIN_NET_ELEMENT(i_trc)))))})) |-> STRING_CONC(SORT({i_ne,i_ne2}))
                ELSE
                    label = i_ne & edge = STRING_CONC(SORT({i_ne,i_ne2})) |-> STRING_CONC(SORT({i_ne,prj1(prj1(RailML3_IS_NET_RELATION(inverseDirectedPair(RailML3_IS_TRACK_BEGIN_NET_ELEMENT(i_trc)))))}))
                END
                or
                IF TRUE : RailML3_IS_LINEAR_LOCATION_KEEPS_ORIENTATION(i_trc)[{i_ne2}] THEN
                    label = i_ne2 & edge = STRING_CONC(SORT({i_ne,i_ne2})) |-> STRING_CONC(SORT({i_ne2,prj1(prj1(RailML3_IS_NET_RELATION(RailML3_IS_TRACK_END_NET_ELEMENT(i_trc))))}))
                ELSE
                    label = i_ne2 & edge = STRING_CONC(SORT({i_ne2,prj1(prj1(RailML3_IS_NET_RELATION(RailML3_IS_TRACK_END_NET_ELEMENT(i_trc))))})) |-> STRING_CONC(SORT({i_ne,i_ne2}))
                END)
                //& IF elementOfId(RailML3_netElement, label)'length /= -1.0 THEN minlen = elementOfId(RailML3_netElement, label)'length*SCALING_FACTOR ELSE minlen = 1.0 END
                |
                    {rec(label: IF DISPLAY_NAMES = TRUE & label |-> LANGUAGE : dom(RailML3_CO_NAMES) THEN label^" ("^RailML3_CO_NAMES(label,LANGUAGE)^")" ELSE label END, `id`: label, style:"filled", colour:"green", penwidth:"1.5", edge: edge)  } //, minlen: minlen) }
            )
        );

    NOR_customGraph(DISPLAY_BALISES, DISPLAY_BUFFERSTOPS, DISPLAY_BORDERS, DISPLAY_CROSSINGS, DISPLAY_DERAILERS, DISPLAY_OPERATIONALPOINTS,
            DISPLAY_LEVELCROSSINGS, DISPLAY_SIGNALS, DISPLAY_SWITCHES, DISPLAY_TRAINDETECTIONELEMENTS, DISPLAY_TVDSECTIONS, DISPLAY_NAMES,
            SCALING_FACTOR, LANGUAGE, DOT_ENGINE, USE_CURVED_SPLINES) == rec(
        layout: "neato",
        `size`: "1000,1000",
        directed: FALSE,
        overlap: "true",
        scale: TO_STRING(SCALING_FACTOR), // default: 0.1
        splines: "false",
        
        // Bufferstops, Crossings, Openends, TDEs, Signals, Switches:
        nodes1:
            UNION(i_e, e_ne, e_sloc, iC1, iC2, e_sep1, e_sep2, x1, y1, x2, y2).(i_e : BALISES(DISPLAY_BALISES) \/ BORDERS(DISPLAY_BORDERS) \/ BUFFERSTOPS(DISPLAY_BUFFERSTOPS) \/ CROSSINGS(DISPLAY_CROSSINGS)
                    \/ DERAILERS(DISPLAY_DERAILERS) \/ LEVELCROSSINGS(DISPLAY_LEVELCROSSINGS) \/ SIGNALS(DISPLAY_SIGNALS) \/ SWITCHES(DISPLAY_SWITCHES) \/ TRAINDETECTIONELEMENTS(DISPLAY_TRAINDETECTIONELEMENTS)
                & e_ne : RailML3_netElement & e_sloc : dom(RailML3_IS_SPOT_LOCATIONS(i_e)) & MU(e_ne'Id) = prj1(e_sloc)
                & {iC1,iC2} <: union(ran(RailML3_IS_NET_ELEMENT_INTRINSIC_COORDINATES(MU(e_ne'Id))))~
                & prj1(iC1) <= prj2(e_sloc) & IF prj2(e_sloc) = 1.0 THEN prj2(e_sloc) <= prj1(iC2) ELSE prj2(e_sloc) < prj1(iC2) END
                & #i_aps.(i_aps : dom(RailML3_IS_NET_ELEMENT_ASSOCIATED_POSITIONING_SYSTEM(MU(e_ne'Id))) & RailML3_IS_NET_ELEMENT_ASSOCIATED_POSITIONING_SYSTEM(MU(e_ne'Id))(i_aps)~(iC1) = pred(RailML3_IS_NET_ELEMENT_ASSOCIATED_POSITIONING_SYSTEM(MU(e_ne'Id))(i_aps)~(iC2)))
                & e_sep1 : RailML_spotElementProjection & prj2(iC1) = MU(e_sep1'refersToElement)
                & e_sep2 : RailML_spotElementProjection & prj2(iC2) = MU(e_sep2'refersToElement)
                & x1 = STRING_TO_REAL(MU(MU(e_sep1'coordinate)'x))/INCH_FACTOR & y1 = STRING_TO_REAL(MU(MU(e_sep1'coordinate)'y))/INCH_FACTOR
                & x2 = STRING_TO_REAL(MU(MU(e_sep2'coordinate)'x))/INCH_FACTOR & y2 = STRING_TO_REAL(MU(MU(e_sep2'coordinate)'y))/INCH_FACTOR
                |
                    {rec(shape:"point", nodes: i_e, `id`: i_e, xlabel: IF DISPLAY_NAMES = TRUE & i_e |-> LANGUAGE : dom(RailML3_CO_NAMES) THEN i_e^" ("^RailML3_CO_NAMES(i_e,LANGUAGE)^")" ELSE i_e END, pos: TO_STRING(x1 + ((prj2(e_sloc) - prj1(iC1)) / (prj1(iC2) - prj1(iC1))) * (x2-x1) )^","^TO_STRING(y1 + ((prj2(e_sloc) - prj1(iC1)) / (prj1(iC2) - prj1(iC1))) * (y2-y1) )^"!", height: IF i_e : RailML3_IS_MOVABLE_CROSSING_IDS \/ SWITCHES(DISPLAY_SWITCHES) THEN "0.075" ELSIF i_e : DERAILERS(DISPLAY_DERAILERS) \/ RailML3_IL_SIGNAL_CONTROLLED THEN "0.05" ELSE "0.025" END, width: IF i_e : RailML3_IS_MOVABLE_CROSSING_IDS \/ SWITCHES(DISPLAY_SWITCHES) THEN "0.075" ELSIF i_e : DERAILERS(DISPLAY_DERAILERS) \/ RailML3_IL_SIGNAL_CONTROLLED THEN "0.05" ELSE "0.025" END, fontsize: IF i_e : RailML3_IS_MOVABLE_CROSSING_IDS \/ SWITCHES(DISPLAY_SWITCHES) \/ DERAILERS(DISPLAY_DERAILERS) \/ RailML3_IL_SIGNAL_CONTROLLED THEN "5" ELSE "4" END)}
                ),
        // Virtual nodes for netElements (only available with exact position):
        nodes2:
            UNION(i_e, e_sep, e_coord).(e_sep : RailML_spotElementProjection & i_e = MU(e_sep'refersToElement) & e_coord = MU(e_sep'coordinate) |
                {rec(shape:"point", nodes: i_e, `id`: i_e, pos: TO_STRING(STRING_TO_REAL(MU(e_coord'x))/INCH_FACTOR)^","^TO_STRING(STRING_TO_REAL(MU(e_coord'y))/INCH_FACTOR)^"!", width:"0")}
            ),
        // Nodes for operational points (only for labelling)
        nodes3:
            UNION(i_op, e_sep, e_coord).(i_op : OPERATIONALPOINTS(DISPLAY_OPERATIONALPOINTS) & e_sep : RailML_spotElementProjection & i_op = MU(e_sep'refersToElement) & e_coord = MU(e_sep'coordinate) |
                {rec(shape:"plaintext", nodes: i_op, `id`: i_op, label: IF DISPLAY_NAMES = TRUE & i_op |-> LANGUAGE : dom(RailML3_CO_NAMES) THEN i_op^" ("^RailML3_CO_NAMES(i_op,LANGUAGE)^")" ELSE i_op END, fontsize: "12", pos: TO_STRING(STRING_TO_REAL(MU(e_coord'x))/INCH_FACTOR)^","^TO_STRING(STRING_TO_REAL(MU(e_coord'y))/INCH_FACTOR)^"!")}
            ),

        // netElement paths with exact positions:
        edges1:
            UNION(i_ne, e_ne, iC1, iC2, e_sep1, e_sep2).(e_ne : RailML3_netElement & i_ne = MU(e_ne'Id)
                & {iC1,iC2} <: union(ran(RailML3_IS_NET_ELEMENT_INTRINSIC_COORDINATES(MU(e_ne'Id))))~
                & #i_aps.(i_aps : dom(RailML3_IS_NET_ELEMENT_ASSOCIATED_POSITIONING_SYSTEM(MU(e_ne'Id))) & RailML3_IS_NET_ELEMENT_ASSOCIATED_POSITIONING_SYSTEM(MU(e_ne'Id))(i_aps)~(iC1) = pred(RailML3_IS_NET_ELEMENT_ASSOCIATED_POSITIONING_SYSTEM(MU(e_ne'Id))(i_aps)~(iC2)))
                & e_sep1 : RailML_spotElementProjection & e_sep2 : RailML_spotElementProjection & prj2(iC1) = MU(e_sep1'refersToElement) & prj2(iC2) = MU(e_sep2'refersToElement) |
                {rec(label: IF DISPLAY_NAMES = TRUE & i_ne |-> LANGUAGE : dom(RailML3_CO_NAMES) THEN i_ne^" ("^RailML3_CO_NAMES(i_ne,LANGUAGE)^")" ELSE i_ne END, `id`:i_ne, style:"filled", colour:"green", edge: prj2(iC1) |-> prj2(iC2), fontsize: "5") }
            )
        )
