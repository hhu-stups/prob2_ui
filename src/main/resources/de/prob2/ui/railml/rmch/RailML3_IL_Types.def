DEFINITIONS
    //-----------------------------------------------------------------------------
    // RailML 3: INTERLOCKING
    // descriptions taken from https://wiki3.railml.org/wiki/IL:interlocking
    //-----------------------------------------------------------------------------

    RailML3_IL_generic_Type ==
        struct(
            recId : NATURAL1,
            pId : NATURAL,
            xmlLineNumber : NATURAL1,
            type : RailML3_IL_GENERIC_TYPES
        );

    // list of various assets which are related to one single infrastructure manager
    RailML3_IL_assetsForInterlocking_Type == 
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(union(allIdsOfType[{"assetsForInterlocking", "assetsForIL"}])) // obligatory
        );

    // identifies the routes that may never be simultaneously allocated
    RailML3_IL_conflictingRoute_Type ==
        struct(
            recId : NATURAL1,
            pId : NATURAL,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("conflictingRoute")), // obligatory
            // elementNumber

            // children:
            conflictsWithRoutes : FIN(allIdsOfType("route")), // (1..*)
            refersToRoute : FIN(allIdsOfType("route")) // (1..1)
            // belongsToOperationalPoint (0..*), designator (0..*), hasCommand (0..*), hasIndication (0..*), objectName (0..*), reasonForConflict (0..*)
        );

    // The derailer is a track asset that either allows or disallows train passage. Here the functional aspects for interlocking operation are considered.
    RailML3_IL_derailerIL_Type ==
        struct(
            recId : NATURAL1,
            pId : NATURAL,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("derailerIL")), // obligatory
            preferredPosition : FIN(RailML3_IL_DERAILER_POSITIONS), // optional
            returnsToPreferredPosition : BOOL, // optional
            isKeyLocked : BOOL, // optional
            maxThrowTime : NATURAL, // optional; default 0 ms
            typicalThrowTime : NATURAL, // optional; default 0 ms

            // children:
            refersTo : FIN(allIdsOfType("derailerIS")), // (1..2)
            hasGaugeClearanceMarkers : FIN(allIdsOfType("trainDetectionElement")), // (0..2)
            hasTvdSection : FIN(allIdsOfType("tvdSection")), // (0..1)
            relatedMovableElement : FIN(union(allIdsOfType[{"movableCrossing", "derailerIL", "switchIL"}])) // (0..1)
            // lockedTrack (0..2)
        );

    // Crossings are a special item for interlockings as a position is required for them even if there is no really movable item trackside. Here the functional aspects for interlocking operation are considered.
    RailML3_IL_movableCrossing_Type ==
        struct(
            recId : NATURAL1,
            pId : NATURAL,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("movableCrossing")), // obligatory
            preferredPosition : FIN(RailML3_IL_CROSSING_POSITIONS), // optional
            returnsToPreferredPosition : BOOL, // optional
            isKeyLocked : BOOL, // optional
            maxThrowTime : NATURAL, // optional; default 0 ms
            typicalThrowTime : NATURAL, // optional; default 0 ms

            // children:
            refersTo : FIN(RailML3_IS_SWITCH_IDS \/ allIdsOfType("crossing")), // (1..2)
            branchDownLeft : FIN(union(allIdsOfType[{"netElement", "track"}])), // (1..1)
            branchDownRight : FIN(union(allIdsOfType[{"netElement", "track"}])), // (1..1)
            branchUpLeft : FIN(union(allIdsOfType[{"netElement", "track"}])), // (1..1)
            branchUpRight : FIN(union(allIdsOfType[{"netElement", "track"}])), // (1..1)
            hasGaugeClearanceMarkers : FIN(allIdsOfType("trainDetectionElement")), // (0..2)
            hasFoulingTrainDetectors : FIN(allIdsOfType("trainDetectionElement")), // (0..*)
            hasTvdSection : FIN(allIdsOfType("tvdSection")), // (0..1)
            relatedMovableElement : FIN(union(allIdsOfType[{"movableCrossing", "derailerIL", "switchIL"}])) // (0..1)
        );

    // track(s) in advance of a stop signal, or a stopping point in a continuous signalling system,
    // which must be kept clear to avoid the risk of collision should a train inadvertently run past the signal or the stopping point
    RailML3_IL_overlap_Type ==
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("overlap")), // obligatory
            //releaseSpeed: FIN(REAL), // optional
            //overlapSpeed: FIN(REAL), // optional
            overlapValidityTime: NATURAL, // optional; default: 0,
            length: FIN(REAL), // optional,
            //elementNumber: FIN(NATURAL), // optional

            // children:
            activeForApproachRoutes: FIN(allIdsOfType("route")), // (0..*) 
            //additionalRelation (0..*), belongsToOperationalPoint (0..*), designator (0..*), hasCommand (0..*), hasIndication (0..*), objectName (0..*), requiresLevelCrossingInState (0..*)          
            hasTvdSections : FIN(allIdsOfType("tvdSection")), // (0..*)
            isLimitedBy: FIN(union(allIdsOfType[{"bufferStop", "trainDetectionElement", "switchIL"}])), //(0..*)
            relatedToTrackAsset: FIN(allIdsOfType("signalIL")), // (0..1)
            overlapRelease: FIN(RailML3_IL_overlapRelease_Type), // (0..1), 
            requiresSwitchInPosition: FIN(RailML3_IL_requiredSwitchPosition_Type) // (0..*)
        );

    /* Overlap is set in lockstep with the route. The interlocking releases the overlap when it is safe to presume that an
    approaching train will not overrun a closed destination signal. When the train occupied the last section (or destination area),
    an overlap release timer starts running. The timer value is defined by operational rules and the approaching speed. Upon expiry,
    the interlocking releases the overlap. Overlap is released together with the route or after expiration of the release timer.
    Overlap is released after a defined time in a timer that starts from a timerTriggerPoint.*/
    RailML3_IL_overlapRelease_Type ==
        struct(
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("overlapRelease")), // obligatory

            // children:
            overlapReleaseTimer: FIN(RailML3_IL_overlapReleaseTimer_Type), // (1..*)
            releaseTriggerSection: FIN(allIdsOfType("tvdSection")) // (0..1)
        );

        // Description of overlap release timer (duration, start condition)
        RailML3_IL_overlapReleaseTimer_Type ==
            struct(
                xmlLineNumber : NATURAL1,

                // attributes:
                timerValue : NATURAL, // obligatory
                overlapReleaseCondition: FIN(RailML3_IL_OVERLAP_RELEASE_CONDITIONS) // optional            
            );

    // path for train movements in railway network secured by interlocking system
    RailML3_IL_route_Type ==
        struct(
            recId : NATURAL1,
            pId : NATURAL,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("route")), // obligatory
            locksAutomatically : BOOL, // optional
            processingDelay : NATURAL, // optional
            proceedAspectDelay : NATURAL, // optional
            signalClosureDelay : NATURAL, // optional
            approachReleaseDelay : NATURAL, // optional
            residualRouteReleaseDelay : NATURAL, // optional
            priorityRank : FIN(NATURAL), // optional
            // elementNumber

            // children:
            additionalRelations : allIdsOfType("routeRelation") +-> FIN(RailML3_IL_ROUTE_RELATION_TYPES), // (0..*)
            hasTvdSections : FIN(allIdsOfType("tvdSection")), // (0..*)
            hasReleaseGroups : FIN(union(allIdsOfType[{"routeReleaseGroupAhead", "routeReleaseGroupRear"}])), // (0..*)
            routeActivationSections : FIN(RailML3_IL_routeActivationSection_Type), // (0..*)
            facingSwitchInPositions : FIN(RailML3_IL_switchInPosition_Type), // (0..*)
            trailingSwitchInPositions : FIN(RailML3_IL_switchInPosition_Type), // (0..*)
            switchPositionsInDepartureTrack : FIN(RailML3_IL_switchInPosition_Type), // (0..*)
            routeEntry : FIN(RailML3_IL_routeEntry_Type), // (1..1)
            routeExit : FIN(RailML3_IL_routeExit_Type) // (1..1)
            // assetName (0..*), belongsToOperationalPoint (0..1), designator (0..*), hasCommand (0..*), hasIndication (0..*), hasIndicator (0..*), hasRepeater (0..*), protectsBlockExit (0..*)
        );

        // Description of the route activation, i.e. automatic setting or locking when the route entry is approached.
        RailML3_IL_routeActivationSection_Type ==
            struct(
                xmlLineNumber : NATURAL1,

                // attributes:
                Id : FIN(allIdsOfType("routeActivationSection")), // obligatory since RailML 3.2
                delayForLock : NATURAL, // optional; default: 0
                automaticReleaseDelay : NATURAL, // optional; default: 0

                // children:
                activationSections : FIN(union(allIdsOfType[{"routeActivationSection", "tvdSection"}])) // (1..*)
            );

        // Description of the start point of the route. This is normally a signal.
        RailML3_IL_routeEntry_Type ==
            struct(
                xmlLineNumber : NATURAL1,

                // attributes:
                Id : FIN(allIdsOfType("routeEntry")), // obligatory
                // elementNumber

                // children:
                refersTo : FIN(dom(all_ids)), // (1..1)
                nonReplacement : FIN(allIdsOfType("tvdSection")) // (0..*)
                // belongsToOperationalPoint (0..*), designator (0..*), hasCommand (0..*), hasIndication (0..*), hasIndicator (0..1), hasSignalIndicator (0..1), nonReplacement (0..*), objectName (0..*)
            );

        // Description of the route destination point. In most cases the route destination is a signal or a buffer stop.
        RailML3_IL_routeExit_Type ==
            struct(
                xmlLineNumber : NATURAL1,

                // attributes:
                Id : FIN(allIdsOfType("routeExit")), // obligatory
                // elementNumber

                // children:
                refersTo : FIN(dom(all_ids)), // (1..1)
                hasOverlaps : FIN(allIdsOfType("overlap")) // (0..*)
                // belongsToOperationalPoint (0..*), designator (0..*), hasCommand (0..*), hasDangerPoint (0..1), hasIndication (0..*), hasIndicator (0..1), objectName (0..*)
            );

    // states the conditions that must be fulfilled for a given signal to be open
    RailML3_IL_routeRelation_Type ==
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("routeRelation")), // obligatory
            //elementNumber: FIN(NATURAL), // optional

            // children:
            // belongsToOperationalPoint (0..*), designator (0..*), hasCommand (0..*), hasIndication (0..*), objectName (0..*)
            //requiredCrossingPosition (0..*), 
            requiredDerailerPosition: FIN(RailML3_IL_requiredDerailerPosition_Type), // (0..*)
            requiredDetectorState: FIN(RailML3_IL_requiredDetectorState_Type), // (0..*)
            //requiredKeyLockState (0..*), requiredLevelCrossingState (0..*),
            requiredSectionState : FIN(RailML3_IL_requiredSectionState_Type), // (0..*)
            //requiredSignalAspect (0..*),
            requiredSwitchPosition: FIN(RailML3_IL_requiredSwitchPosition_Type) // (0..*)
            //equiredTunnelGateState (0..*)
        );

        // 	References to a particular derailer and its required position to fulfil the route relation
        RailML3_IL_requiredDerailerPosition_Type ==
            struct(
                xmlLineNumber : NATURAL1,

                // attributes:
                mustOrShould : RailML3_IL_REQUIRE_ENFORCEMENT_LEVELS, // optional; default: must
                proving : RailML3_IL_REQUIRE_PROVING_TYPES, // optional; default: oneOff
                isNegated : BOOL, // optional; default: FALSE

                // children:
                relatedDerailerAndPosition : FIN(RailML3_IL_derailerInPosition_Type) // (1..1)
            );

            // This is the reference and the state/position of the derailer of the relation.
            RailML3_IL_derailerInPosition_Type ==
                struct(
                    xmlLineNumber : NATURAL1,

                    // attributes:
                    inPosition : FIN(RailML3_IL_DERAILER_POSITIONS), // obligatory
                    isNegated : BOOL, // optional; default: FALSE

                    // children:
                    refersToDerailer : FIN(allIdsOfType("derailerIL")) // (1..1)
                );

        // References to a particular detector and its required state to fulfil the route relation
        RailML3_IL_requiredDetectorState_Type ==
            struct(
                xmlLineNumber : NATURAL1,

                // attributes:
                mustOrShould : RailML3_IL_REQUIRE_ENFORCEMENT_LEVELS, // optional; default: must
                proving : RailML3_IL_REQUIRE_PROVING_TYPES, // optional; default: oneOff
                isNegated : BOOL, // optional; default: FALSE

                // children:
                relatedDetectorAndState : FIN(RailML3_IL_relatedDetectorAndState_Type) // (1..1)
            );

            // the tuple of references to the detector and its state
            RailML3_IL_relatedDetectorAndState_Type ==
                struct(
                    xmlLineNumber : NATURAL1,

                    // attributes:
                    inState : FIN(RailML3_IL_DETECTOR_STATES), // obligatory
                    isNegated : BOOL, // optional; default: FALSE

                    // children:
                    refersToDetector : FIN(allIdsOfType("trainDetectionElement")) // (1..1)
                );

        //	References to a particular TVD section and its required state to fulfil the route relation
        RailML3_IL_requiredSectionState_Type ==
            struct(
                xmlLineNumber : NATURAL1,

                // attributes:
                mustOrShould : RailML3_IL_REQUIRE_ENFORCEMENT_LEVELS, // optional; default: must
                proving : RailML3_IL_REQUIRE_PROVING_TYPES, // optional; default: oneOff
                isNegated : BOOL, // optional; default: FALSE

                // children:
                relatedSectionAndVacancy : FIN(RailML3_IL_relatedSectionAndVacancy_Type) // (1..1)
            );

            // the tuple of references to the TVD section and its state plus the level of enforcement
            RailML3_IL_relatedSectionAndVacancy_Type ==
                struct(
                    xmlLineNumber : NATURAL1,

                    // attributes:
                    inState : FIN(RailML3_IL_TVD_SECTION_STATES), // obligatory
                    isNegated : BOOL, // optional; default: FALSE

                    // children:
                    refersToSection : FIN(allIdsOfType("tvdSection")) // (1..1)
                );

        // References to a particular switch and its required position to fulfil the route relation
        RailML3_IL_requiredSwitchPosition_Type ==
            struct(
                xmlLineNumber : NATURAL1,

                // attributes:
                mustOrShould : RailML3_IL_REQUIRE_ENFORCEMENT_LEVELS, // optional; default: must
                proving : RailML3_IL_REQUIRE_PROVING_TYPES, // optional; default: oneOff
                isNegated : BOOL, // optional; default: FALSE

                // children:
                relatedSwitchAndPosition : FIN(RailML3_IL_switchInPosition_Type) // (1..1)
            );

            // the tuple of references to the switch and its position
            RailML3_IL_switchInPosition_Type ==
                struct(
                    xmlLineNumber : NATURAL1,

                    // attributes:
                    inPosition : FIN(RailML3_IL_SWITCH_POSITIONS), // obligatory
                    isNegated : BOOL, // optional; default: FALSE

                    // children:
                    refersToSwitch : FIN(allIdsOfType("switchIL")) // (1..1)
                );
    
    // Ahead: One or more TVD sections as part of the route which can be released in a group ahead of the train in standstill.
    // Rear: One or more TVD sections as part of the route which can be released in a group in rear of passing train.
    RailML3_IL_routeReleaseGroupAheadRear_Type ==
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(union(allIdsOfType[{"routeReleaseGroupAhead", "routeReleaseGroupRear"}])), // obligatory
            typicalDelay : NATURAL, // optional; default: 0 ms
            isAutomatic : BOOL, // optional; default: FALSE
            // delay, elementNumber

            // children:
            hasTvdSections : FIN(allIdsOfType("tvdSection")) // (0..*)
            // belongsToOperationalPoint (0..*), designator (0..*), hasCommand (0..*), hasIndication (0..*), objectName (0..*)
        );

    // The signal is a track asset used to transmit information to the train driver represented by its optical appearance.
    RailML3_IL_signalIL_Type ==
        struct(
            recId : NATURAL1,
            pId : NATURAL,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("signalIL")), // obligatory
            releaseSpeed : FIN(REAL), // optional
            malfunctionSpeed : FIN(REAL), // optional
            approachSpeed : FIN(REAL), // optional
            passingSpeed : FIN(REAL), // optional
            function : FIN(RailML3_IL_SIGNAL_FUNCTION_TYPES), // optional
            isNotWired : BOOL, // optional
            // releaseDelay, callOnAspectTime, sightDistance, elementNumber

            // children:
            refersTo : FIN(allIdsOfType("signalIS")) // (0..1)
            // assetName (0..*), belongsToOperationalPoint (0..1), designator (0..*), hasCommand (0..*), hasIndication (0..*), hasIndicator (0..*), hasRepeater (0..*), protectsBlockExit (0..*)
        );

    // The switch is a track asset where a train can change from one track to another. Here the functional aspects for interlocking operation are considered.
    RailML3_IL_switchIL_Type ==
        struct(
            recId : NATURAL1,
            pId : NATURAL,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("switchIL")), // obligatory
            preferredPosition : FIN(RailML3_IL_SWITCH_POSITIONS), // optional
            returnsToPreferredPosition : BOOL, // optional
            isKeyLocked : BOOL, // optional
            maxThrowTime : NATURAL, // optional; default 0 ms
            typicalThrowTime : NATURAL, // optional; default 0 ms

            // children:
            refersTo : FIN(RailML3_IS_SWITCH_IDS \/ allIdsOfType("crossing")), // (1..2)
            branchLeft : FIN(union(allIdsOfType[{"netElement", "track"}])), // (1..1)
            branchRight : FIN(union(allIdsOfType[{"netElement", "track"}])), // (1..1)
            branchTip : FIN(union(allIdsOfType[{"netElement", "track"}])), // (1..1)
            hasGaugeClearanceMarkers : FIN(allIdsOfType("trainDetectionElement")), //(0..2)
            hasFoulingTrainDetectors : FIN(allIdsOfType("trainDetectionElement")), //(0..*)
            hasPositionRestriction: FIN(RailML3_IL_hasPositionRestriction_Type), // (0..1)
            hasTvdSection : FIN(allIdsOfType("tvdSection")), //(0..1)
            relatedMovableElement : FIN(union(allIdsOfType[{"movableCrossing", "derailerIL", "switchIL"}])) // (0..1) //(0..1)
        );

        // It defines the position the related element shall have when the switch is to be switched in the given position.
        RailML3_IL_hasPositionRestriction_Type ==
            struct(
                xmlLineNumber : NATURAL1,

                // attributes:
                restrictedPosition : FIN(RailML3_IL_SWITCH_POSITIONS), // obligatory

                // children:
                relatedDerailerInPosition : FIN(RailML3_IL_derailerInPosition_Type), // (0..1)
                relatedSwitchInPosition : FIN(RailML3_IL_switchInPosition_Type) // (0..1), will cause invariant violation until IL_SIGNAL_IDS are computed
            );

    // track vacancy detection (TVD) section reports train occupancy to the interlocking
    RailML3_IL_tvdSection_Type ==
        struct(
            recId : NATURAL1,
            pId : NATURAL,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("tvdSection")), // obligatory
            isBerthingTrack : BOOL, // optional
            technology : FIN(RailML3_IL_TVD_SECTION_TECHNOLOGY_TYPES), // optional
            // residualRouteCancellationDelay, partialRouteReleaseDelay, frequency, elementNumber

            // children:
            hasDemarcatingBufferstops : FIN(allIdsOfType("bufferStop") \/ RailML3_IS_OPENEND_IDS), // (0..2)
            hasDemarcatingTraindetectors : FIN(allIdsOfType("trainDetectionElement")) // (0..*)
            // hasExitSignal : FIN(allIdsOfType("signalIS")) // (0..2)
            // belongsToOperationalPoint (0..1)
            // hasCommand (0..*), hasIndication (0..*), hasResetStrategy (0..1), hasTrackElement (0..*), hasTrainNumberField (0..*)            
        );

    // --------------------------

    // Container with the characteristics of an individual interlocking system.
    RailML3_IL_signalBox_Type ==
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("signalBox")), // obligatory
            //model, softwareVersion
            //elementNumber: FIN(NATURAL), // optional

            // children:
            // belongsToInfrastructureManager (0..1), belongsToOperationalPoint (0..*), connectedToRadioBlockCentre (0..*), controlledBy (0..*), controlsCombinedRoute (0..*), controlsInterface (0..*), controlsRoute (0..*), controlsSystemAsset (0..*), controlsTrackAsset (0..*), designator (0..*), hasCommand (0..*), hasCommunicationSettings (0..*), hasConfiguration (0..*), hasConflictingRoutes (0..*), hasIndication (0..*), hasName (0..1), hasPermissionZone (0..*), implementsElementGroup (0..*),
            implementsSignalplans : FIN(RaiML3_IL_implementsSignalplan_Type) // (0..*)
        );

        // The references to the signal plans the interlocking uses
        RaiML3_IL_implementsSignalplan_Type ==
            struct(
                xmlLineNumber : NATURAL1,

                // attributes:
                //refersTo : STRING // id of parent signalBox
                //model, softwareVersion
                //elementNumber: FIN(NATURAL), // optional

                // children:
                aspectRelations : FIN(RaiML3_IL_aspectRelation_Type) // (1..*)
            );

            // One aspect relation has a) one master signal showing a given aspect b) one or more slaves showing a given aspect. The slave aspect depends on the master aspect. c) an optional overlap when the master aspect is at danger.
            // The path from slave to master may contain switches. The switch positions are given in order to unequivocally determine the path.
            RaiML3_IL_aspectRelation_Type ==
                struct(
                    xmlLineNumber : NATURAL1,

                    // attributes:
                    Id : FIN(allIdsOfType("aspectRelation")), // obligatory
                    passingSpeed : FIN(REAL), // optional
                    expectingSpeed : FIN(REAL), // optional
                    endSectionTime: NATURAL, // optional; default: 0

                    // children:
                    appliesToRoutes : FIN(allIdsOfType("route")), // (0..*)
                    //designator (0..*)
                    distantAspects : FIN(RaiML3_IL_aspect_Type), // (0..*)
                    masterAspect : FIN(RaiML3_IL_aspect_Type), // (0..1)
                    //signalsSpeedProfile (0..*)
                    slaveAspect : FIN(RaiML3_IL_aspect_Type) // (0..1)
                );

                // The combination of the signal and the aspect it is showing.
                RaiML3_IL_aspect_Type ==
                    struct(
                        xmlLineNumber : NATURAL1,

                        // attributes:
                        isNegated : BOOL, // optional

                        // children:
                        refersToSignal : FIN(allIdsOfType("signalIL")), // (1..1)
                        showsAspects : FIN(allIdsOfType("hasAspect")) // (1..*)
                    );

    // --------------------------

    // Container with the generic classification of types used by a specific infrastructure manager.
    RailML3_IL_specificInfrastructureManager_Type ==
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(union(allIdsOfType[{"specificInfrastructureManager", "specificIM"}])),//, // obligatory
            //model, softwareVersion
            //elementNumber: FIN(NATURAL), // optional

            // children:
            // belongsToInfrastructureManager (1..1), designator (0..*), ownsSetsOfAssets (0..*),
            usesTypes : FIN(RailML3_IL_usesTypes_Type) // (1..1)
        );

        // The types defined for this IM.
        RailML3_IL_usesTypes_Type ==
            struct(
                xmlLineNumber : NATURAL1,

                // attributes:

                // children:
                hasAspects : FIN(RailML3_IL_hasAspect_Type) // (2..*)
                //hasDetectorTypes (0..*), hasElementGroupType (0..*), hasHmiIndication (0..*), hasLevelCrossingType (0..*), hasOperatorCommand (0..*), hasRouteType (1..*), hasTVDresetStrategy (0..*)
            );

            // Classification of signal aspects.
            RailML3_IL_hasAspect_Type ==
                struct(
                    xmlLineNumber : NATURAL1,

                    // attributes:
                    Id : FIN(STRING), // obligatory
                    genericAspect : FIN(RailML3_IL_SIGNAL_GENERIC_ASPECTS) // obligatory

                    // children:
                    // designator (0..*)
                );