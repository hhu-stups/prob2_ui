RULES_MACHINE RailML3_readFile
SETS
    SUPPORTED_VERSIONS = {v3_1, v3_2}
DEFINITIONS
    "LibraryStrings.def";    
    "LibraryXML.def"
ABSTRACT_CONSTANTS
    elementsOfType, childsOfElementType, allIdsOfType
CONCRETE_CONSTANTS
    file, data /*@desc the complete imported railML file by READ_XML */, all_ids
PROPERTIES
    data = READ_XML(file, "auto")
    & elementsOfType = %type.(type : STRING | { e | e : ran(data) & e'element = type } )
    & childsOfElementType = %(type, pId).(type : STRING & pId : NATURAL | { e | e : elementsOfType(type) & e'pId = pId } )
    & all_ids = { i, t | #e.(e : ran(data) & "id" : dom(e'attributes) & i = e'attributes("id") & t = e'element |-> e'recId) }
    & allIdsOfType = %type.( type : STRING | all_ids~[{type} * ran(ran(all_ids))] )
OPERATIONS
    RULE is_supported_railml
    CLASSIFICATION syntax
    BODY
        RULE_FAIL e
        WHEN
            1 : dom(data) & e = STRING_TO_LOWER(data(1)'element) & e /= "railml"
        COUNTEREXAMPLE
            "Provided XML file is not a railML file, found type '"^e^"'"
        END;
        RULE_FAIL v
        WHEN
            v = data(1)'attributes("version") & v /: {"3.1", "3.2"}
        COUNTEREXAMPLE
            "RailML version "^v^" is currently not supported"
        END
    END;

    RULE unique_ids
    CLASSIFICATION syntax
    DEPENDS_ON_RULE is_supported_railml
    BODY
        RULE_FAIL duplic_i
        WHEN
            duplic_i : dom(all_ids) & card(all_ids[{duplic_i}]) > 1
        COUNTEREXAMPLE
            "All IDs must be unique, ID '"^duplic_i^"' is not unique"
        END
    END;

    COMPUTATION read_file
    DEPENDS_ON_RULE unique_ids
    BODY
        DEFINE version
            TYPE FIN(SUPPORTED_VERSIONS)
            VALUE {TYPED_STRING_TO_ENUM(SUPPORTED_VERSIONS, "v"^STRING_REPLACE(data(1)'attributes("version"),".","_") )}
        END
    END
END
