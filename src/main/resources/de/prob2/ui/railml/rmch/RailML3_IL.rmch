/*
RailML3 Interlocking Rules
------------------------------
Reads RailML3 interlocking from XML "data" in "RailML_readFile.rmch" and creates a new set per element type by a computation.
The type of the set is specific for each element type. Types are specified in "RailML3_CO_Types.def".
Childs with finite cardinality (e.g. (0..1), (1..1) or (0..2)) or properties which can be listed easily (e.g. string refs in a set (0..*))
are included in their parent; others stored as types separatly.
Necessary rules that must hold for valid RailML data are checked on this sets. They only check the pure railML schematic rules;
specific constraints for B are validated in RailML_validation.mch.
Sets for animation are created after successful validation of the data.

The general procedure for each element type is:
    - Computation "set_xyz":
        Search data for all elements of type "xyz" -> Compute RailML_xyz of B-type RailML3_IS_xyz_Type to guarantee correct types of attributes
    - Rule is_valid_xyz:
        Validation of the correct cardinality of the elements themselves and of the attributes
        Validate whether the element xyz has the correct parent element; if successful, xyz is fully validated
    - Rule warnings_xyz
        When a default value was set for a not available attribute and the default value is not part of the railML schema a warning should be prompted
    - Computation(s) set_IL_XYZ(_IDS):
        Convert selected data into a structure that is used for animation.
    - Rule validate_xyz
        Semantic validation rules are implemented here.
    - Rule warnings_xyz
        When a default value was set for a not available attribute and the default value is not part of the railML schema a warning should be prompted.
        Additional semantical rules can also be written as a warning if they are not crucial for the functioning of the model.
*/
RULES_MACHINE RailML3_IL
REFERENCES RailML3_IS, RailML3_VIS, RailML3_readFile
SETS
    RailML3_IL_GENERIC_TYPES = {interlocking, assetsForInterlockings, assetsForInterlocking, conflictingRoutes, derailersIL, movableCrossings,
        overlaps, routeReleaseGroupsAhead, routeReleaseGroupsRear, routeRelations, routes, signalsIL, switchesIL, tvdSections,
        signalBoxes,
        specificInfrastructureManagers, specificIMs};

    // Attribute Types:
    RailML3_IL_CROSSING_POSITIONS = {`position_downleft-rightup`, `position_upleft-rightdown`};
    RailML3_IL_DERAILER_POSITIONS = {position_derailingPosition, position_passablePosition};
    RailML3_IL_DETECTOR_STATES = {detector_activated, detector_deactivated, detector_inactive};
    RailML3_IL_OVERLAP_RELEASE_CONDITIONS = {overlap_startTimerAfterVacating, overlap_startTimerUponOccupation, trainInitiatedTrigger};
    RailML3_IL_REQUIRE_ENFORCEMENT_LEVELS = {require_must, require_none, require_should};
    RailML3_IL_REQUIRE_PROVING_TYPES = {proving_continuously, proving_oneOff, proving_staffAcknowledged};
    RailML3_IL_ROUTE_RELATION_TYPES = {relation_asOppositeSignal, relation_inFlankProtection, relation_inHeadProtection, relation_inOverlapProtection, inRunningPath};
    RailML3_IL_SIGNAL_FUNCTION_TYPES = {function_barrage, function_block, function_blockInterface, function_distant, function_entry, function_exit, 
        function_group, function_intermediate, function_intermediateStop, function_junction, function_lineInterface, function_main, `function_main+shunting`,
        function_repeater, function_shunting, `function_other:blocking`, `function_other:end`};
    RailML3_IL_SIGNAL_GENERIC_ASPECTS = {aspect_callOn, aspect_caution, aspect_closed, aspect_combinedProceed, aspect_informative, aspect_limitedProceed,
        aspect_proceed, aspect_restriction, aspect_supplementary, aspect_warning};
    RailML3_IL_SWITCH_POSITIONS = {position_left, position_right};
    RailML3_IL_TVD_SECTION_STATES = {tvd_occupied, tvd_unknown, tvd_vacant};
    RailML3_IL_TVD_SECTION_TECHNOLOGY_TYPES = {technology_axleCounter, technology_trackCircuit}
DEFINITIONS
    "CHOOSE.def";    
    "LibraryIO.def";
    "LibraryRegex.def";
    "LibraryStrings.def";
    "SORT.def";
    "RailML3_IL_Types.def";
    
    elementOfId(Set, eId) == MU( { e | e : Set & eId = MU(e'Id)} );
    readDuration(durString) ==
        IF REGEX_MATCH(durString, "PT\d+S") THEN
            STRING_TO_INT(STRING_SPLIT(REGEX_SEARCH_STR(durString,"\d+S"), "S")(1))*1000
        ELSIF REGEX_MATCH(durString, "PT\d+M\d+S") THEN
            STRING_TO_INT(STRING_SPLIT(REGEX_SEARCH_STR(durString,"\d+M"), "M")(1))*60000 + STRING_TO_INT(STRING_SPLIT(REGEX_SEARCH_STR(durString,"\d+S"), "S")(1))*1000
        ELSIF REGEX_MATCH(durString, "PT\d+M") THEN
            STRING_TO_INT(STRING_SPLIT(REGEX_SEARCH_STR(durString,"\d+M"), "M")(1))*60000
        ELSE
            0
        END;
    ignoreDirection(Relation) == dom({ r, cr | cr : Relation & r = prj1(prj1(cr)) |-> prj1(prj2(cr)) });
    addDirection(Relation) == dom({ r1_r2, cr | cr : Relation & prj1(r1_r2) : {prj1(cr),prj2(cr)} * {direction_normal, direction_reverse} & prj2(r1_r2) : {prj1(cr),prj2(cr)} * {direction_normal, direction_reverse} & r1_r2 : RailML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS });
    inverseDirectedRelation(Relation) == dom({ ir, r | r : Relation & ir = prj1(prj2(r)) |-> oppositeDirection(prj2(prj2(r))) |-> (prj1(prj1(r)) |-> oppositeDirection(prj2(prj1(r)))) });
    lengthBetweenPositionsOnRelation(Pos1, Pos2, Relation) ==
        SIGMA(bl, begin).( begin : dom(Relation) & begin /: ran(Relation) & bl = prj1(prj1(begin)) & RailML3_IS_NET_ELEMENT_LENGTHS(bl) /= -1.0 | RailML3_IS_NET_ELEMENT_LENGTHS(bl) )
        + SIGMA(bl, begin, end).( begin : dom(Relation) & begin /: ran(Relation) & end /: dom(Relation) & end : ran(Relation) & bl : dom(dom(ran(Relation))) - dom(dom({begin,end})) & RailML3_IS_NET_ELEMENT_LENGTHS(bl) /= -1.0 | RailML3_IS_NET_ELEMENT_LENGTHS(bl) )
        + SIGMA(bl, end).( end /: dom(Relation) & end : ran(Relation) & bl = prj1(prj1(end)) & RailML3_IS_NET_ELEMENT_LENGTHS(bl) /= -1.0 | RailML3_IS_NET_ELEMENT_LENGTHS(bl) );

    genericILType(TypeAsString) == 
        dom({e, e_g | e_g : elementsOfType(TypeAsString)
                    & e = rec(
                            recId:e_g'recId,
                            pId:e_g'pId,
                            xmlLineNumber:STRING_TO_INT(e_g'meta("xmlLineNumber")),
                            type:TYPED_STRING_TO_ENUM(RailML3_IL_GENERIC_TYPES, TypeAsString)
                        ) });

    oppositeDirection(Dir) == IF Dir = direction_normal THEN direction_reverse ELSE direction_normal END;
    negatedDerailerPosition(Position) == IF Position = position_derailingPosition THEN position_passablePosition ELSE position_derailingPosition END;
    negatedSectionState(State) == IF State = tvd_occupied THEN tvd_vacant ELSIF State = tvd_vacant THEN tvd_occupied ELSE tvd_unknown END;
    negatedSwitchPosition(Position) == IF Position = position_left THEN position_right ELSE position_left END;

    errorCard(TypeAsString, Set, MinNr, MaxNr, ActualNr) == 
        STRING_FORMAT("[Lines ~w]: expected min. ~w and max. ~w elements of type '"^TypeAsString^"', but were ~w", dom({ nr, e | e : Set & nr = e'xmlLineNumber }), MinNr, MaxNr, ActualNr);
    errorCardOnlyLowerBound(TypeAsString, Set, MinNr, ActualNr) == 
        STRING_FORMAT("[Lines ~w]: expected min. ~w elements of type '"^TypeAsString^"', but were ~w", dom({ nr, e | e : Set & nr = e'xmlLineNumber }), MinNr, ActualNr);
    errorAttribute(AttrNameAsString, TypeAsString, lineNr) ==
        STRING_FORMAT("[Line ~w]: expected obligatory attribute '"^AttrNameAsString^"' for element '"^TypeAsString^"' is missing", lineNr);
    errorParent(TypeAsString, ParentTypeAsString, lineNr) == 
        STRING_FORMAT("[Line ~w]: expected parent of type '"^ParentTypeAsString^"' for type '"^TypeAsString^"'", lineNr);
    errorParentMultipleTypes(TypeAsString, SetOfParentTypesAsString, lineNr) == 
        STRING_FORMAT("[Line ~w]: expected parent of types '~w' for type '"^TypeAsString^"'", lineNr, SetOfParentTypesAsString);
    errorValue(TypeAsString, ExpectedValueAsString, ValueAsString, lineNr) == 
        STRING_FORMAT("[Line ~w]: expected one of the values "^ExpectedValueAsString^" for attribute '"^TypeAsString^"', but was '"^ValueAsString^"'", lineNr);
    errorReference(Attribute, ActualValue, ExpectedType, lineNr) == 
        STRING_FORMAT("[Line ~w]: Attribute '"^Attribute^"' must be an ID referencing to '"^ExpectedType^"', but was '"^ActualValue^"'", lineNr);
    warningDefaultValue(AttrNameAsString, DefaultValueAsString, lineNr) ==
        STRING_FORMAT("[Line ~w]: attribute '"^AttrNameAsString^"' not specified - set to default value '"^DefaultValueAsString^"'", lineNr);
OPERATIONS
    COMPUTATION set_interlocking
    DEPENDS_ON_COMPUTATION read_file
    BODY
        DEFINE RailML3_interlocking
            TYPE FIN(RailML3_IL_generic_Type)
            VALUE genericILType("interlocking")
        END
    END;
    RULE is_valid_interlocking
    DEPENDS_ON_COMPUTATION set_interlocking
    BODY
        RULE_FAIL c
            WHEN c = card(RailML3_interlocking) & c > 1
        COUNTEREXAMPLE 
            errorCard("interlocking", RailML3_interlocking, 0, 1, c)
        END;
        RULE_FAIL e
            WHEN e : RailML3_interlocking & e'pId /= 1
        COUNTEREXAMPLE 
            errorParent("interlocking", "railML", e'xmlLineNumber)
        END
    END;

    // BEGIN ASSETS_FOR_INTERLOCKINGS
    COMPUTATION set_assetsForInterlockings
    DEPENDS_ON_RULE is_valid_interlocking
    BODY
        DEFINE RailML3_assetsForInterlockings
            TYPE FIN(RailML3_IL_generic_Type)
            VALUE genericILType("assetsForInterlockings")
        END
    END;
    RULE is_valid_assetsForInterlockings
    DEPENDS_ON_COMPUTATION set_assetsForInterlockings
    BODY
        RULE_FAIL c
            WHEN c = card(RailML3_assetsForInterlockings) & c /: 0..card(RailML3_interlocking) // (0..1), 0 if no interlocking
        COUNTEREXAMPLE 
            errorCard("assetsForInterlockings", RailML3_assetsForInterlockings, 0, card(RailML3_interlocking), c)
        END;
        RULE_FORALL e
            WHERE e : RailML3_assetsForInterlockings & card(RailML3_interlocking) = 1
            EXPECT e'pId = MU_WD(RailML3_interlocking)'recId
        COUNTEREXAMPLE 
            errorParent("assetsForInterlockings", "interlocking", e'xmlLineNumber)
        END
    END;

    COMPUTATION set_assetsForInterlocking
    DEPENDS_ON_RULE is_valid_assetsForInterlockings
    BODY
        DEFINE RailML3_assetsForInterlocking
            TYPE FIN(RailML3_IL_assetsForInterlocking_Type)
            VALUE dom({e, e_ass | e_ass : ran(data) & e_ass'element = IF version = {v3_2} THEN "assetsForInterlocking" ELSE "assetsForIL" END
                & e = rec(recId:e_ass'recId, pId:e_ass'pId, xmlLineNumber:STRING_TO_INT(e_ass'meta("xmlLineNumber")), Id:e_ass'attributes[{"id"}]) })
        END
    END;
    RULE is_valid_assetsForInterlocking
    DEPENDS_ON_COMPUTATION set_assetsForInterlocking
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_assetsForInterlocking)
            & IF version = {v3_2} 
                THEN IF card(RailML3_assetsForInterlockings) = 1 
                    THEN c < 1
                    ELSE c /= 0
                END
            ELSE
                IF card(RailML3_interlocking) = 1
                    THEN c > 1
                    ELSE c /= 0
                END
            END // 3.2: (1..*), 0 if no assetsForInterlockings; 3.1: (0..1), 0 if no interlocking
        COUNTEREXAMPLE
            IF version = {v3_2} & card(RailML3_assetsForInterlockings) = 1
                THEN errorCardOnlyLowerBound("assetsForInterlocking", RailML3_assetsForInterlockings, 1, c)
            ELSIF version = {v3_1} & card(RailML3_interlocking) = 1
                THEN errorCard("assetsForIL", RailML3_assetsForInterlocking, 0, 1, c)
                ELSE errorCard("assetsForInterlocking", RailML3_assetsForInterlocking, 0, 0, c)
            END
        END;
        RULE_FORALL e
            WHERE e : RailML3_assetsForInterlocking & IF version = {v3_2} THEN card(RailML3_assetsForInterlockings) = 1 ELSE card(RailML3_interlocking) = 1 END
            EXPECT IF version = {v3_2} THEN e'pId = MU_WD(RailML3_assetsForInterlockings)'recId ELSE e'pId = MU_WD(RailML3_interlocking)'recId END
        COUNTEREXAMPLE 
            errorParent("assetsForInterlocking", IF version = {v3_2} THEN "assetsForInterlockings" ELSE "interlocking" END, e'xmlLineNumber)
        END
    END;

    // BEGIN CONFLICTING ROUTES
    COMPUTATION set_conflictingRoutes
    DEPENDS_ON_RULE is_valid_assetsForInterlocking
    BODY
        DEFINE RailML3_conflictingRoutes
            TYPE FIN(RailML3_IL_generic_Type)
            VALUE genericILType("conflictingRoutes")
        END
    END;
    RULE is_valid_conflictingRoutes
    DEPENDS_ON_COMPUTATION set_conflictingRoutes
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_conflictingRoutes) & c /: 0..card(RailML3_assetsForInterlocking) // (0..1), 0 if no assetsForInterlocking
        COUNTEREXAMPLE
            IF card(RailML3_assetsForInterlocking) > 0 
                THEN errorCard("conflictingRoutes", RailML3_assetsForInterlocking, 0, 1, c)
                ELSE errorCard("conflictingRoutes", RailML3_assetsForInterlocking, 0, 0, c)
            END
        END;
        RULE_FAIL e
        WHEN
            e : RailML3_conflictingRoutes & !e_ass.(e_ass : RailML3_assetsForInterlocking => e'pId /= e_ass'recId)
        COUNTEREXAMPLE
            errorParent("conflictingRoutes", "assetsForInterlocking", e'xmlLineNumber)
        END
    END;

    COMPUTATION set_conflictingRoute
    DEPENDS_ON_RULE is_valid_conflictingRoutes, validate_route
    BODY
        DEFINE RailML3_conflictingRoute
            TYPE FIN(RailML3_IL_conflictingRoute_Type)
            VALUE dom({e, e_crt | e_crt : ran(data) & e_crt'element  = "conflictingRoute"
                & e = rec(
                        recId: e_crt'recId,
                        pId: e_crt'pId,
                        xmlLineNumber: STRING_TO_INT(e_crt'meta("xmlLineNumber")),
                        Id: e_crt'attributes[{"id"}],
                        conflictsWithRoutes: dom({ i_A, e_A | e_A : childsOfElementType( "conflictsWithRoute", e_crt'recId) & i_A : e_A'attributes[{"ref"}] }),
                        refersToRoute: dom({ i_A, e_A | e_A : childsOfElementType( "refersToRoute", e_crt'recId) & i_A : e_A'attributes[{"ref"}] })
                    ) })
        END
    END;
    RULE is_valid_conflictingRoute
    DEPENDS_ON_COMPUTATION set_conflictingRoute
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_conflictingRoute) & IF card(RailML3_conflictingRoutes) = 1 THEN c = 0 ELSE c /= 0 END // (1..*), 0 if no conflictingRoutes
        COUNTEREXAMPLE
            IF card(RailML3_conflictingRoutes) = 1 
                THEN errorCardOnlyLowerBound("conflictingRoute", RailML3_conflictingRoutes, 1, c)
                ELSE errorCard("conflictingRoute", RailML3_conflictingRoute, 0, 0, c)
            END
        END;
        RULE_FAIL e
            WHEN e : RailML3_conflictingRoute & (card(e'Id) /= 1 or (card(e'Id) = 1 & MU_WD(e'Id) = ""))
        COUNTEREXAMPLE
            errorAttribute("id", "conflictingRoute", e'xmlLineNumber)
        END;
        RULE_FAIL e_crt, c
            WHEN e_crt : RailML3_conflictingRoute & c = card(e_crt'conflictsWithRoutes) & c < 1
        COUNTEREXAMPLE
            errorCardOnlyLowerBound("conflictsWithRoutes", {e_crt}, 1, c)
        END;
        RULE_FAIL e_crt, e_data
            WHEN e_crt : RailML3_conflictingRoute & e_data : childsOfElementType("conflictsWithRoute", e_crt'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "conflictsWithRoute", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_crt, c
            WHEN e_crt : RailML3_conflictingRoute & c = card(e_crt'refersToRoute) & c /= 1
        COUNTEREXAMPLE
            errorCard("refersToRoute", {e_crt}, 1, 1, c)
        END;        
        RULE_FAIL e_crt, e_data
            WHEN e_crt : RailML3_conflictingRoute & e_data : childsOfElementType("refersToRoute", e_crt'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "refersToRoute", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_crt
            WHEN e_crt : RailML3_conflictingRoute & card(e_crt'refersToRoute) = 1 & MU_WD(e_crt'refersToRoute) /: allIdsOfType("route")
        COUNTEREXAMPLE
            errorReference("refersToRoute", MU_WD(e_crt'refersToRoute), "route", e_crt'xmlLineNumber)
        END;
        RULE_FORALL e
            WHERE e : RailML3_conflictingRoute & card(RailML3_conflictingRoutes) = 1
            EXPECT e'pId = MU_WD(RailML3_conflictingRoutes)'recId
        COUNTEREXAMPLE
            errorParent("conflictingRoute", "conflictingRoutes", e'xmlLineNumber)
        END
    END;

    COMPUTATION set_CONFLICTING_ROUTE
    DEPENDS_ON_RULE is_valid_conflictingRoute
    BODY
        DEFINE RailML3_IL_CONFLICTING_ROUTES
            TYPE allIdsOfType("route") +-> FIN(allIdsOfType("route"))
            VALUE { i_rt, i_crt | #e_crt.(e_crt : RailML3_conflictingRoute & MU_WD(e_crt'refersToRoute) = i_rt & i_crt = e_crt'conflictsWithRoutes) }
        END
    END;
    // END CONFLICTING ROUTES

    // BEGIN DERAILERS
    COMPUTATION set_derailersIL
    DEPENDS_ON_RULE is_valid_assetsForInterlocking
    BODY
        DEFINE RailML3_derailersIL
            TYPE FIN(RailML3_IL_generic_Type)
            VALUE genericILType("derailersIL")
        END
    END;
    RULE is_valid_derailersIL
    DEPENDS_ON_COMPUTATION set_derailersIL
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_derailersIL) & c /: 0..card(RailML3_assetsForInterlocking) // (0..1), 0 if no assetsForInterlocking
        COUNTEREXAMPLE
            IF card(RailML3_assetsForInterlocking) > 0 
                THEN errorCard("derailersIL", RailML3_assetsForInterlocking, 0, 1, c)
                ELSE errorCard("derailersIL", RailML3_assetsForInterlocking, 0, 0, c)
            END
        END;
        RULE_FAIL e
        WHEN
            e : RailML3_derailersIL & !e_ass.(e_ass : RailML3_assetsForInterlocking => e'pId /= e_ass'recId)
        COUNTEREXAMPLE
            errorParent("derailersIL", "assetsForInterlocking", e'xmlLineNumber)
        END
    END;

    COMPUTATION set_derailerIL
    DEPENDS_ON_RULE is_valid_derailersIL
    DEPENDS_ON_COMPUTATION set_NET_ELEMENT
    BODY
        DEFINE RailML3_derailerIL
            TYPE FIN(RailML3_IL_derailerIL_Type)
            VALUE dom({e, e_der | e_der : elementsOfType("derailerIL")
                & e = rec(
                        recId: e_der'recId,
                        pId: e_der'pId,
                        xmlLineNumber: STRING_TO_INT(e_der'meta("xmlLineNumber")),
                        Id: e_der'attributes[{"id"}],
                        preferredPosition: IF "preferredPosition" : dom(e_der'attributes) THEN {TYPED_STRING_TO_ENUM(RailML3_IL_DERAILER_POSITIONS, "position_"^e_der'attributes("preferredPosition"))} ELSE {} END,
                        returnsToPreferredPosition : IF "returnsToPreferredPosition" : dom(e_der'attributes) & e_der'attributes("returnsToPreferredPosition") = "true" THEN TRUE ELSE FALSE END,
                        isKeyLocked : IF "isKeyLocked" : dom(e_der'attributes) & e_der'attributes("isKeyLocked") = "true" THEN TRUE ELSE FALSE END,
                        maxThrowTime : IF "maxThrowTime" : dom(e_der'attributes) THEN readDuration(e_der'attributes("maxThrowTime")) ELSIF "typicalThrowTime" : dom(e_der'attributes) THEN readDuration(e_der'attributes("typicalThrowTime")) + 1000 ELSE 2000 END,
                        typicalThrowTime : IF "typicalThrowTime" : dom(e_der'attributes) THEN readDuration(e_der'attributes("typicalThrowTime")) ELSIF "maxThrowTime" : dom(e_der'attributes) THEN min({readDuration(e_der'attributes("maxThrowTime")) - 1000, 1000}) ELSE 1000 END,
                        refersTo: dom({ i_A, e_A | e_A : childsOfElementType( "refersTo", e_der'recId) & i_A : e_A'attributes[{"ref"}] }),
                        hasGaugeClearanceMarkers: dom({ i_A, e_A | e_A : childsOfElementType( "hasGaugeClearanceMarker", e_der'recId) & i_A : e_A'attributes[{"ref"}] }),
                        hasTvdSection: dom({ i_A, e_A | e_A : childsOfElementType( "hasTvdSection", e_der'recId) & i_A : e_A'attributes[{"ref"}] }),
                        relatedMovableElement: dom({ i_A, e_A | e_A : childsOfElementType( "relatedMovableElement", e_der'recId) & i_A : e_A'attributes[{"ref"}] })
                    ) })
        END
    END;
    RULE is_valid_derailerIL
    DEPENDS_ON_COMPUTATION set_derailerIL
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_derailerIL) & IF card(RailML3_derailersIL) = 1 THEN c = 0 ELSE c /= 0 END // (1..*), 0 if no derailersIL
        COUNTEREXAMPLE
            IF card(RailML3_derailersIL) = 1 
                THEN errorCardOnlyLowerBound("derailerIL", RailML3_derailersIL, 1, c)
                ELSE errorCard("derailerIL", RailML3_derailerIL, 0, 0, c)
            END
        END;
        RULE_FAIL e
            WHEN e : RailML3_derailerIL & (card(e'Id) /= 1 or (card(e'Id) = 1 & MU_WD(e'Id) = ""))
        COUNTEREXAMPLE
            errorAttribute("id", "derailerIL", e'xmlLineNumber)
        END;
        RULE_FAIL e_der, c
            WHEN e_der : RailML3_derailerIL & c = card(e_der'refersTo) & c /: 1..2
        COUNTEREXAMPLE
            errorCard("refersTo", {e_der}, 1, 2, c)
        END;
        RULE_FAIL e_der, e_data
            WHEN e_der : RailML3_derailerIL & e_data : childsOfElementType("refersTo", e_der'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "refersTo", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_der, i_der
            WHEN e_der : RailML3_derailerIL & i_der : e_der'refersTo & i_der /: allIdsOfType("derailerIS")
        COUNTEREXAMPLE
            errorReference("refersTo@derailerIL", i_der, "derailerIS", e_der'xmlLineNumber)
        END;
        RULE_FAIL e_der
            WHEN e_der : RailML3_derailerIL & card(e_der'refersTo) = 1 & MU_WD(e_der'refersTo) /: allIdsOfType("derailerIS")
        COUNTEREXAMPLE
            errorReference("refersTo", MU_WD(e_der'refersTo), "derailerIS", e_der'xmlLineNumber)
        END;
        RULE_FAIL e_der, c
            WHEN e_der : RailML3_derailerIL & c = card(e_der'hasGaugeClearanceMarkers) & c > 2
        COUNTEREXAMPLE
            errorCard("hasGaugeClearanceMarker", {e_der}, 0, 2, c)
        END;
        RULE_FAIL e_der, e_data
            WHEN e_der : RailML3_derailerIL & e_data : childsOfElementType("hasGaugeClearanceMarker", e_der'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "hasGaugeClearanceMarker", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_der, e_tde, i_tde, type
            WHEN e_der : RailML3_derailerIL & i_tde : e_der'hasGaugeClearanceMarkers & e_tde : RailML3_trainDetectionElement & i_tde = MU_WD(e_tde'Id) & type : e_tde'type & type /= trainDetectionElement_clearancePoint 
        COUNTEREXAMPLE
           errorValue("hasGaugeClearanceMarker", "clearancePoint", STRING_SPLIT(TO_STRING(type), "_")(2), e_der'xmlLineNumber)
        END;
        RULE_FAIL e_der, c
            WHEN e_der : RailML3_derailerIL & c = card(e_der'hasTvdSection) & c > 1
        COUNTEREXAMPLE
            errorCard("hasTvdSection", {e_der}, 0, 1, c)
        END;
        RULE_FAIL e_der, e_data
            WHEN e_der : RailML3_derailerIL & e_data : childsOfElementType("hasTvdSection", e_der'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "hasTvdSection", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_der, c
            WHEN e_der : RailML3_derailerIL & c = card(e_der'relatedMovableElement) & c > 1
        COUNTEREXAMPLE
            errorCard("relatedMovableElement", {e_der}, 0, 1, c)
        END;
        RULE_FAIL e_der, e_data
            WHEN e_der : RailML3_derailerIL & e_data : childsOfElementType("relatedMovableElement", e_der'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "relatedMovableElement", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_der, i_der
            WHEN e_der : RailML3_derailerIL & i_der : e_der'relatedMovableElement & i_der /: union(allIdsOfType[{"movableCrossing","derailerIL","switchIL"}])
        COUNTEREXAMPLE
            errorReference("derailerIL@relatedMovableElement", i_der, "movableCrossing', 'derailerIL', or 'switchIL", e_der'xmlLineNumber)
        END;
        RULE_FORALL e
            WHERE e : RailML3_derailerIL & card(RailML3_derailersIL) = 1
            EXPECT e'pId = MU_WD(RailML3_derailersIL)'recId
        COUNTEREXAMPLE
            errorParent("derailerIL", "derailersIL", e'xmlLineNumber)
        END
    END;

    COMPUTATION set_IL_DERAILER
    DEPENDS_ON_RULE is_valid_movableCrossing, is_valid_derailerIL, is_valid_switchIL
    DEPENDS_ON_COMPUTATION set_CROSSING, set_SPOT_LOCATION, set_NET_RELATION_SUBSEQUENT_LOCATIONS
    BODY
        DEFINE RailML3_IL_DERAILER_REFERS_TO
            TYPE allIdsOfType("derailerIL") >->> allIdsOfType("derailerIS")
            VALUE { i_der_il, i_der | #e_der_il.(e_der_il : RailML3_derailerIL & MU_WD(e_der_il'Id) = i_der_il & i_der : e_der_il'refersTo ) }
        END;
        DEFINE RailML3_IL_DERAILER_HAS_TVD_SECTION
            TYPE allIdsOfType("derailerIS") +-> FIN(allIdsOfType("tvdSection"))
            VALUE fnc({ i_der, rme | #e_der.(e_der : RailML3_derailerIL & i_der : e_der'refersTo & rme : e_der'hasTvdSection) })
        END;
        DEFINE RailML3_IL_DERAILER_IS_KEY_LOCKED
            TYPE allIdsOfType("derailerIS") --> BOOL
            VALUE { i_der, ikl | i_der : allIdsOfType("derailerIS") & ikl = IF #e_der.(e_der : RailML3_derailerIL & i_der = MU_WD(e_der'refersTo) & e_der'isKeyLocked = TRUE) THEN TRUE ELSE FALSE END } 
        END;
        DEFINE RailML3_IL_DERAILER_PREFERRED_POSITION
            TYPE allIdsOfType("derailerIL") +-> RailML3_IL_DERAILER_POSITIONS
            VALUE { i_der, pref | i_der : allIdsOfType("derailerIL") & #e_der.(e_der : RailML3_derailerIL & i_der = MU_WD(e_der'Id) & pref : e_der'preferredPosition) } 
        END;
        DEFINE RailML3_IL_DERAILER_RETURNS_TO_PREFERRED_POSITION
            TYPE allIdsOfType("derailerIL") --> BOOL
            VALUE { i_der, rpp | i_der : allIdsOfType("derailerIL") & rpp = IF #e_der.(e_der : RailML3_derailerIL & i_der = MU_WD(e_der'Id) & e_der'returnsToPreferredPosition = TRUE) THEN TRUE ELSE FALSE END } 
        END;
        DEFINE RailML3_IL_DERAILER_RELATED_MOVABLE_ELEMENT
            TYPE allIdsOfType("derailerIS") +-> (allIdsOfType("crossing") \/ allIdsOfType("derailerIS") \/ RailML3_IS_SWITCH_IDS)
            VALUE
                { i_der, rme | #(e_der, rme_il).(e_der : RailML3_derailerIL & i_der : e_der'refersTo & rme_il : e_der'relatedMovableElement
                    & IF rme_il : allIdsOfType("movableCrossing") THEN rme : elementOfId(RailML3_movableCrossing, rme_il)'refersTo
                    ELSE IF rme_il : allIdsOfType("derailerIL") THEN rme : elementOfId(RailML3_derailerIL, rme_il)'refersTo
                        ELSE IF rme_il : allIdsOfType("switchIL") THEN rme : elementOfId(RailML3_switchIL, rme_il)'refersTo
                            ELSE bfalse END
                        END
                    END
                ) }
        END;
        DEFINE RailML3_IL_DERAILER_MAX_THROW_TIMES
            TYPE allIdsOfType("derailerIS") --> NATURAL
            VALUE { i_der, mtt | i_der : allIdsOfType("derailerIS") & card(RailML3_derailerIL) /= 0 & mtt = min({ time | #e_der.(e_der : RailML3_derailerIL & i_der : e_der'refersTo & time = e_der'maxThrowTime) }) }
        END;
        DEFINE RailML3_IL_DERAILER_TYPICAL_THROW_TIMES
            TYPE allIdsOfType("derailerIS") --> NATURAL
            VALUE { i_der, ttt | i_der : allIdsOfType("derailerIS") & card(RailML3_derailerIL) /= 0 & ttt = max({ time | #e_der.(e_der : RailML3_derailerIL & i_der : e_der'refersTo & time = e_der'typicalThrowTime) }) }
        END
    END;

    RULE validate_derailerIL
    DEPENDS_ON_COMPUTATION set_IL_DERAILER
    BODY
        RULE_FAIL e_der, i_der
            WHEN e_der : RailML3_derailerIL & i_der = MU_WD(e_der'Id) & RailML3_IL_DERAILER_RETURNS_TO_PREFERRED_POSITION(i_der) = TRUE & i_der /: dom(RailML3_IL_DERAILER_PREFERRED_POSITION)
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '"^i_der^"']: Derailer should return to preferred position, but no preferred position is defined", e_der'xmlLineNumber)
        END
    END;
    RULE warnings_derailerIL
    DEPENDS_ON_COMPUTATION set_IL_DERAILER
    ERROR_TYPES 2
    BODY
        RULE_FAIL e_der, e_der_imp
            WHEN e_der : elementsOfType("derailerIL") & "maxThrowTime" /: dom(e_der'attributes) & e_der_imp : RailML3_derailerIL & MU_WD(e_der_imp'Id) = e_der'attributes("id")
        COUNTEREXAMPLE
            warningDefaultValue("maxThrowTime", TO_STRING(e_der_imp'maxThrowTime), STRING_TO_INT(e_der'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_der, e_der_imp
            WHEN e_der : elementsOfType("derailerIL") & "typicalThrowTime" /: dom(e_der'attributes) & e_der_imp : RailML3_derailerIL & MU_WD(e_der_imp'Id) = e_der'attributes("id")
        COUNTEREXAMPLE
            warningDefaultValue("typicalThrowTime", TO_STRING(e_der_imp'typicalThrowTime), STRING_TO_INT(e_der'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_der, i_der, i_tvd
            WHEN e_der : RailML3_derailerIS & i_der = MU_WD(e_der'Id) & i_tvd : union(RailML3_IL_DERAILER_HAS_TVD_SECTION[{i_der}]) & RailML3_IL_TVD_SECTIONS(i_tvd) /\ RailML3_IS_DERAILER_NOT_PASSABLE(i_der) = {}
        ERROR_TYPE 2
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: TvdSection '~w' is declared as related to the derailer, but this could not be inferred from its corresponding track parts", e_der'xmlLineNumber, i_der, i_tvd)
        END
    END;
    // END DERAILERS

    // BEGIN MOVABLE_CROSSINGS
    COMPUTATION set_movableCrossings
    DEPENDS_ON_RULE is_valid_assetsForInterlocking
    BODY
        DEFINE RailML3_movableCrossings
            TYPE FIN(RailML3_IL_generic_Type)
            VALUE genericILType("movableCrossings")
        END
    END;
    RULE is_valid_movableCrossings
    DEPENDS_ON_COMPUTATION set_movableCrossings
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_movableCrossings) & c /: 0..card(RailML3_assetsForInterlocking) // (0..1), 0 if no assetsForInterlocking
        COUNTEREXAMPLE
            IF card(RailML3_assetsForInterlocking) > 0 
                THEN errorCard("movableCrossings", RailML3_assetsForInterlocking, 0, 1, c)
                ELSE errorCard("movableCrossings", RailML3_assetsForInterlocking, 0, 0, c)
            END
        END;
        RULE_FAIL e
        WHEN
            e : RailML3_movableCrossings & !e_ass.(e_ass : RailML3_assetsForInterlocking => e'pId /= e_ass'recId)
        COUNTEREXAMPLE
            errorParent("movableCrossings", "assetsForInterlocking", e'xmlLineNumber)
        END
    END;

    COMPUTATION set_movableCrossing
    DEPENDS_ON_RULE is_valid_movableCrossings
    DEPENDS_ON_COMPUTATION set_NET_ELEMENT, set_SWITCH, set_TRACK, set_CROSSING
    BODY
        DEFINE RailML3_movableCrossing
            TYPE FIN(RailML3_IL_movableCrossing_Type)
            VALUE dom({e, e_cr | e_cr : elementsOfType("movableCrossing")
                & e = rec(
                        recId: e_cr'recId,
                        pId: e_cr'pId,
                        xmlLineNumber: STRING_TO_INT(e_cr'meta("xmlLineNumber")),
                        Id: e_cr'attributes[{"id"}],
                        preferredPosition: IF "preferredPosition" : dom(e_cr'attributes) THEN {TYPED_STRING_TO_ENUM(RailML3_IL_CROSSING_POSITIONS, "position_"^e_cr'attributes("preferredPosition"))} ELSE {} END,
                        returnsToPreferredPosition : IF "returnsToPreferredPosition" : dom(e_cr'attributes) & e_cr'attributes("returnsToPreferredPosition") = "true" THEN TRUE ELSE FALSE END,
                        isKeyLocked : IF "isKeyLocked" : dom(e_cr'attributes) & e_cr'attributes("isKeyLocked") = "true" THEN TRUE ELSE FALSE END,
                        maxThrowTime : IF "maxThrowTime" : dom(e_cr'attributes) THEN readDuration(e_cr'attributes("maxThrowTime")) ELSIF "typicalThrowTime" : dom(e_cr'attributes) THEN readDuration(e_cr'attributes("typicalThrowTime")) + 1000 ELSE 2000 END,
                        typicalThrowTime : IF "typicalThrowTime" : dom(e_cr'attributes) THEN readDuration(e_cr'attributes("typicalThrowTime")) ELSIF "maxThrowTime" : dom(e_cr'attributes) THEN min({readDuration(e_cr'attributes("maxThrowTime")) - 1000, 1000}) ELSE 1000 END,
                        refersTo: dom({ i_A, e_A | e_A : childsOfElementType( "refersTo", e_cr'recId) & i_A : e_A'attributes[{"ref"}] }),
                        branchDownLeft: dom({ i_A, e_A | e_A : childsOfElementType( "branchDownLeft", e_cr'recId) & i_A : e_A'attributes[{"ref"}] }),
                        branchDownRight: dom({ i_A, e_A | e_A : childsOfElementType( "branchDownRight", e_cr'recId) & i_A : e_A'attributes[{"ref"}] }),
                        branchUpLeft: dom({ i_A, e_A | e_A : childsOfElementType( "branchUpLeft", e_cr'recId) & i_A : e_A'attributes[{"ref"}] }),
                        branchUpRight: dom({ i_A, e_A | e_A : childsOfElementType( "branchUpRight", e_cr'recId) & i_A : e_A'attributes[{"ref"}] }),
                        hasGaugeClearanceMarkers: dom({ i_A, e_A | e_A : childsOfElementType( "hasGaugeClearanceMarker", e_cr'recId) & i_A : e_A'attributes[{"ref"}] }),
                        hasFoulingTrainDetectors: dom({ i_A, e_A | e_A : childsOfElementType( "hasFoulingTrainDetector", e_cr'recId) & i_A : e_A'attributes[{"ref"}] }),
                        hasTvdSection: dom({ i_A, e_A | e_A : childsOfElementType( "hasTvdSection", e_cr'recId) & i_A : e_A'attributes[{"ref"}] }),
                        relatedMovableElement: dom({ i_A, e_A | e_A : childsOfElementType( "relatedMovableElement", e_cr'recId) & i_A : e_A'attributes[{"ref"}] })
                    ) })
        END
    END;
    RULE is_valid_movableCrossing
    DEPENDS_ON_COMPUTATION set_movableCrossing
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_movableCrossing) & IF card(RailML3_movableCrossings) = 1 THEN c = 0 ELSE c /= 0 END // (1..*), 0 if no movableCrossings
        COUNTEREXAMPLE
            IF card(RailML3_movableCrossings) = 1 
                THEN errorCardOnlyLowerBound("movableCrossing", RailML3_movableCrossings, 1, c)
                ELSE errorCard("movableCrossing", RailML3_movableCrossing, 0, 0, c)
            END
        END;
        RULE_FAIL e
            WHEN e : RailML3_movableCrossing & (card(e'Id) /= 1 or (card(e'Id) = 1 & MU_WD(e'Id) = ""))
        COUNTEREXAMPLE
            errorAttribute("id", "movableCrossing", e'xmlLineNumber)
        END;
        RULE_FAIL e_cr, c
            WHEN e_cr : RailML3_movableCrossing & c = card(e_cr'refersTo) & c /: 1..2
        COUNTEREXAMPLE
            errorCard("refersTo", {e_cr}, 1, 2, c)
        END;
        RULE_FAIL e_cr, e_data
            WHEN e_cr : RailML3_movableCrossing & e_data : childsOfElementType("refersTo", e_cr'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "refersTo", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_cr
            WHEN e_cr : RailML3_movableCrossing & card(e_cr'refersTo) = 1 & MU_WD(e_cr'refersTo) /: allIdsOfType("crossing")
        COUNTEREXAMPLE
            errorReference("refersTo", MU_WD(e_cr'refersTo), "crossing", e_cr'xmlLineNumber)
        END;
        RULE_FAIL e_cr, c
            WHEN e_cr : RailML3_movableCrossing & c = card(e_cr'branchDownLeft) & c /= 1
        COUNTEREXAMPLE
            errorCard("branchDownLeft", {e_cr}, 1, 1, c)
        END;
        RULE_FAIL e_cr, e_data
            WHEN e_cr : RailML3_movableCrossing & e_data : childsOfElementType("branchDownLeft", e_cr'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "branchDownLeft", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_cr, c
            WHEN e_cr : RailML3_movableCrossing & c = card(e_cr'branchDownRight) & c /= 1
        COUNTEREXAMPLE
            errorCard("branchDownRight", {e_cr}, 1, 1, c)
        END;
        RULE_FAIL e_cr, e_data
            WHEN e_cr : RailML3_movableCrossing & e_data : childsOfElementType("branchDownRight", e_cr'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "branchDownRight", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_cr, c
            WHEN e_cr : RailML3_movableCrossing & c = card(e_cr'branchUpLeft) & c /= 1
        COUNTEREXAMPLE
            errorCard("branchUpLeft", {e_cr}, 1, 1, c)
        END;
        RULE_FAIL e_cr, e_data
            WHEN e_cr : RailML3_movableCrossing & e_data : childsOfElementType("branchUpLeft", e_cr'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "branchUpLeft", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_cr, c
            WHEN e_cr : RailML3_movableCrossing & c = card(e_cr'branchUpRight) & c /= 1
        COUNTEREXAMPLE
            errorCard("branchUpRight", {e_cr}, 1, 1, c)
        END;
        RULE_FAIL e_cr, e_data
            WHEN e_cr : RailML3_movableCrossing & e_data : childsOfElementType("branchUpRight", e_cr'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "branchUpRight", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_cr, c
            WHEN e_cr : RailML3_movableCrossing & c = card(e_cr'hasGaugeClearanceMarkers) & c > 2
        COUNTEREXAMPLE
            errorCard("hasGaugeClearanceMarker", {e_cr}, 0, 2, c)
        END;
        RULE_FAIL e_cr, e_data
            WHEN e_cr : RailML3_movableCrossing & e_data : childsOfElementType("hasGaugeClearanceMarker", e_cr'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "hasGaugeClearanceMarker", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_cr, e_tde, i_tde, type
            WHEN e_cr : RailML3_movableCrossing & i_tde : e_cr'hasGaugeClearanceMarkers & e_tde : RailML3_trainDetectionElement & i_tde = MU_WD(e_tde'Id) & type : e_tde'type & type /= trainDetectionElement_clearancePoint 
        COUNTEREXAMPLE
           errorValue("hasGaugeClearanceMarker", "clearancePoint", STRING_SPLIT(TO_STRING(type), "_")(2), e_cr'xmlLineNumber)
        END;
        RULE_FAIL e_cr, e_data
            WHEN e_cr : RailML3_movableCrossing & e_data : childsOfElementType("hasFoulingTrainDetector", e_cr'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "hasFoulingTrainDetector", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_cr, c
            WHEN e_cr : RailML3_movableCrossing & c = card(e_cr'hasTvdSection) & c > 1
        COUNTEREXAMPLE
            errorCard("hasTvdSection", {e_cr}, 0, 1, c)
        END;
        RULE_FAIL e_cr, e_data
            WHEN e_cr : RailML3_movableCrossing & e_data : childsOfElementType("hasTvdSection", e_cr'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "hasTvdSection", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_cr, c
            WHEN e_cr : RailML3_movableCrossing & c = card(e_cr'relatedMovableElement) & c > 1
        COUNTEREXAMPLE
            errorCard("relatedMovableElement", {e_cr}, 0, 1, c)
        END;
        RULE_FAIL e_cr, e_data
            WHEN e_cr : RailML3_movableCrossing & e_data : childsOfElementType("relatedMovableElement", e_cr'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "relatedMovableElement", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FORALL e
            WHERE e : RailML3_movableCrossing & card(RailML3_movableCrossings) = 1
            EXPECT e'pId = MU_WD(RailML3_movableCrossings)'recId
        COUNTEREXAMPLE
            errorParent("movableCrossing", "movableCrossings", e'xmlLineNumber)
        END
    END;    

    COMPUTATION set_IL_MOVABLE_CROSSING
    DEPENDS_ON_RULE is_valid_movableCrossing, is_valid_derailerIL, is_valid_switchIL
    DEPENDS_ON_COMPUTATION set_NET_RELATION, set_NET_ELEMENT, set_CROSSING, set_TRACK
    BODY
        DEFINE RailML3_IL_MOVABLE_CROSSING_REFERS_TO
            // Total injection: not all crossings are movable
            TYPE allIdsOfType("movableCrossing") >-> allIdsOfType("crossing")
            VALUE { i_cr_il, i_cr | #e_cr_il.(e_cr_il : RailML3_movableCrossing & MU_WD(e_cr_il'Id) = i_cr_il & i_cr : e_cr_il'refersTo ) } 
        END;
        DEFINE RailML3_IS_MOVABLE_CROSSING_IDS
            TYPE FIN(allIdsOfType("crossing"))
            VALUE ran(RailML3_IL_MOVABLE_CROSSING_REFERS_TO)
        END;
        DEFINE RailML3_IL_MOVABLE_CROSSING_BRANCHES
            TYPE RailML3_IS_MOVABLE_CROSSING_IDS --> ((allIdsOfType("movableCrossing") * RailML3_IL_CROSSING_POSITIONS) +-> ((allIdsOfType("netElement") * REAL * RailML3_IS_DIRECTION) <-> (allIdsOfType("netElement") * REAL * RailML3_IS_DIRECTION)))
            VALUE
                %i_cr.( i_cr : RailML3_IS_MOVABLE_CROSSING_IDS |
                    %pos.( pos : {RailML3_IL_MOVABLE_CROSSING_REFERS_TO~(i_cr)} * RailML3_IL_CROSSING_POSITIONS |
                        { b1,b2 | #(ne_start, ne_branch).(
                                b1 |-> b2 : RailML3_IS_CROSSING_BRANCHES(i_cr)
                                & (b1 |-> b2 = ne_start |-> ne_branch or b1 |-> b2 = ne_branch |-> ne_start)
                            & #(e_cr_il).(
                                e_cr_il : RailML3_movableCrossing & i_cr : e_cr_il'refersTo & prj1(pos) = MU_WD(e_cr_il'Id)
                                & IF prj2(pos) = `position_downleft-rightup` THEN
                                    ne_start : IF MU_WD(e_cr_il'branchDownLeft) : allIdsOfType("netElement") THEN e_cr_il'branchDownLeft ELSE (RailML3_IS_TRACKS(MU_WD(e_cr_il'branchDownLeft)) \/ RailML3_IS_TRACKS(MU_WD(e_cr_il'branchDownLeft))~)[{i_cr}] END *{0.0,1.0}*{direction_normal,direction_reverse}
                                    & ne_branch : IF MU_WD(e_cr_il'branchUpRight) : allIdsOfType("netElement") THEN e_cr_il'branchUpRight ELSE (RailML3_IS_TRACKS(MU_WD(e_cr_il'branchUpRight)) \/ RailML3_IS_TRACKS(MU_WD(e_cr_il'branchUpRight))~)[{i_cr}] END *{0.0,1.0}*{direction_normal,direction_reverse}
                                ELSE
                                    ne_start : IF MU_WD(e_cr_il'branchUpLeft) : allIdsOfType("netElement") THEN e_cr_il'branchUpLeft ELSE (RailML3_IS_TRACKS(MU_WD(e_cr_il'branchUpLeft)) \/ RailML3_IS_TRACKS(MU_WD(e_cr_il'branchUpLeft))~)[{i_cr}] END *{0.0,1.0}*{direction_normal,direction_reverse}
                                    & ne_branch : IF MU_WD(e_cr_il'branchDownRight) : allIdsOfType("netElement") THEN e_cr_il'branchDownRight ELSE (RailML3_IS_TRACKS(MU_WD(e_cr_il'branchDownRight)) \/ RailML3_IS_TRACKS(MU_WD(e_cr_il'branchDownRight))~)[{i_cr}] END *{0.0,1.0}*{direction_normal,direction_reverse}
                                END )
                            )
                        }
                    )
                )
        END;
        DEFINE RailML3_IL_MOVABLE_CROSSING_HAS_TVD_SECTION
            TYPE RailML3_IS_MOVABLE_CROSSING_IDS +-> FIN(allIdsOfType("tvdSection"))
            VALUE fnc({ i_cr, rme | #e_cr.(e_cr : RailML3_movableCrossing & i_cr : e_cr'refersTo & rme : e_cr'hasTvdSection) })
        END;
        DEFINE RailML3_IL_MOVABLE_CROSSING_IS_KEY_LOCKED
            TYPE RailML3_IS_MOVABLE_CROSSING_IDS --> BOOL
            VALUE { i_cr, ikl | i_cr : RailML3_IS_MOVABLE_CROSSING_IDS & ikl = IF #e_cr.(e_cr : RailML3_movableCrossing & i_cr = MU_WD(e_cr'refersTo) & e_cr'isKeyLocked = TRUE) THEN TRUE ELSE FALSE END } 
        END;
        DEFINE RailML3_IL_MOVABLE_CROSSING_PREFERRED_POSITION
            TYPE allIdsOfType("movableCrossing") +-> RailML3_IL_CROSSING_POSITIONS
            VALUE { i_cr, pref | i_cr : allIdsOfType("movableCrossing") & #e_cr.(e_cr : RailML3_movableCrossing & i_cr = MU_WD(e_cr'Id) & pref : e_cr'preferredPosition) } 
        END;
        DEFINE RailML3_IL_MOVABLE_CROSSING_RETURNS_TO_PREFERRED_POSITION
            TYPE allIdsOfType("movableCrossing") --> BOOL
            VALUE { i_cr, ikl | i_cr : allIdsOfType("movableCrossing") & ikl = IF #e_cr.(e_cr : RailML3_movableCrossing & i_cr = MU_WD(e_cr'Id) & e_cr'returnsToPreferredPosition = TRUE) THEN TRUE ELSE FALSE END } 
        END;
        DEFINE RailML3_IL_MOVABLE_CROSSING_RELATED_MOVABLE_ELEMENT
            TYPE RailML3_IS_MOVABLE_CROSSING_IDS +-> (RailML3_IS_MOVABLE_CROSSING_IDS \/ allIdsOfType("derailerIS") \/ RailML3_IS_SWITCH_IDS)
            VALUE
                { i_cr, rme | #(e_cr, rme_il).(e_cr : RailML3_movableCrossing & i_cr : e_cr'refersTo & rme_il : e_cr'relatedMovableElement
                    & IF rme_il : allIdsOfType("movableCrossing") THEN rme : elementOfId(RailML3_movableCrossing, rme_il)'refersTo
                    ELSE IF rme_il : allIdsOfType("derailerIL") THEN rme : elementOfId(RailML3_derailerIL, rme_il)'refersTo
                        ELSE IF rme_il : allIdsOfType("switchIL") THEN rme : elementOfId(RailML3_switchIL, rme_il)'refersTo
                            ELSE bfalse END
                        END
                    END
                ) } 
        END;
        DEFINE RailML3_IL_MOVABLE_CROSSING_MAX_THROW_TIMES
            TYPE RailML3_IS_MOVABLE_CROSSING_IDS --> NATURAL
            VALUE { i_cr, mtt | i_cr : RailML3_IS_MOVABLE_CROSSING_IDS & card(RailML3_movableCrossing) /= 0 & mtt = min({ time | #e_cr.(e_cr : RailML3_movableCrossing & i_cr : e_cr'refersTo & time = e_cr'maxThrowTime) }) } 
        END;
        DEFINE RailML3_IL_MOVABLE_CROSSING_TYPICAL_THROW_TIMES
            TYPE RailML3_IS_MOVABLE_CROSSING_IDS --> NATURAL
            VALUE { i_cr, ttt | i_cr : RailML3_IS_MOVABLE_CROSSING_IDS & card(RailML3_movableCrossing) /= 0 & ttt = max({ time | #e_cr.(e_cr : RailML3_movableCrossing & i_cr : e_cr'refersTo & time = e_cr'typicalThrowTime) }) } 
        END
    END;

    RULE validate_movableCrossing
    DEPENDS_ON_COMPUTATION set_IL_MOVABLE_CROSSING
    BODY
        RULE_FAIL e_cr, i_cr
            WHEN e_cr : RailML3_movableCrossing & i_cr = MU_WD(e_cr'Id) & RailML3_IL_MOVABLE_CROSSING_RETURNS_TO_PREFERRED_POSITION(i_cr) = TRUE & i_cr /: dom(RailML3_IL_MOVABLE_CROSSING_PREFERRED_POSITION)
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '"^i_cr^"']: Movable crossing should return to preferred position, but no preferred position is defined", e_cr'xmlLineNumber)
        END;
        RULE_FAIL e_cr, i_cr
            WHEN e_cr : RailML3_movableCrossing & i_cr = MU_WD(e_cr'Id) & i_cr /: dom(RailML3_IL_MOVABLE_CROSSING_REFERS_TO)
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '"^i_cr^"']: Movable crossing's reference to corresponding infrastructure crossing could not be established", e_cr'xmlLineNumber)
        END;
        RULE_FORALL e_cr, i_cr, i_cr_is, branch
            WHERE e_cr : RailML3_movableCrossing & i_cr = MU_WD(e_cr'Id) & i_cr_is = MU_WD(e_cr'refersTo) & i_cr_is : dom(RailML3_IL_MOVABLE_CROSSING_REFERS_TO) & branch : union(ran(RailML3_IL_MOVABLE_CROSSING_BRANCHES(i_cr_is)))
            EXPECT branch : RailML3_IS_CROSSING_BRANCHES(i_cr_is)
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: Movable crossing branch (~w) is not defined on infrastructure side for referenced crossing '~w'", e_cr'xmlLineNumber, i_cr, branch, i_cr_is)
        END
    END;
    RULE warnings_movableCrossing
    DEPENDS_ON_COMPUTATION set_IL_MOVABLE_CROSSING
    ERROR_TYPES 2
    BODY
        RULE_FAIL e_cr, e_cr_imp
            WHEN e_cr : elementsOfType("movableCrossing") & "maxThrowTime" /: dom(e_cr'attributes) & e_cr_imp : RailML3_movableCrossing & MU_WD(e_cr_imp'Id) = e_cr'attributes("id")
        COUNTEREXAMPLE
            warningDefaultValue("maxThrowTime", TO_STRING(e_cr_imp'maxThrowTime), STRING_TO_INT(e_cr'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_cr, e_cr_imp
            WHEN e_cr : elementsOfType("movableCrossing") & "typicalThrowTime" /: dom(e_cr'attributes) & e_cr_imp : RailML3_movableCrossing & MU_WD(e_cr_imp'Id) = e_cr'attributes("id")
        COUNTEREXAMPLE
            warningDefaultValue("typicalThrowTime", TO_STRING(e_cr_imp'typicalThrowTime), STRING_TO_INT(e_cr'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_cr, i_cr, i_tvd
            WHEN e_cr : RailML3_crossing & i_cr = MU_WD(e_cr'Id) & i_tvd : union(RailML3_IL_MOVABLE_CROSSING_HAS_TVD_SECTION[{i_cr}]) & RailML3_IL_TVD_SECTIONS(i_tvd) /\ RailML3_IS_CROSSING_BRANCHES(i_cr) = {}
        ERROR_TYPE 2
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: TvdSection '~w' is declared as related to the crossing, but this could not be inferred from its branches", e_cr'xmlLineNumber, i_cr, i_tvd)
        END
    END;
    // END MOVABLE_CROSSINGS

    // BEGIN OVERLAPS
    COMPUTATION set_overlaps
    DEPENDS_ON_RULE is_valid_assetsForInterlocking
    BODY
        DEFINE RailML3_overlaps
            TYPE FIN(RailML3_IL_generic_Type)
            VALUE genericILType("overlaps")
        END
    END;
    RULE is_valid_overlaps
    DEPENDS_ON_COMPUTATION set_overlaps
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_overlaps) & c /: 0..card(RailML3_assetsForInterlocking) // (0..1), 0 if no assetsForInterlocking
        COUNTEREXAMPLE
            IF card(RailML3_assetsForInterlocking) > 0 
                THEN errorCard("overlaps", RailML3_assetsForInterlocking, 0, 1, c)
                ELSE errorCard("overlaps", RailML3_assetsForInterlocking, 0, 0, c)
            END
        END;
        RULE_FAIL e
        WHEN
            e : RailML3_overlaps & !e_ass.(e_ass : RailML3_assetsForInterlocking => e'pId /= e_ass'recId)
        COUNTEREXAMPLE
            errorParent("overlaps", "assetsForInterlocking", e'xmlLineNumber)
        END
    END;

    COMPUTATION set_overlap
    DEPENDS_ON_RULE is_valid_overlaps
    BODY
        DEFINE RailML3_overlap
            TYPE FIN(RailML3_IL_overlap_Type)
            VALUE dom({e, e_o | e_o : elementsOfType("overlap")
                & e = rec(
                        recId: e_o'recId,
                        pId: e_o'pId,
                        xmlLineNumber: STRING_TO_INT(e_o'meta("xmlLineNumber")),
                        Id: e_o'attributes[{"id"}],
                        length: IF "length" : dom(e_o'attributes) & STRING_IS_NUMBER(e_o'attributes("length")) THEN {STRING_TO_REAL(e_o'attributes("length"))} ELSE {} END,
                        overlapValidityTime: IF "overlapValidityTime" : dom(e_o'attributes) THEN readDuration(e_o'attributes("overlapValidityTime")) ELSE 1000 END,
                        activeForApproachRoutes : dom({ i_A, e_A | e_A : childsOfElementType( "activeForApproachRoute", e_o'recId) & i_A : e_A'attributes[{"ref"}] }),
                        hasTvdSections : dom({ i_A, e_A | e_A : childsOfElementType( "hasTvdSection", e_o'recId) & i_A : e_A'attributes[{"ref"}] }),
                        isLimitedBy : dom({ i_A, e_A | e_A : childsOfElementType( "isLimitedBy", e_o'recId) & i_A : e_A'attributes[{"ref"}] }),
                        relatedToTrackAsset : dom({ i_A, e_A | e_A : childsOfElementType( "relatedToTrackAsset", e_o'recId) & i_A : e_A'attributes[{"ref"}] }),
                        requiresSwitchInPosition :
                            dom({ i_A, e_A | e_A : childsOfElementType( "requiresSwitchInPosition", e_o'recId)
                                & i_A = rec(
                                    xmlLineNumber : STRING_TO_INT(e_A'meta("xmlLineNumber")),
                                    mustOrShould : IF "mustOrShould" : dom(e_A'attributes) THEN TYPED_STRING_TO_ENUM(RailML3_IL_REQUIRE_ENFORCEMENT_LEVELS, "require_"^e_A'attributes("mustOrShould")) ELSE require_must END,
                                    proving : IF "proving" : dom(e_A'attributes) THEN TYPED_STRING_TO_ENUM(RailML3_IL_REQUIRE_PROVING_TYPES, "proving_"^e_A'attributes("proving")) ELSE proving_oneOff END,
                                    isNegated: IF "isNegated" : dom(e_A'attributes) & e_A'attributes("isNegated") = "true" THEN TRUE ELSE FALSE END,
                                    relatedSwitchAndPosition :
                                        dom({ a, c | c : childsOfElementType( "relatedSwitchAndPosition", e_A'recId)
                                            & #c2.(c2 : childsOfElementType( "refersToSwitch", c'recId)
                                            & a = rec(
                                                xmlLineNumber : STRING_TO_INT(c'meta("xmlLineNumber")),
                                                refersToSwitch : c2'attributes[{"ref"}],
                                                inPosition : IF "inPosition" : dom(c'attributes) THEN {TYPED_STRING_TO_ENUM(RailML3_IL_SWITCH_POSITIONS, "position_"^c'attributes("inPosition"))} ELSE {} END,
                                                isNegated: IF "isNegated" : dom(c'attributes) & c'attributes("isNegated") = "true" THEN TRUE ELSE FALSE END
                                        ))})
                                )
                            }),
                        overlapRelease :
                            dom({ i_A, e_A | e_A : childsOfElementType( "overlapRelease", e_o'recId)
                                & i_A = rec(
                                    xmlLineNumber : STRING_TO_INT(e_A'meta("xmlLineNumber")),
                                    Id: e_A'attributes[{"id"}],
                                    overlapReleaseTimer :
                                        dom({ e_B, e_ort | e_ort : childsOfElementType( "overlapReleaseTimer", e_A'recId)
                                            & e_B = rec(
                                                xmlLineNumber : STRING_TO_INT(e_ort'meta("xmlLineNumber")),
                                                timerValue : IF "timerValue" : dom(e_ort'attributes) THEN readDuration(e_ort'attributes("timerValue")) ELSE 1000 END,
                                                overlapReleaseCondition: IF "overlapReleaseCondition" : dom(e_A'attributes) THEN {TYPED_STRING_TO_ENUM(RailML3_IL_OVERLAP_RELEASE_CONDITIONS, "overlap_"^e_ort'attributes("overlapReleaseCondition"))} ELSE {} END
                                        )}),
                                    releaseTriggerSection: dom({ i_B, e_B | e_B : childsOfElementType( "releaseTriggerSection", e_A'recId) & i_B : e_B'attributes[{"ref"}] })
                                )
                            })
                    ) })
        END
    END;
    RULE is_valid_overlap
    DEPENDS_ON_COMPUTATION set_overlap
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_overlap) & IF card(RailML3_overlaps) = 1 THEN c = 0 ELSE c /= 0 END // (1..*), 0 if no overlaps
        COUNTEREXAMPLE
            IF card(RailML3_overlaps) = 1 
                THEN errorCardOnlyLowerBound("overlap", RailML3_overlaps, 1, c)
                ELSE errorCard("overlap", RailML3_overlap, 0, 0, c)
            END
        END;
        RULE_FAIL e
            WHEN e : RailML3_overlap & (card(e'Id) /= 1 or (card(e'Id) = 1 & MU_WD(e'Id) = ""))
        COUNTEREXAMPLE
            errorAttribute("id", "overlap", e'xmlLineNumber)
        END;
        RULE_FAIL e_o, e_data
            WHEN e_o : RailML3_overlap & e_data : childsOfElementType("activeForApproachRoute", e_o'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "activeForApproachRoute", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_o, e_data
            WHEN e_o : RailML3_overlap & e_data : childsOfElementType("hasTvdSection", e_o'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "hasTvdSection", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_o, e_data
            WHEN e_o : RailML3_overlap & e_data : childsOfElementType("isLimitedBy", e_o'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "isLimitedBy", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_o, e_data
            WHEN e_o : RailML3_overlap & e_data : childsOfElementType("relatedToTrackAsset", e_o'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "relatedToTrackAsset", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_o, c
            WHEN e_o : RailML3_overlap & c = card(e_o'relatedToTrackAsset) & c /: 0..1
        COUNTEREXAMPLE
            errorCard("relatedToTrackAsset", {e_o}, 0, 1, c)
        END;
        RULE_FAIL e_o, c
            WHEN e_o : RailML3_overlap & c = card(e_o'overlapRelease) & c /: 0..1
        COUNTEREXAMPLE
            errorCard("overlapRelease", {e_o}, 0, 1, c)
        END;
        RULE_FAIL e_o, e_rsp, c
            WHEN e_o : RailML3_overlap & e_rsp : e_o'requiresSwitchInPosition & c = card(e_rsp'relatedSwitchAndPosition) & c /= 1
        COUNTEREXAMPLE
            errorCard("relatedSwitchAndPosition", {e_rsp}, 1, 1, c)
        END;
        RULE_FAIL e_o, e_rsp, e_rsap, c
            WHEN e_o : RailML3_overlap & e_rsp : e_o'requiresSwitchInPosition & e_rsap : e_rsp'relatedSwitchAndPosition & c = card(e_rsap'refersToSwitch) & c /= 1
        COUNTEREXAMPLE
            errorCard("refersToSwitch", {e_rsap}, 1, 1, c)
        END;
        RULE_FAIL e_o, e_rsp, e_rsap
            WHEN e_o : RailML3_overlap & e_rsp : e_o'requiresSwitchInPosition & e_rsap : e_rsp'relatedSwitchAndPosition & card(e_rsap'refersToSwitch) = 1 & MU_WD(e_rsap'refersToSwitch) /: allIdsOfType("switchIL")
        COUNTEREXAMPLE
            errorReference("refersToSwitch", MU_WD(e_rsap'refersToSwitch), "switchIL", e_rsap'xmlLineNumber)
        END;
        RULE_FAIL e_o, e_or, c
            WHEN e_o : RailML3_overlap & e_or : e_o'overlapRelease & c = card(e_or'overlapReleaseTimer) & c < 1
        COUNTEREXAMPLE
            errorCardOnlyLowerBound("overlapReleaseTimer", {e_or}, 1, c)
        END;
        RULE_FAIL e_o, e_or, c
            WHEN e_o : RailML3_overlap & e_or : e_o'overlapRelease & c = card(e_or'releaseTriggerSection) & c /: 0..1
        COUNTEREXAMPLE
            errorCard("releaseTriggerSection", {e_or}, 0, 1, c)
        END;
        RULE_FAIL e_o, e_or, e_or_data, e_orts_data
            WHEN e_o : RailML3_overlap & e_or : e_o'overlapRelease & e_or_data : childsOfElementType( "overlapRelease", e_o'recId) & e_orts_data : childsOfElementType("releaseTriggerSection", e_or_data'recId) & ("ref" /: dom(e_orts_data'attributes) or "ref" |-> "" : e_orts_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "releaseTriggerSection", STRING_TO_INT(e_orts_data'meta("xmlLineNumber")))
        END;
        RULE_FORALL e
            WHERE e : RailML3_overlap & card(RailML3_overlaps) = 1
            EXPECT e'pId = MU_WD(RailML3_overlaps)'recId
        COUNTEREXAMPLE
            errorParent("overlap", "overlaps", e'xmlLineNumber)
        END
    END;    

    COMPUTATION set_IL_OVERLAP
    DEPENDS_ON_RULE is_valid_overlap, validate_route
    DEPENDS_ON_COMPUTATION set_SPOT_LOCATION, set_IL_MOVABLE_CROSSING
    BODY
        DEFINE RailML3_IL_OVERLAP_LENGTH
            TYPE allIdsOfType("overlap") +-> REAL
            VALUE { i_o, l | #e_o.(e_o : RailML3_overlap & i_o = MU_WD(e_o'Id) & l : e_o'length) }
        END;
        DEFINE RailML3_IL_OVERLAP_VALIDITY_TIME
            TYPE allIdsOfType("overlap") --> NATURAL
            VALUE { i_o, val_time | #e_o.(e_o : RailML3_overlap & i_o = MU_WD(e_o'Id) & val_time = e_o'overlapValidityTime) }
        END;
        DEFINE RailML3_IL_OVERLAP_NXT
            TYPE allIdsOfType("overlap") --> ((allIdsOfType("netElement") * REAL * RailML3_IS_DIRECTION) >+> (allIdsOfType("netElement") * REAL * RailML3_IS_DIRECTION))
            VALUE
                fnc({ i_o, nxt | #(e_o, ne_entry, ref_exit, ne_exit, restriction_set).(
                        e_o : RailML3_overlap & i_o = MU_WD(e_o'Id)
                        & ( #i_r.(i_r : e_o'activeForApproachRoutes & ne_entry = prj2(RailML3_IL_ROUTE_EXIT(i_r))) // can entry be a bufferstop or openend?
                            or
                            #rta.(rta : e_o'relatedToTrackAsset 
                                & ne_entry : IF rta : allIdsOfType("trainDetectionElement")
                                    THEN dom(RailML3_IS_SPOT_LOCATIONS(rta)) * {direction_normal, direction_reverse}
                                    ELSE //ELSIF ref_entry : allIdsOfType("signalIL") THEN
                                        RailML3_IS_SPOT_LOCATIONS(MU(elementOfId(RailML3_signalIL, rta)'refersTo)) // for Norwegian
                                    END
                            )
                        )
                        & ref_exit : e_o'isLimitedBy
                        & ne_exit : IF ref_exit : union(allIdsOfType[{"bufferStop","trainDetectionElement"}])
                            THEN RailML3_IS_SPOT_LOCATIONS(ref_exit)
                            ELSE // ref_exit : allIdsOfType("switchIL") THEN
                                dom({ loc, branches | branches = union(RailML3_IS_SWITCH_BRANCHES[{MU(elementOfId(RailML3_switchIL, ref_exit)'refersTo)}]) & loc : dom(branches) \/ ran(branches) }) // for Norwegian
                        END
                        & restriction_set = ( railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1[{ne_entry}] /\ railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1~[{ne_exit}] ) \/ {ne_entry, ne_exit}
                        & nxt : restriction_set <| RailML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS |> restriction_set
                )})
        END;
        DEFINE RailML3_IL_OVERLAP_TVD_SECTIONS
            TYPE allIdsOfType("overlap") --> FIN(allIdsOfType("tvdSection"))
            VALUE %i_o.(i_o : allIdsOfType("overlap") |
                    dom({ i_tvd, e_o | e_o : RailML3_overlap & i_o = MU_WD(e_o'Id) & i_tvd : e_o'hasTvdSections \/ { i | i : dom(RailML3_IL_TVD_SECTIONS) & RailML3_IL_TVD_SECTIONS(i) /\ RailML3_IL_OVERLAP_NXT(i_o) /= {} } })
                )
        END;
        DEFINE RailML3_IL_OVERLAP_MUST_SWITCH_POSITIONS
            TYPE allIdsOfType("overlap") +-> ((RailML3_IL_REQUIRE_PROVING_TYPES*BOOL) <-> (RailML3_IS_SWITCH_IDS +-> (allIdsOfType("switchIL") +-> RailML3_IL_SWITCH_POSITIONS)))
            VALUE
                { i_o, prov | i_o : allIdsOfType("overlap")
                    & prov =
                        { provtype_bool, pos | #(e_o, e_rsp, e_rsp_pos).(
                            e_o : RailML3_overlap & i_o = MU_WD(e_o'Id)
                            & e_rsp : e_o'requiresSwitchInPosition & e_rsp'mustOrShould = require_must
                            & e_rsp_pos : e_rsp'relatedSwitchAndPosition
                            & provtype_bool = e_rsp'proving |-> e_rsp'isNegated
                            & pos = { i_sw, positions | #e_sw.(i_sw : RailML3_IS_SWITCH_IDS
                                & e_sw = elementOfId(RailML3_switchIL, MU_WD(e_rsp_pos'refersToSwitch)) & i_sw = MU_WD(e_sw'refersTo)
                                & positions = { i_sw_il, sw_pos | i_sw_il = MU_WD(e_sw'Id) & IF e_rsp_pos'isNegated = FALSE THEN sw_pos = MU_WD(e_rsp_pos'inPosition) ELSE sw_pos = negatedSwitchPosition(MU_WD(e_rsp_pos'inPosition)) END}
                            )}
                        )}
                    & prov /= {}
                }
        END;
        DEFINE RailML3_IL_OVERLAP_CROSSING_POSITIONS
            TYPE allIdsOfType("overlap") +-> (allIdsOfType("crossing") +-> (allIdsOfType("movableCrossing") * RailML3_IL_CROSSING_POSITIONS))
            VALUE
                { i_o, cr_pos | i_o : allIdsOfType("overlap")
                    & cr_pos = { i_cr, position | i_cr : RailML3_IS_MOVABLE_CROSSING_IDS
                        & position : dom({ pos, branch |
                                pos : dom(RailML3_IL_MOVABLE_CROSSING_BRANCHES(i_cr))
                                & branch : RailML3_IL_MOVABLE_CROSSING_BRANCHES(i_cr)(pos)
                                & branch : RailML3_IL_OVERLAP_NXT(i_o) })
                    }
                    & cr_pos /= {}
                }
        END;
        DEFINE RailML3_IL_OVERLAP_DERAILERS // no positions needed -> clearly they should all be in passablePosition
            TYPE allIdsOfType("overlap") +-> FIN(allIdsOfType("derailerIS"))
            VALUE fnc({ i_o, der | i_o : allIdsOfType("overlap") & der : allIdsOfType("derailerIS") & #bl.(bl : RailML3_IS_DERAILER_NOT_PASSABLE(der) & bl : RailML3_IL_OVERLAP_NXT(i_o)) })
        END;
        DEFINE RailML3_IL_OVERLAP_SWITCH_POSITIONS
            TYPE allIdsOfType("overlap") +-> (RailML3_IS_SWITCH_IDS +-> (allIdsOfType("switchIL") +-> RailML3_IL_SWITCH_POSITIONS))
            VALUE
                { i_o, sw_pos | i_o : allIdsOfType("overlap")
                    & sw_pos = { i_sw, positions | i_sw : RailML3_IS_SWITCH_IDS
                        & positions = 
                            union(dom({ pos, branch |
                                pos : dom(RailML3_IL_SWITCH_BRANCHES(i_sw))
                                & branch : RailML3_IL_SWITCH_BRANCHES(i_sw)(pos)
                                & branch : RailML3_IL_OVERLAP_NXT(i_o) }))
                        & positions /= {}
                    }
                    & sw_pos /= {}
                }
        END;
        DEFINE RailML3_IL_OVERLAP_RELEASE_TIMERS
            TYPE allIdsOfType("overlap") +-> FIN(NATURAL)
            VALUE
                fnc({ i_o, timer | i_o : allIdsOfType("overlap")
                    & #(e_o, e_or, e_ort).(
                        e_o : RailML3_overlap & i_o = MU_WD(e_o'Id)
                        & e_or : e_o'overlapRelease & e_ort : e_or'overlapReleaseTimer
                        & timer = e_ort'timerValue
                    )
                })
        END;
        DEFINE RailML3_IL_OVERLAP_RELEASE_TRIGGER_SECTION
            TYPE allIdsOfType("overlap") +-> allIdsOfType("tvdSection")
            VALUE
                { i_o, i_tvd | i_o : allIdsOfType("overlap")
                    & #(e_o, e_or).(
                        e_o : RailML3_overlap & i_o = MU_WD(e_o'Id)
                        & e_or : e_o'overlapRelease
                        & i_tvd : e_or'releaseTriggerSection
                    )
                }
        END
    END;
    
    RULE validate_overlap
    DEPENDS_ON_COMPUTATION set_IL_OVERLAP
    BODY
        RULE_FAIL e_o, i_o
        WHEN e_o : RailML3_overlap & i_o = MU_WD(e_o'Id) & i_o /: dom(RailML3_IL_OVERLAP_NXT)
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: Path for overlap could not be initialised - check that switch positions, activeForApproachRoutes and/or relatedTrackAsset match the topology", e_o'xmlLineNumber, i_o)
        END;
        RULE_FORALL e_o, i_o, i_sw, must_pos
        WHERE e_o : RailML3_overlap & i_o = MU_WD(e_o'Id) & i_o : dom(RailML3_IL_OVERLAP_MUST_SWITCH_POSITIONS) & i_sw : RailML3_IS_SWITCH_IDS
            & must_pos = union(RailML3_IL_OVERLAP_MUST_SWITCH_POSITIONS(i_o)[RailML3_IL_REQUIRE_PROVING_TYPES * {FALSE}])[{i_sw}]
        EXPECT card(must_pos) <= 1 & must_pos /\ union(RailML3_IL_OVERLAP_MUST_SWITCH_POSITIONS(i_o)[RailML3_IL_REQUIRE_PROVING_TYPES * {TRUE}])[{i_sw}] = {}
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: requiresSwitchInPosition specifies multiple must positions for switch '~w'", e_o'xmlLineNumber, i_o, i_sw)
        END;
        RULE_FORALL e_o, i_o, o_begin, o_end, min_length, inf_length
        WHERE e_o : RailML3_overlap & i_o = MU_WD(e_o'Id) & i_o : dom(RailML3_IL_OVERLAP_LENGTH)
            & o_begin : dom(RailML3_IL_OVERLAP_NXT(i_o)) & o_begin /: ran(RailML3_IL_OVERLAP_NXT(i_o))
            & o_end /: dom(RailML3_IL_OVERLAP_NXT(i_o)) & o_end : ran(RailML3_IL_OVERLAP_NXT(i_o))
            & !ne.(ne : dom(dom(dom(RailML3_IL_OVERLAP_NXT(i_o)) \/ ran(RailML3_IL_OVERLAP_NXT(i_o)))) => RailML3_IS_NET_ELEMENT_LENGTHS(ne) /= -1.0)
            & min_length = RailML3_IL_OVERLAP_LENGTH(i_o)
            & inf_length = lengthBetweenPositionsOnRelation(o_begin, o_end, RailML3_IL_OVERLAP_NXT(i_o))
        EXPECT min_length <= inf_length
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: Minimum length of the overlap is declared as ~w, but its inferred length is ~w", e_o'xmlLineNumber, i_o, min_length, inf_length)
        END
        // as soon as additionalRelations are supported: check that they match the forced positions
    END;
    RULE warnings_overlap
    DEPENDS_ON_COMPUTATION set_IL_OVERLAP
    ERROR_TYPES 2
    BODY
        RULE_FAIL e_o
            WHEN e_o : elementsOfType("overlap") & "overlapValidityTime" /: dom(e_o'attributes)
        COUNTEREXAMPLE
            warningDefaultValue("overlapValidityTime", "1000", STRING_TO_INT(e_o'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_o, e_rsp
            WHEN e_o : RailML3_overlap & e_rsp : childsOfElementType( "requiresSwitchInPosition", e_o'recId) & "mustOrShould" /: dom(e_rsp'attributes)
        COUNTEREXAMPLE
            warningDefaultValue("mustOrShould", "must", STRING_TO_INT(e_rsp'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_o, e_rsp
            WHEN e_o : RailML3_overlap & e_rsp : childsOfElementType( "requiresSwitchInPosition", e_o'recId) & "proving" /: dom(e_rsp'attributes)
        COUNTEREXAMPLE
            warningDefaultValue("proving", "oneOff", STRING_TO_INT(e_rsp'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_o, e_or, e_ort
            WHEN e_o : RailML3_overlap & e_or : childsOfElementType( "overlapRelease", e_o'recId) & e_ort : childsOfElementType("overlapReleaseTimer", e_or'recId) & "timerValue" /: dom(e_ort'attributes)
        COUNTEREXAMPLE
            warningDefaultValue("timerValue", "1000", STRING_TO_INT(e_ort'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_o, i_o, i_tvd
            WHEN e_o : RailML3_route & i_o = MU_WD(e_o'Id) & i_tvd : e_o'hasTvdSections & i_tvd /: { i | i : dom(RailML3_IL_TVD_SECTIONS) & RailML3_IL_TVD_SECTIONS(i) /\ RailML3_IL_OVERLAP_NXT(i_o) /= {} }
        ERROR_TYPE 2
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: TvdSection '~w' is declared as part of the overlap, but this could not be inferred from the overlap", e_o'xmlLineNumber, i_o, i_tvd)
        END
    END;
    // END OVERLAPS

    // BEGIN ROUTE RELEASE_GROUP_AHEAD
    COMPUTATION set_routeReleaseGroupsAhead
    DEPENDS_ON_RULE is_valid_assetsForInterlocking
    BODY
        DEFINE RailML3_routeReleaseGroupsAhead
            TYPE FIN(RailML3_IL_generic_Type)
            VALUE genericILType("routeReleaseGroupsAhead")
        END
    END;
    RULE is_valid_routeReleaseGroupsAhead
    DEPENDS_ON_COMPUTATION set_routeReleaseGroupsAhead
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_routeReleaseGroupsAhead) & c /: 0..card(RailML3_assetsForInterlocking) // (0..1), 0 if no assetsForInterlocking
        COUNTEREXAMPLE
            IF card(RailML3_assetsForInterlocking) > 0 
                THEN errorCard("routeReleaseGroupsAhead", RailML3_assetsForInterlocking, 0, 1, c)
                ELSE errorCard("routeReleaseGroupsAhead", RailML3_assetsForInterlocking, 0, 0, c)
            END
        END;
        RULE_FAIL e
        WHEN
            e : RailML3_routeReleaseGroupsAhead & !e_ass.(e_ass : RailML3_assetsForInterlocking => e'pId /= e_ass'recId)
        COUNTEREXAMPLE
            errorParent("routeReleaseGroupsAhead", "assetsForInterlocking", e'xmlLineNumber)
        END
    END;

    COMPUTATION set_routeReleaseGroupAhead
    DEPENDS_ON_RULE is_valid_routeReleaseGroupsAhead
    BODY
        DEFINE RailML3_routeReleaseGroupAhead
            TYPE FIN(RailML3_IL_routeReleaseGroupAheadRear_Type)
            VALUE dom({e, e_rga | e_rga : elementsOfType("routeReleaseGroupAhead")
                & e = rec(
                        recId: e_rga'recId,
                        pId: e_rga'pId,
                        xmlLineNumber: STRING_TO_INT(e_rga'meta("xmlLineNumber")),
                        Id: e_rga'attributes[{"id"}],
                        typicalDelay : IF "typicalDelay" : dom(e_rga'attributes) THEN readDuration(e_rga'attributes("typicalDelay")) ELSE 1000 END,
                        isAutomatic : IF "isAutomatic" : dom(e_rga'attributes) & e_rga'attributes("isAutomatic") = "true" THEN TRUE ELSE FALSE END,
                        hasTvdSections : dom({ i_A, e_A | e_A : childsOfElementType( "hasTvdSection", e_rga'recId) & i_A : e_A'attributes[{"ref"}] })
                    ) })
        END
    END;
    RULE is_valid_routeReleaseGroupAhead
    DEPENDS_ON_COMPUTATION set_routeReleaseGroupAhead
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_routeReleaseGroupAhead) & IF card(RailML3_routeReleaseGroupsAhead) = 1 THEN c = 0 ELSE c /= 0 END // (1..*), 0 if no routeReleaseGroupsAhead
        COUNTEREXAMPLE
            IF card(RailML3_routeReleaseGroupsAhead) = 1 
                THEN errorCardOnlyLowerBound("routeReleaseGroupAhead", RailML3_routeReleaseGroupsAhead, 1, c)
                ELSE errorCard("routeReleaseGroupAhead", RailML3_routeReleaseGroupAhead, 0, 0, c)
            END
        END;
        RULE_FAIL e
            WHEN e : RailML3_routeReleaseGroupAhead & (card(e'Id) /= 1 or (card(e'Id) = 1 & MU_WD(e'Id) = ""))
        COUNTEREXAMPLE
            errorAttribute("id", "routeReleaseGroupAhead", e'xmlLineNumber)
        END;
        RULE_FAIL e_rga, e_data
            WHEN e_rga : RailML3_routeReleaseGroupAhead & e_data : childsOfElementType("hasTvdSection", e_rga'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "hasTvdSection", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FORALL e
            WHERE e : RailML3_routeReleaseGroupAhead & card(RailML3_routeReleaseGroupsAhead) = 1
            EXPECT e'pId = MU(RailML3_routeReleaseGroupsAhead)'recId
        COUNTEREXAMPLE
            errorParent("routeReleaseGroupAhead", "routeReleaseGroupsAhead", e'xmlLineNumber)
        END
    END;  

    COMPUTATION set_IL_ROUTE_RELEASE_GROUP_AHEAD
    DEPENDS_ON_RULE is_valid_routeReleaseGroupAhead, validate_route, validate_tvdSection
    BODY
        DEFINE RailML3_IL_ROUTE_RELEASE_GROUPS_AHEAD_TVD_SECTIONS
            TYPE allIdsOfType("routeReleaseGroupAhead") --> FIN(allIdsOfType("tvdSection"))
            VALUE { i_rga, i_tvd | #e_rga.(e_rga : RailML3_routeReleaseGroupAhead & i_rga = MU_WD(e_rga'Id) & i_tvd = e_rga'hasTvdSections) }
        END;
        DEFINE RailML3_IL_ROUTE_RELEASE_GROUP_AHEAD_NXT
            TYPE allIdsOfType("routeReleaseGroupAhead") --> (allIdsOfType("route") +-> ((allIdsOfType("netElement") * REAL * RailML3_IS_DIRECTION) >+> (allIdsOfType("netElement") * REAL * RailML3_IS_DIRECTION)))
            VALUE %i_rga.(i_rga : allIdsOfType("routeReleaseGroupAhead") |
                { i_r, nxt | i_rga : union(RailML3_IL_ROUTE_RELEASE_GROUPS[{i_r}])
                    & nxt = union(RailML3_IL_TVD_SECTIONS[RailML3_IL_ROUTE_RELEASE_GROUPS_AHEAD_TVD_SECTIONS(i_rga)]) /\ RailML3_IL_ROUTE_NXT(i_r)
                })
        END;        
        DEFINE RailML3_IL_ROUTE_RELEASE_GROUPS_AHEAD_TYPICAL_DELAYS
            TYPE allIdsOfType("routeReleaseGroupAhead") --> NATURAL
            VALUE { i_rga, delay | #e_rga.(e_rga : RailML3_routeReleaseGroupAhead & i_rga = MU_WD(e_rga'Id) & delay = e_rga'typicalDelay) }
        END
    END;

    RULE validate_routeReleaseGroupAhead
    DEPENDS_ON_COMPUTATION set_IL_ROUTE_RELEASE_GROUP_AHEAD
    BODY
        RULE_FORALL e_rga, i_rga, i_r
            WHERE e_rga : RailML3_routeReleaseGroupAhead & i_rga = MU_WD(e_rga'Id) & i_r : allIdsOfType("route") & i_rga : union(RailML3_IL_ROUTE_RELEASE_GROUPS[{i_r}])
            EXPECT i_r : dom(RailML3_IL_ROUTE_RELEASE_GROUP_AHEAD_NXT(i_rga))
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: Path for routeReleaseGroupAhead could not be initialised for route '~w' - check if tvdSections match the route", e_rga'xmlLineNumber, i_rga, i_r)
        END
    END;    
    RULE warnings_routeReleaseGroupAhead
    DEPENDS_ON_COMPUTATION set_IL_ROUTE_RELEASE_GROUP_AHEAD
    ERROR_TYPES 2
    BODY
        RULE_FAIL e_rga
            WHEN e_rga : elementsOfType("routeReleaseGroupAhead") & "typicalDelay" /: dom(e_rga'attributes)
        COUNTEREXAMPLE
            warningDefaultValue("typicalDelay", "1000", STRING_TO_INT(e_rga'meta("xmlLineNumber")))
        END;
        RULE_FORALL e_rga, i_rga, i_tvd, i_r
            WHERE e_rga : RailML3_routeReleaseGroupAhead & i_rga = MU_WD(e_rga'Id) & i_tvd : RailML3_IL_ROUTE_RELEASE_GROUPS_AHEAD_TVD_SECTIONS(i_rga) & i_r : dom(RailML3_IL_ROUTE_RELEASE_GROUPS) & i_rga : RailML3_IL_ROUTE_RELEASE_GROUPS(i_r)
            EXPECT RailML3_IL_TVD_SECTIONS(i_tvd) /\ RailML3_IL_ROUTE_NXT(i_r) /= {}
        ERROR_TYPE 2
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: TvdSection '~w' is declared as part of the routeReleaseGroupAhead, but this could not be inferred from the tvdSections of route '~w'", e_rga'xmlLineNumber, i_rga, i_tvd, i_r)
        END
    END;
    // END ROUTE RELEASE_GROUP_AHEAD

    // BEGIN ROUTE RELEASE_GROUP_REAR
    COMPUTATION set_routeReleaseGroupsRear
    DEPENDS_ON_RULE is_valid_assetsForInterlocking
    BODY
        DEFINE RailML3_routeReleaseGroupsRear
            TYPE FIN(RailML3_IL_generic_Type)
            VALUE genericILType("routeReleaseGroupsRear")
        END
    END;
    RULE is_valid_routeReleaseGroupsRear
    DEPENDS_ON_COMPUTATION set_routeReleaseGroupsRear
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_routeReleaseGroupsRear) & c /: 0..card(RailML3_assetsForInterlocking) // (0..1), 0 if no assetsForInterlocking
        COUNTEREXAMPLE
            IF card(RailML3_assetsForInterlocking) > 0 
                THEN errorCard("routeReleaseGroupsRear", RailML3_assetsForInterlocking, 0, 1, c)
                ELSE errorCard("routeReleaseGroupsRear", RailML3_assetsForInterlocking, 0, 0, c)
            END
        END;
        RULE_FAIL e
        WHEN
            e : RailML3_routeReleaseGroupsRear & !e_ass.(e_ass : RailML3_assetsForInterlocking => e'pId /= e_ass'recId)
        COUNTEREXAMPLE
            errorParent("routeReleaseGroupsRear", "assetsForInterlocking", e'xmlLineNumber)
        END
    END;

    COMPUTATION set_routeReleaseGroupRear
    DEPENDS_ON_RULE is_valid_routeReleaseGroupsRear
    BODY
        DEFINE RailML3_routeReleaseGroupRear
            TYPE FIN(RailML3_IL_routeReleaseGroupAheadRear_Type)
            VALUE dom({e, e_rgr | e_rgr : elementsOfType("routeReleaseGroupRear")
                & e = rec(
                        recId: e_rgr'recId,
                        pId: e_rgr'pId,
                        xmlLineNumber: STRING_TO_INT(e_rgr'meta("xmlLineNumber")),
                        Id: e_rgr'attributes[{"id"}],
                        typicalDelay : IF "typicalDelay" : dom(e_rgr'attributes) THEN readDuration(e_rgr'attributes("typicalDelay")) ELSE 1000 END,
                        isAutomatic : FALSE, // only used for release groups ahead
                        hasTvdSections : dom({ i_A, e_A | e_A : childsOfElementType( "hasTvdSection", e_rgr'recId) & i_A = e_A'attributes("ref") })
                    ) })
        END
    END;
    RULE is_valid_routeReleaseGroupRear
    DEPENDS_ON_COMPUTATION set_routeReleaseGroupRear
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_routeReleaseGroupRear) & IF card(RailML3_routeReleaseGroupsRear) = 1 THEN c = 0 ELSE c /= 0 END // (1..*), 0 if no routeReleaseGroupsRear
        COUNTEREXAMPLE
            IF card(RailML3_routeReleaseGroupsRear) = 1 
                THEN errorCardOnlyLowerBound("routeReleaseGroupRear", RailML3_routeReleaseGroupsRear, 1, c)
                ELSE errorCard("routeReleaseGroupRear", RailML3_routeReleaseGroupRear, 0, 0, c)
            END
        END;
        RULE_FAIL e
            WHEN e : RailML3_routeReleaseGroupRear & (card(e'Id) /= 1 or (card(e'Id) = 1 & MU_WD(e'Id) = ""))
        COUNTEREXAMPLE
            errorAttribute("id", "routeReleaseGroupRear", e'xmlLineNumber)
        END;
        RULE_FAIL e_rgr, e_data
            WHEN e_rgr : RailML3_routeReleaseGroupRear & e_data : childsOfElementType("hasTvdSection", e_rgr'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "hasTvdSection", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FORALL e
            WHERE e : RailML3_routeReleaseGroupRear & card(RailML3_routeReleaseGroupsRear) = 1
            EXPECT e'pId = MU(RailML3_routeReleaseGroupsRear)'recId
        COUNTEREXAMPLE
            errorParent("routeReleaseGroupRear", "routeReleaseGroupsRear", e'xmlLineNumber)
        END
    END;    

    COMPUTATION set_IL_ROUTE_RELEASE_GROUP_REAR
    DEPENDS_ON_RULE is_valid_routeReleaseGroupRear, validate_route, validate_tvdSection
    BODY
        DEFINE RailML3_IL_ROUTE_RELEASE_GROUPS_REAR_TVD_SECTIONS
            TYPE allIdsOfType("routeReleaseGroupRear") --> FIN(allIdsOfType("tvdSection"))
            VALUE { i_rgr, i_tvd | #e_rgr.(e_rgr : RailML3_routeReleaseGroupRear & i_rgr = MU_WD(e_rgr'Id) & i_tvd = e_rgr'hasTvdSections) }
        END;
        DEFINE RailML3_IL_ROUTE_RELEASE_GROUP_REAR_NXT
            TYPE allIdsOfType("routeReleaseGroupRear") --> (allIdsOfType("route") +-> ((allIdsOfType("netElement") * REAL * RailML3_IS_DIRECTION) >+> (allIdsOfType("netElement") * REAL * RailML3_IS_DIRECTION)))
            VALUE %i_rgr.(i_rgr : allIdsOfType("routeReleaseGroupRear") |
                { i_r, nxt | i_rgr : union(RailML3_IL_ROUTE_RELEASE_GROUPS[{i_r}])
                    & nxt = union(RailML3_IL_TVD_SECTIONS[RailML3_IL_ROUTE_RELEASE_GROUPS_REAR_TVD_SECTIONS(i_rgr)]) /\ RailML3_IL_ROUTE_NXT(i_r)
                })
        END;
        DEFINE RailML3_IL_ROUTE_RELEASE_GROUPS_REAR_TYPICAL_DELAYS
            TYPE allIdsOfType("routeReleaseGroupRear") --> NATURAL
            VALUE { i_rgr, delay | #e_rgr.(e_rgr : RailML3_routeReleaseGroupRear & i_rgr = MU_WD(e_rgr'Id) & delay = e_rgr'typicalDelay) }
        END
    END;

    RULE validate_routeReleaseGroupRear
    DEPENDS_ON_COMPUTATION set_IL_ROUTE_RELEASE_GROUP_REAR
    BODY
        RULE_FORALL e_rgr, i_rgr, i_r
            WHERE e_rgr : RailML3_routeReleaseGroupRear & i_rgr = MU_WD(e_rgr'Id) & i_r : allIdsOfType("route") & i_rgr : union(RailML3_IL_ROUTE_RELEASE_GROUPS[{i_r}])
            EXPECT i_r : dom(RailML3_IL_ROUTE_RELEASE_GROUP_REAR_NXT(i_rgr))
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: Path for routeReleaseGroupRear could not be initialised for route '~w' - check if tvdSections match the route", e_rgr'xmlLineNumber, i_rgr, i_r)
        END
    END;    
    RULE warnings_routeReleaseGroupRear
    DEPENDS_ON_COMPUTATION set_IL_ROUTE_RELEASE_GROUP_REAR
    ERROR_TYPES 2
    BODY
         RULE_FAIL e_rgr
            WHEN e_rgr : elementsOfType("routeReleaseGroupRear") & "typicalDelay" /: dom(e_rgr'attributes)
        COUNTEREXAMPLE
            warningDefaultValue("typicalDelay", "1000", STRING_TO_INT(e_rgr'meta("xmlLineNumber")))
        END;
        RULE_FORALL e_rgr, i_rgr, i_tvd, i_r
            WHERE e_rgr : RailML3_routeReleaseGroupRear & i_rgr = MU_WD(e_rgr'Id) & i_tvd : RailML3_IL_ROUTE_RELEASE_GROUPS_REAR_TVD_SECTIONS(i_rgr) & i_r : dom(RailML3_IL_ROUTE_RELEASE_GROUPS) & i_rgr : RailML3_IL_ROUTE_RELEASE_GROUPS(i_r)
            EXPECT RailML3_IL_TVD_SECTIONS(i_tvd) /\ RailML3_IL_ROUTE_NXT(i_r) /= {}
        ERROR_TYPE 2
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: TvdSection '~w' is declared as part of the routeReleaseGroupRear, but this could not be inferred from the tvdSections of route '~w'", e_rgr'xmlLineNumber, i_rgr, i_tvd, i_r)
        END
    END;
    // END ROUTE RELEASE_GROUP_REAR

    // BEGIN ROUTE_RELATIONS
    COMPUTATION set_routeRelations
    DEPENDS_ON_RULE is_valid_assetsForInterlocking
    BODY
        DEFINE RailML3_routeRelations
            TYPE FIN(RailML3_IL_generic_Type)
            VALUE genericILType("routeRelations")
        END
    END;
    RULE is_valid_routeRelations
    DEPENDS_ON_COMPUTATION set_routeRelations
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_routeRelations) & c /: 0..card(RailML3_assetsForInterlocking) // (0..1), 0 if no assetsForInterlocking
        COUNTEREXAMPLE
            IF card(RailML3_assetsForInterlocking) > 0 
                THEN errorCard("routeRelations", RailML3_assetsForInterlocking, 0, 1, c)
                ELSE errorCard("routeRelations", RailML3_assetsForInterlocking, 0, 0, c)
            END
        END;
        RULE_FAIL e
        WHEN
            e : RailML3_routeRelations & !e_ass.(e_ass : RailML3_assetsForInterlocking => e'pId /= e_ass'recId)
        COUNTEREXAMPLE
            errorParent("routeRelations", "assetsForInterlocking", e'xmlLineNumber)
        END
    END;

    COMPUTATION set_routeRelation
    DEPENDS_ON_RULE is_valid_routeRelations
    BODY
        DEFINE RailML3_routeRelation
            TYPE FIN(RailML3_IL_routeRelation_Type)
            VALUE dom({e, e_rr | e_rr : elementsOfType("routeRelation")
                & e = rec(
                        recId: e_rr'recId,
                        pId: e_rr'pId,
                        xmlLineNumber: STRING_TO_INT(e_rr'meta("xmlLineNumber")),
                        Id: e_rr'attributes[{"id"}],
                        requiredDerailerPosition :
                            dom({ i_A, e_A | e_A : childsOfElementType( "requiredDerailerPosition", e_rr'recId)
                                & i_A = rec(
                                    xmlLineNumber : STRING_TO_INT(e_A'meta("xmlLineNumber")),
                                    mustOrShould : IF "mustOrShould" : dom(e_A'attributes) THEN TYPED_STRING_TO_ENUM(RailML3_IL_REQUIRE_ENFORCEMENT_LEVELS, "require_"^e_A'attributes("mustOrShould")) ELSE require_must END,
                                    proving : IF "proving" : dom(e_A'attributes) THEN TYPED_STRING_TO_ENUM(RailML3_IL_REQUIRE_PROVING_TYPES, "proving_"^e_A'attributes("proving")) ELSE proving_oneOff END,
                                    isNegated: IF "isNegated" : dom(e_A'attributes) & e_A'attributes("isNegated") = "true" THEN TRUE ELSE FALSE END,
                                    relatedDerailerAndPosition :
                                        dom({ a, c | c : childsOfElementType( "relatedDerailerAndPosition", e_A'recId)
                                            & #c2.(c2 : childsOfElementType( "refersToDerailer", c'recId)
                                            & a = rec(
                                                xmlLineNumber : STRING_TO_INT(c'meta("xmlLineNumber")),
                                                refersToDerailer : c2'attributes[{"ref"}],
                                                inPosition : IF "inPosition" : dom(c'attributes) THEN {TYPED_STRING_TO_ENUM(RailML3_IL_DERAILER_POSITIONS, "position_"^c'attributes("inPosition"))} ELSE {} END,
                                                isNegated: IF "isNegated" : dom(c'attributes) & c'attributes("isNegated") = "true" THEN TRUE ELSE FALSE END
                                        ))})
                                )
                            }),
                        requiredDetectorState :
                            dom({ i_A, e_A | e_A : childsOfElementType( "requiredDetectorState", e_rr'recId)
                                & i_A = rec(
                                    xmlLineNumber : STRING_TO_INT(e_A'meta("xmlLineNumber")),
                                    mustOrShould : IF "mustOrShould" : dom(e_A'attributes) THEN TYPED_STRING_TO_ENUM(RailML3_IL_REQUIRE_ENFORCEMENT_LEVELS, "require_"^e_A'attributes("mustOrShould")) ELSE require_must END,
                                    proving : IF "proving" : dom(e_A'attributes) THEN TYPED_STRING_TO_ENUM(RailML3_IL_REQUIRE_PROVING_TYPES, "proving_"^e_A'attributes("proving")) ELSE proving_oneOff END,
                                    isNegated: IF "isNegated" : dom(e_A'attributes) & e_A'attributes("isNegated") = "true" THEN TRUE ELSE FALSE END,
                                    relatedDetectorAndState :
                                        dom({ a, c | c : childsOfElementType( "relatedDetectorAndState", e_A'recId)
                                            & #c2.(c2 : childsOfElementType( "refersToDetector", c'recId)
                                            & a = rec(
                                                xmlLineNumber : STRING_TO_INT(c'meta("xmlLineNumber")),
                                                refersToDetector : c2'attributes[{"ref"}],
                                                inState : IF "inState" : dom(c'attributes) THEN {TYPED_STRING_TO_ENUM(RailML3_IL_DETECTOR_STATES, "detector_"^c'attributes("inState"))} ELSE {} END,
                                                isNegated: IF "isNegated" : dom(c'attributes) & c'attributes("isNegated") = "true" THEN TRUE ELSE FALSE END
                                        ))})
                                )
                            }),
                        requiredSectionState :
                            dom({ i_A, e_A | e_A : childsOfElementType( "requiredSectionState", e_rr'recId)
                                & i_A = rec(
                                    xmlLineNumber : STRING_TO_INT(e_A'meta("xmlLineNumber")),
                                    mustOrShould : IF "mustOrShould" : dom(e_A'attributes) THEN TYPED_STRING_TO_ENUM(RailML3_IL_REQUIRE_ENFORCEMENT_LEVELS, "require_"^e_A'attributes("mustOrShould")) ELSE require_must END,
                                    proving : IF "proving" : dom(e_A'attributes) THEN TYPED_STRING_TO_ENUM(RailML3_IL_REQUIRE_PROVING_TYPES, "proving_"^e_A'attributes("proving")) ELSE proving_oneOff END,
                                    isNegated: IF "isNegated" : dom(e_A'attributes) & e_A'attributes("isNegated") = "true" THEN TRUE ELSE FALSE END,
                                    relatedSectionAndVacancy :
                                        dom({ a, c | c : childsOfElementType( "relatedSectionAndVacancy", e_A'recId)
                                            & #c2.(c2 : childsOfElementType( "refersToSection", c'recId)
                                            & a = rec(
                                                xmlLineNumber : STRING_TO_INT(c'meta("xmlLineNumber")),
                                                refersToSection : c2'attributes[{"ref"}],
                                                inState : IF "inState" : dom(c'attributes) THEN {TYPED_STRING_TO_ENUM(RailML3_IL_TVD_SECTION_STATES, "tvd_"^c'attributes("inState"))} ELSE {} END,
                                                isNegated: IF "isNegated" : dom(c'attributes) & c'attributes("isNegated") = "true" THEN TRUE ELSE FALSE END
                                        ))})
                                )
                            }),
                        requiredSwitchPosition :
                            dom({ i_A, e_A | e_A : childsOfElementType( "requiredSwitchPosition", e_rr'recId)
                                & i_A = rec(
                                    xmlLineNumber : STRING_TO_INT(e_A'meta("xmlLineNumber")),
                                    mustOrShould : IF "mustOrShould" : dom(e_A'attributes) THEN TYPED_STRING_TO_ENUM(RailML3_IL_REQUIRE_ENFORCEMENT_LEVELS, "require_"^e_A'attributes("mustOrShould")) ELSE require_must END,
                                    proving : IF "proving" : dom(e_A'attributes) THEN TYPED_STRING_TO_ENUM(RailML3_IL_REQUIRE_PROVING_TYPES, "proving_"^e_A'attributes("proving")) ELSE proving_oneOff END,
                                    isNegated: IF "isNegated" : dom(e_A'attributes) & e_A'attributes("isNegated") = "true" THEN TRUE ELSE FALSE END,
                                    relatedSwitchAndPosition :
                                        dom({ a, c | c : childsOfElementType( "relatedSwitchAndPosition", e_A'recId)
                                            & #c2.(c2 : childsOfElementType( "refersToSwitch", c'recId)
                                            & a = rec(
                                                xmlLineNumber : STRING_TO_INT(c'meta("xmlLineNumber")),
                                                refersToSwitch : c2'attributes[{"ref"}],
                                                inPosition : IF "inPosition" : dom(c'attributes) THEN {TYPED_STRING_TO_ENUM(RailML3_IL_SWITCH_POSITIONS, "position_"^c'attributes("inPosition"))} ELSE {} END,
                                                isNegated: IF "isNegated" : dom(c'attributes) & c'attributes("isNegated") = "true" THEN TRUE ELSE FALSE END
                                        ))})
                                )
                            })
                    ) })
        END
    END;
    RULE is_valid_routeRelation
    DEPENDS_ON_COMPUTATION set_routeRelation
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_routeRelation) & IF card(RailML3_routeRelations) = 1 THEN c = 0 ELSE c /= 0 END // (1..*), 0 if no routeRelations
        COUNTEREXAMPLE
            IF card(RailML3_routeRelations) = 1 
                THEN errorCardOnlyLowerBound("routeRelation", RailML3_routeRelations, 1, c)
                ELSE errorCard("routeRelation", RailML3_routeRelation, 0, 0, c)
            END
        END;
        RULE_FAIL e
            WHEN e : RailML3_routeRelation & (card(e'Id) /= 1 or (card(e'Id) = 1 & MU_WD(e'Id) = ""))
        COUNTEREXAMPLE
            errorAttribute("id", "routeRelation", e'xmlLineNumber)
        END;
        // related derailer positions:
        RULE_FAIL e_rr, e_rp, c
            WHEN e_rr : RailML3_routeRelation & e_rp : e_rr'requiredDerailerPosition & c = card(e_rp'relatedDerailerAndPosition) & c /= 1
        COUNTEREXAMPLE
            errorCard("relatedDerailerAndPosition", {e_rp}, 1, 1, c)
        END;
        RULE_FAIL e_rr, e_rp, e_rdap, c
            WHEN e_rr : RailML3_routeRelation & e_rp : e_rr'requiredDerailerPosition & e_rdap : e_rp'relatedDerailerAndPosition & c = card(e_rdap'refersToDerailer) & c /= 1
        COUNTEREXAMPLE
            errorCard("refersToDerailer", {e_rdap}, 1, 1, c)
        END;
        RULE_FAIL e_rr, e_rp, e_rdap
            WHEN e_rr : RailML3_routeRelation & e_rp : e_rr'requiredDerailerPosition & e_rdap : e_rp'relatedDerailerAndPosition & card(e_rdap'refersToDerailer) = 1 & MU_WD(e_rdap'refersToDerailer) /: allIdsOfType("derailerIS")
        COUNTEREXAMPLE
            errorReference("refersToDerailer", MU_WD(e_rdap'refersToDerailer), "derailerIL", e_rdap'xmlLineNumber)
        END;
        // related detector states:
        RULE_FAIL e_rr, e_rp, c
            WHEN e_rr : RailML3_routeRelation & e_rp : e_rr'requiredDetectorState & c = card(e_rp'relatedDetectorAndState) & c /= 1
        COUNTEREXAMPLE
            errorCard("relatedDetectorAndState", {e_rp}, 1, 1, c)
        END;
        RULE_FAIL e_rr, e_rp, e_rdas, c
            WHEN e_rr : RailML3_routeRelation & e_rp : e_rr'requiredDetectorState & e_rdas : e_rp'relatedDetectorAndState & c = card(e_rdas'refersToDetector) & c /= 1
        COUNTEREXAMPLE
            errorCard("refersToDetector", {e_rdas}, 1, 1, c)
        END;
        RULE_FAIL e_rr, e_rp, e_rdas
            WHEN e_rr : RailML3_routeRelation & e_rp : e_rr'requiredDetectorState & e_rdas : e_rp'relatedDetectorAndState & card(e_rdas'refersToDetector) = 1 & MU_WD(e_rdas'refersToDetector) /: allIdsOfType("trainDetectionElement")
        COUNTEREXAMPLE
            errorReference("refersToDetector", MU_WD(e_rdas'refersToDetector), "trainDetectionElement", e_rdas'xmlLineNumber)
        END;
        // related section states:
        RULE_FAIL e_rr, e_rp, c
            WHEN e_rr : RailML3_routeRelation & e_rp : e_rr'requiredSectionState & c = card(e_rp'relatedSectionAndVacancy) & c /= 1
        COUNTEREXAMPLE
            errorCard("relatedSectionAndVacancy", {e_rp}, 1, 1, c)
        END;
        RULE_FAIL e_rr, e_rp, e_rsav, c
            WHEN e_rr : RailML3_routeRelation & e_rp : e_rr'requiredSectionState & e_rsav : e_rp'relatedSectionAndVacancy & c = card(e_rsav'refersToSection) & c /= 1
        COUNTEREXAMPLE
            errorCard("refersToSection", {e_rsav}, 1, 1, c)
        END;
        RULE_FAIL e_rr, e_rp, e_rsav
            WHEN e_rr : RailML3_routeRelation & e_rp : e_rr'requiredSectionState & e_rsav : e_rp'relatedSectionAndVacancy & card(e_rsav'refersToSection) = 1 & MU_WD(e_rsav'refersToSection) /: allIdsOfType("tvdSection")
        COUNTEREXAMPLE
            errorReference("refersToSection", MU_WD(e_rsav'refersToSection), "tvdSection", e_rsav'xmlLineNumber)
        END;
        // related switch positions:
        RULE_FAIL e_rr, e_rp, c
            WHEN e_rr : RailML3_routeRelation & e_rp : e_rr'requiredSwitchPosition & c = card(e_rp'relatedSwitchAndPosition) & c /= 1
        COUNTEREXAMPLE
            errorCard("relatedSwitchAndPosition", {e_rp}, 1, 1, c)
        END;
        RULE_FAIL e_rr, e_rp, e_rsap, c
            WHEN e_rr : RailML3_routeRelation & e_rp : e_rr'requiredSwitchPosition & e_rsap : e_rp'relatedSwitchAndPosition & c = card(e_rsap'refersToSwitch) & c /= 1
        COUNTEREXAMPLE
            errorCard("refersToSwitch", {e_rsap}, 1, 1, c)
        END;
        RULE_FAIL e_rr, e_rp, e_rsap
            WHEN e_rr : RailML3_routeRelation & e_rp : e_rr'requiredSwitchPosition & e_rsap : e_rp'relatedSwitchAndPosition & card(e_rsap'refersToSwitch) = 1 & MU_WD(e_rsap'refersToSwitch) /: allIdsOfType("switchIL")
        COUNTEREXAMPLE
            errorReference("refersToSwitch", MU_WD(e_rsap'refersToSwitch), "switchIL", e_rsap'xmlLineNumber)
        END;
        RULE_FORALL e
            WHERE e : RailML3_routeRelation & card(RailML3_routeRelations) = 1
            EXPECT e'pId = MU_WD(RailML3_routeRelations)'recId
        COUNTEREXAMPLE
            errorParent("routeRelation", "routeRelations", e'xmlLineNumber)
        END
    END;    

    COMPUTATION set_IL_ROUTE_RELATION
    DEPENDS_ON_RULE is_valid_routeRelation
    BODY
        DEFINE RailML3_IL_ROUTE_RELATION_MUST_DERAILER_POSITIONS
            TYPE allIdsOfType("routeRelation") +-> ((RailML3_IL_REQUIRE_PROVING_TYPES*BOOL) <-> (allIdsOfType("derailerIS") +-> (allIdsOfType("derailerIL") * RailML3_IL_DERAILER_POSITIONS)))
            VALUE
                { i_rr, prov | i_rr : allIdsOfType("routeRelation")
                    & prov =
                        { provtype_bool, pos | #(e_rr, e_rsp, e_rsp_pos).(
                            e_rr : RailML3_routeRelation & i_rr = MU(e_rr'Id)
                            & e_rsp : e_rr'requiredDerailerPosition & e_rsp'mustOrShould = require_must
                            & e_rsp_pos : e_rsp'relatedDerailerAndPosition
                            & provtype_bool = e_rsp'proving |-> e_rsp'isNegated
                            & pos = { i_der, position | #e_der.(i_der : allIdsOfType("derailerIS")
                                & e_der = elementOfId(RailML3_derailerIL, MU_WD(e_rsp_pos'refersToDerailer)) & i_der = MU_WD(e_der'refersTo)
                                & prj1(position) = MU_WD(e_der'Id)
                                & IF e_rsp_pos'isNegated = FALSE THEN prj2(position) = MU_WD(e_rsp_pos'inPosition) ELSE prj2(position) = negatedDerailerPosition(MU_WD(e_rsp_pos'inPosition)) END
                            )}
                        )}
                    & prov /= {}
                }
        END;
        // TODO: Detector States (currently not in use)
        DEFINE RailML3_IL_ROUTE_RELATION_MUST_SECTION_STATES
            TYPE allIdsOfType("routeRelation") +-> ((RailML3_IL_REQUIRE_PROVING_TYPES*BOOL) <-> (allIdsOfType("tvdSection") * RailML3_IL_TVD_SECTION_STATES))
            VALUE
                { i_rr, prov | i_rr : allIdsOfType("routeRelation")
                    & prov =
                        { provtype_bool, st | #(e_rr, e_rsp, e_rsp_pos, state).(
                            e_rr : RailML3_routeRelation & i_rr = MU_WD(e_rr'Id)
                            & e_rsp : e_rr'requiredSectionState & e_rsp'mustOrShould = require_must
                            & e_rsp_pos : e_rsp'relatedSectionAndVacancy
                            & provtype_bool = e_rsp'proving |-> e_rsp'isNegated
                            & st = MU(e_rsp_pos'refersToSection) |-> state
                            & IF e_rsp_pos'isNegated = FALSE THEN state = MU_WD(e_rsp_pos'inState) ELSE state = negatedSectionState(MU_WD(e_rsp_pos'inState)) END
                        )}
                    & prov /= {}
                }
        END;
        DEFINE RailML3_IL_ROUTE_RELATION_MUST_SWITCH_POSITIONS
            TYPE allIdsOfType("routeRelation") +-> ((RailML3_IL_REQUIRE_PROVING_TYPES*BOOL) <-> (RailML3_IS_SWITCH_IDS +-> (allIdsOfType("switchIL") +-> RailML3_IL_SWITCH_POSITIONS)))
            VALUE
                { i_rr, prov | i_rr : allIdsOfType("routeRelation")
                    & prov =
                        { provtype_bool, pos | #(e_rr, e_rsp, e_rsp_pos).(
                            e_rr : RailML3_routeRelation & i_rr = MU_WD(e_rr'Id)
                            & e_rsp : e_rr'requiredSwitchPosition & e_rsp'mustOrShould = require_must
                            & e_rsp_pos : e_rsp'relatedSwitchAndPosition
                            & provtype_bool = e_rsp'proving |-> e_rsp'isNegated
                            & pos = { i_sw, positions | #e_sw.(i_sw : RailML3_IS_SWITCH_IDS
                                & e_sw = elementOfId(RailML3_switchIL, MU_WD(e_rsp_pos'refersToSwitch)) & i_sw = MU_WD(e_sw'refersTo)
                                & positions = { i_sw_il, sw_pos | i_sw_il = MU_WD(e_sw'Id) & IF e_rsp_pos'isNegated = FALSE THEN sw_pos = MU_WD(e_rsp_pos'inPosition) ELSE sw_pos = negatedSwitchPosition(MU_WD(e_rsp_pos'inPosition)) END}
                            )}
                        )}
                    & prov /= {}
                }
        END
    END;

    RULE validate_routeRelation
    DEPENDS_ON_COMPUTATION set_IL_ROUTE_RELATION
    BODY
        // related derailer positions:
        RULE_FORALL e_rr, i_rr, i_der, must_pos
            WHERE e_rr : RailML3_routeRelation & i_rr = MU_WD(e_rr'Id) & i_rr : dom(RailML3_IL_ROUTE_RELATION_MUST_DERAILER_POSITIONS) & i_der : allIdsOfType("derailerIS")
                & must_pos = union(RailML3_IL_ROUTE_RELATION_MUST_DERAILER_POSITIONS(i_rr)[RailML3_IL_REQUIRE_PROVING_TYPES * {FALSE}])[{i_der}]
            EXPECT card(must_pos) <= 1 & must_pos /\ union(RailML3_IL_ROUTE_RELATION_MUST_DERAILER_POSITIONS(i_rr)[RailML3_IL_REQUIRE_PROVING_TYPES * {TRUE}])[{i_der}] = {}
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: Route relation specifies multiple must positions for derailer '~w'", e_rr'xmlLineNumber, i_rr, i_der)
        END;
        // TODO: related detector states as soon as needed
        // related section states:
        RULE_FORALL e_rr, i_rr, i_tvd, must_st
            WHERE e_rr : RailML3_routeRelation & i_rr = MU_WD(e_rr'Id) & i_rr : dom(RailML3_IL_ROUTE_RELATION_MUST_SECTION_STATES) & i_tvd : allIdsOfType("tvdSection")
                & must_st = RailML3_IL_ROUTE_RELATION_MUST_SECTION_STATES(i_rr)[RailML3_IL_REQUIRE_PROVING_TYPES * {FALSE}][{i_tvd}]
            EXPECT card(must_st) <= 1 & must_st /\ RailML3_IL_ROUTE_RELATION_MUST_SECTION_STATES(i_rr)[RailML3_IL_REQUIRE_PROVING_TYPES * {TRUE}][{i_tvd}] = {}
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: Route relation specifies multiple must states for section '~w'", e_rr'xmlLineNumber, i_rr, i_tvd)
        END;
        // related switch positions:
        RULE_FORALL e_rr, i_rr, i_sw, must_pos
            WHERE e_rr : RailML3_routeRelation & i_rr = MU_WD(e_rr'Id) & i_rr : dom(RailML3_IL_ROUTE_RELATION_MUST_SWITCH_POSITIONS) & i_sw : RailML3_IS_SWITCH_IDS
                & must_pos = union(RailML3_IL_ROUTE_RELATION_MUST_SWITCH_POSITIONS(i_rr)[RailML3_IL_REQUIRE_PROVING_TYPES * {FALSE}])[{i_sw}]
            EXPECT card(must_pos) <= 1 & must_pos /\ union(RailML3_IL_ROUTE_RELATION_MUST_SWITCH_POSITIONS(i_rr)[RailML3_IL_REQUIRE_PROVING_TYPES * {TRUE}])[{i_sw}] = {}
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: Route relation specifies multiple must positions for switch '~w'", e_rr'xmlLineNumber, i_rr, i_sw)
        END
    END;
    RULE warnings_routeRelation
    DEPENDS_ON_COMPUTATION set_IL_ROUTE_RELATION
    ERROR_TYPES 2
    BODY
        // related derailer positions:
        RULE_FAIL e_rr, e_rp
            WHEN e_rr : RailML3_routeRelation & e_rp : childsOfElementType( "requiredDerailerPosition", e_rr'recId) & "mustOrShould" /: dom(e_rp'attributes)
        COUNTEREXAMPLE
            warningDefaultValue("mustOrShould", "must", STRING_TO_INT(e_rp'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_rr, e_rp
            WHEN e_rr : RailML3_routeRelation & e_rp : childsOfElementType( "requiredDerailerPosition", e_rr'recId) & "proving" /: dom(e_rp'attributes)
        COUNTEREXAMPLE
            warningDefaultValue("proving", "oneOff", STRING_TO_INT(e_rp'meta("xmlLineNumber")))
        END;
        // related detector states:
        RULE_FAIL e_rr, e_rp
            WHEN e_rr : RailML3_routeRelation & e_rp : childsOfElementType( "requiredDetectorState", e_rr'recId) & "mustOrShould" /: dom(e_rp'attributes)
        COUNTEREXAMPLE
            warningDefaultValue("mustOrShould", "must", STRING_TO_INT(e_rp'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_rr, e_rp
            WHEN e_rr : RailML3_routeRelation & e_rp : childsOfElementType( "requiredDetectorState", e_rr'recId) & "proving" /: dom(e_rp'attributes)
        COUNTEREXAMPLE
            warningDefaultValue("proving", "oneOff", STRING_TO_INT(e_rp'meta("xmlLineNumber")))
        END;
        // related section states:
        RULE_FAIL e_rr, e_rp
            WHEN e_rr : RailML3_routeRelation & e_rp : childsOfElementType( "requiredSectionState", e_rr'recId) & "mustOrShould" /: dom(e_rp'attributes)
        COUNTEREXAMPLE
            warningDefaultValue("mustOrShould", "must", STRING_TO_INT(e_rp'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_rr, e_rp
            WHEN e_rr : RailML3_routeRelation & e_rp : childsOfElementType( "requiredSectionState", e_rr'recId) & "proving" /: dom(e_rp'attributes)
        COUNTEREXAMPLE
            warningDefaultValue("proving", "oneOff", STRING_TO_INT(e_rp'meta("xmlLineNumber")))
        END;
        // related switch positions:
        RULE_FAIL e_rr, e_rp
            WHEN e_rr : RailML3_routeRelation & e_rp : childsOfElementType( "requiredSwitchPosition", e_rr'recId) & "mustOrShould" /: dom(e_rp'attributes)
        COUNTEREXAMPLE
            warningDefaultValue("mustOrShould", "must", STRING_TO_INT(e_rp'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_rr, e_rp
            WHEN e_rr : RailML3_routeRelation & e_rp : childsOfElementType( "requiredSwitchPosition", e_rr'recId) & "proving" /: dom(e_rp'attributes)
        COUNTEREXAMPLE
            warningDefaultValue("proving", "oneOff", STRING_TO_INT(e_rp'meta("xmlLineNumber")))
        END;
        RULE_FAIL WHEN bfalse ERROR_TYPE 2 COUNTEREXAMPLE "" END // to implement error type 2
    END;    
    // END ROUTE_RELATIONS

    // BEGIN ROUTES
    COMPUTATION set_routes
    DEPENDS_ON_RULE is_valid_assetsForInterlocking
    BODY
        DEFINE RailML3_routes
            TYPE FIN(RailML3_IL_generic_Type)
            VALUE genericILType("routes")
        END
    END;
    RULE is_valid_routes
    DEPENDS_ON_COMPUTATION set_routes
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_routes) & c /: 0..card(RailML3_assetsForInterlocking) // (0..1), 0 if no assetsForInterlocking
        COUNTEREXAMPLE
            IF card(RailML3_assetsForInterlocking) > 0 
                THEN errorCard("routes", RailML3_assetsForInterlocking, 0, 1, c)
                ELSE errorCard("routes", RailML3_assetsForInterlocking, 0, 0, c)
            END
        END;
        RULE_FAIL e
        WHEN
            e : RailML3_routes & !e_ass.(e_ass : RailML3_assetsForInterlocking => e'pId /= e_ass'recId)
        COUNTEREXAMPLE
            errorParent("routes", "assetsForInterlocking", e'xmlLineNumber)
        END
    END;

    COMPUTATION set_route
    DEPENDS_ON_RULE is_valid_routes
    BODY
        DEFINE RailML3_route
            TYPE FIN(RailML3_IL_route_Type)
            VALUE dom({e, e_r | e_r : elementsOfType("route")
                & e = rec(
                        recId: e_r'recId,
                        pId: e_r'pId,
                        xmlLineNumber: STRING_TO_INT(e_r'meta("xmlLineNumber")),
                        Id: e_r'attributes[{"id"}],
                        locksAutomatically: IF "locksAutomatically" : dom(e_r'attributes) & e_r'attributes("locksAutomatically") = "true" THEN TRUE ELSE FALSE END,
                        processingDelay : IF "processingDelay" : dom(e_r'attributes) THEN readDuration(e_r'attributes("processingDelay")) ELSE 1000 END,
                        proceedAspectDelay : IF "proceedAspectDelay" : dom(e_r'attributes) THEN readDuration(e_r'attributes("proceedAspectDelay")) ELSE 1000 END,
                        signalClosureDelay : IF "signalClosureDelay" : dom(e_r'attributes) THEN readDuration(e_r'attributes("signalClosureDelay")) ELSE 1000 END,
                        approachReleaseDelay : IF "approachReleaseDelay" : dom(e_r'attributes) THEN readDuration(e_r'attributes("approachReleaseDelay")) ELSE 1000 END,
                        residualRouteReleaseDelay : IF "residualRouteReleaseDelay" : dom(e_r'attributes) THEN readDuration(e_r'attributes("residualRouteReleaseDelay")) ELSE 1000 END,
                        priorityRank: IF "priorityRank" : dom(e_r'attributes) THEN {STRING_TO_INT(e_r'attributes("priorityRank"))} ELSE {} END,
                        additionalRelations: dom({ i_A, e_A | #ref.(e_A : childsOfElementType( "additionalRelation", e_r'recId)
                            & ref : e_A'attributes[{"ref"}]
                            & i_A = ref |-> IF version = {v3_2} & "usage" : dom(e_A'attributes) THEN {TYPED_STRING_TO_ENUM(RailML3_IL_ROUTE_RELATION_TYPES, "relation_"^e_A'attributes("usage"))} ELSE {} END) }),
                        hasTvdSections: dom({ i_A, e_A | e_A : childsOfElementType( "hasTvdSection", e_r'recId) & i_A : e_A'attributes[{"ref"}] }),
                        hasReleaseGroups: dom({ i_A, e_A | e_A : childsOfElementType( "hasReleaseGroup", e_r'recId) & i_A : e_A'attributes[{"ref"}] }),
                        routeActivationSections:
                            dom({ a, c | c : childsOfElementType( "routeActivationSection", e_r'recId)
                                & a = rec(
                                    xmlLineNumber : STRING_TO_INT(c'meta("xmlLineNumber")),
                                    Id : c'attributes[{"id"}],
                                    delayForLock : IF "delayForLock" : dom(c'attributes) THEN readDuration(c'attributes("delayForLock")) ELSE 1000 END,
                                    automaticReleaseDelay : IF "automaticReleaseDelay" : dom(c'attributes) THEN readDuration(c'attributes("automaticReleaseDelay")) ELSE 1000 END,
                                    activationSections : dom({ i_A, e_A | e_A : childsOfElementType( "activationSection", c'recId) & i_A : e_A'attributes[{"ref"}] })
                                )
                            }),
                        facingSwitchInPositions:
                            dom({ a, c | c : childsOfElementType( "facingSwitchInPosition", e_r'recId)
                                & #c2.(c2 : childsOfElementType( "refersToSwitch", c'recId)
                                & a = rec(
                                    xmlLineNumber : STRING_TO_INT(c'meta("xmlLineNumber")),
                                    refersToSwitch : c2'attributes[{"ref"}],
                                    inPosition : IF "inPosition" : dom(c'attributes) THEN {TYPED_STRING_TO_ENUM(RailML3_IL_SWITCH_POSITIONS, "position_"^c'attributes("inPosition"))} ELSE {} END,
                                    isNegated: IF "isNegated" : dom(c'attributes) & c'attributes("isNegated") = "true" THEN TRUE ELSE FALSE END
                            ))}),
                        trailingSwitchInPositions:
                            dom({ a, c | c : childsOfElementType( "trailingSwitchInPosition", e_r'recId)
                                & #c2.(c2 : childsOfElementType( "refersToSwitch", c'recId)
                                & a = rec(
                                    xmlLineNumber : STRING_TO_INT(c'meta("xmlLineNumber")),
                                    refersToSwitch : c2'attributes[{"ref"}],
                                    inPosition : IF "inPosition" : dom(c'attributes) THEN {TYPED_STRING_TO_ENUM(RailML3_IL_SWITCH_POSITIONS, "position_"^c'attributes("inPosition"))} ELSE {} END,
                                    isNegated: IF "isNegated" : dom(c'attributes) & c'attributes("isNegated") = "true" THEN TRUE ELSE FALSE END
                            ))}),
                        switchPositionsInDepartureTrack:
                            dom({ a, c | c : childsOfElementType( "switchPositionInDepartureTrack", e_r'recId)
                                & #c2.(c2 : childsOfElementType( "refersToSwitch", c'recId)
                                & a = rec(
                                    xmlLineNumber : STRING_TO_INT(c'meta("xmlLineNumber")),
                                    refersToSwitch : c2'attributes[{"ref"}],
                                    inPosition : IF "inPosition" : dom(c'attributes) THEN {TYPED_STRING_TO_ENUM(RailML3_IL_SWITCH_POSITIONS, "position_"^c'attributes("inPosition"))} ELSE {} END,
                                    isNegated: IF "isNegated" : dom(c'attributes) & c'attributes("isNegated") = "true" THEN TRUE ELSE FALSE END
                            ))}),
                        routeEntry:
                            dom({ a, c | c : childsOfElementType( "routeEntry", e_r'recId)
                                & #c2.(c2 : childsOfElementType( "refersTo", c'recId)
                                & a = rec(
                                    xmlLineNumber : STRING_TO_INT(c'meta("xmlLineNumber")),
                                    Id: c'attributes[{"id"}],
                                    refersTo : c2'attributes[{"ref"}],
                                    nonReplacement : c'attributes[{"nonReplacement"}]
                            ))}),
                        routeExit:
                            dom({ a, c | c : childsOfElementType( "routeExit", e_r'recId)
                                & a = rec(                                    
                                    xmlLineNumber : STRING_TO_INT(c'meta("xmlLineNumber")),
                                    Id: c'attributes[{"id"}],
                                    refersTo : dom({ i_A, e_A | e_A : childsOfElementType( "refersTo", c'recId) & i_A = e_A'attributes("ref") }),
                                    hasOverlaps : dom({ i_A, e_A | e_A : childsOfElementType( "hasOverlap", c'recId) & i_A = e_A'attributes("ref") })
                            )})
                    ) })
        END
    END;
    RULE is_valid_route
    DEPENDS_ON_COMPUTATION set_route
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_route) & IF card(RailML3_routes) = 1 THEN c = 0 ELSE c /= 0 END // (1..*), 0 if no routes
        COUNTEREXAMPLE
            IF card(RailML3_routes) = 1 
                THEN errorCardOnlyLowerBound("route", RailML3_routes, 1, c)
                ELSE errorCard("route", RailML3_route, 0, 0, c)
            END
        END;
        RULE_FAIL e
            WHEN e : RailML3_route & (card(e'Id) /= 1 or (card(e'Id) = 1 & MU_WD(e'Id) = ""))
        COUNTEREXAMPLE
            errorAttribute("id", "route", e'xmlLineNumber)
        END;
        RULE_FAIL e_r, c
            WHEN e_r : RailML3_route & c = card(e_r'routeEntry) & c /= 1
        COUNTEREXAMPLE
            errorCard("routeEntry", {e_r}, 1, 1, c)
        END;
        RULE_FAIL e_r, e_re
            WHEN e_r : RailML3_route & e_re : e_r'routeEntry & (card(e_re'Id) /= 1 or card(e_re'Id) = 1 & MU_WD(e_re'Id) = "")
        COUNTEREXAMPLE
            errorAttribute("id", "routeEntry", e_re'xmlLineNumber)
        END;
        RULE_FAIL e_r, e_re, c
            WHEN e_r : RailML3_route & e_re : e_r'routeEntry & c = card(e_re'refersTo) & c /= 1
        COUNTEREXAMPLE
            errorCard("refersTo", {e_re}, 1, 1, c)
        END;
        RULE_FAIL e_r, e_re
            WHEN e_r : RailML3_route & e_re : e_r'routeEntry & card(e_re'refersTo) = 1 & MU_WD(e_re'refersTo) /: union(allIdsOfType[{"bufferStop", "signalIL"}]) \/ RailML3_IS_OPENEND_IDS
        COUNTEREXAMPLE
            errorReference("refersTo", MU_WD(e_re'refersTo), "signalIL", e_r'xmlLineNumber)
        END;
        RULE_FAIL e_r, c
            WHEN e_r : RailML3_route & c = card(e_r'routeExit) & c /= 1
        COUNTEREXAMPLE
            errorCard("routeExit", {e_r}, 1, 1, c)
        END;
        RULE_FAIL e_r, e_re
            WHEN e_r : RailML3_route & e_re : e_r'routeExit & (card(e_re'Id) /= 1 or card(e_re'Id) = 1 & MU_WD(e_re'Id) = "")
        COUNTEREXAMPLE
            errorAttribute("id", "routeExit", e_re'xmlLineNumber)
        END;
        RULE_FAIL e_r, e_re, c
            WHEN e_r : RailML3_route & e_re : e_r'routeExit & c = card(e_re'refersTo) & c /= 1
        COUNTEREXAMPLE
            errorCard("refersTo", {e_re}, 1, 1, c)
        END;
        RULE_FAIL e_r, e_re
            WHEN e_r : RailML3_route & e_re : e_r'routeExit & card(e_re'refersTo) = 1 & MU_WD(e_re'refersTo) /: union(allIdsOfType[{"bufferStop", "signalIL"}]) \/ RailML3_IS_OPENEND_IDS
        COUNTEREXAMPLE
            errorReference("refersTo", MU_WD(e_re'refersTo), "signalIL", e_r'xmlLineNumber)
        END;
        RULE_FAIL e_r, e_r_data
            WHEN e_r : RailML3_route & e_r_data : childsOfElementType("additionalRelation", e_r'recId) & ("ref" /: dom(e_r_data'attributes) or "ref" |-> "" : e_r_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "additionalRelation", STRING_TO_INT(e_r_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_r, e_r_data
            WHEN e_r : RailML3_route & e_r_data : childsOfElementType("hasTvdSection", e_r'recId) & ("ref" /: dom(e_r_data'attributes) or "ref" |-> "" : e_r_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "hasTvdSection", STRING_TO_INT(e_r_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_r, e_r_data
            WHEN e_r : RailML3_route & e_r_data : childsOfElementType("hasReleaseGroup", e_r'recId) & ("ref" /: dom(e_r_data'attributes) or "ref" |-> "" : e_r_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "hasReleaseGroup", STRING_TO_INT(e_r_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_r, e_as
            WHEN version = {v3_2} & e_r : RailML3_route & e_as : e_r'routeActivationSections & (card(e_as'Id) /= 1 or card(e_as'Id) = 1 & MU_WD(e_as'Id) = "")
        COUNTEREXAMPLE
            errorAttribute("id", "routeActivationSection", e_as'xmlLineNumber)
        END;
        RULE_FAIL e_r, e_r_data, e_as_data
            WHEN e_r : RailML3_route & e_r_data : childsOfElementType("routeActivationSection", e_r'recId) & e_as_data : childsOfElementType("activationSection", e_r_data'recId) & ("ref" /: dom(e_as_data'attributes) or "ref" |-> "" : e_as_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "activationSection", STRING_TO_INT(e_as_data'meta("xmlLineNumber")))
        END;        
        RULE_FAIL e_r, e_fsw, c
            WHEN e_r : RailML3_route & e_fsw : e_r'facingSwitchInPositions & c = card(e_fsw'refersToSwitch) & c /= 1
        COUNTEREXAMPLE
            errorCard("refersToSwitch", {e_fsw}, 1, 1, c)
        END;
        RULE_FAIL e_r, e_fsw
            WHEN e_r : RailML3_route & e_fsw : e_r'facingSwitchInPositions & card(e_fsw'refersToSwitch) = 1 & MU_WD(e_fsw'refersToSwitch) /: allIdsOfType("switchIL")
        COUNTEREXAMPLE
            errorReference("refersToSwitch", MU_WD(e_fsw'refersToSwitch), "switchIL", e_r'xmlLineNumber)
        END;
        RULE_FAIL e_r, e_fsw, c
            WHEN e_r : RailML3_route & e_fsw : e_r'facingSwitchInPositions & c = card(e_fsw'inPosition) & c /= 1
        COUNTEREXAMPLE
            errorCard("inPosition", {e_fsw}, 1, 1, c)
        END;
        RULE_FAIL e_r, e_tsw, c
            WHEN e_r : RailML3_route & e_tsw : e_r'trailingSwitchInPositions & c = card(e_tsw'refersToSwitch) & c /= 1
        COUNTEREXAMPLE
            errorCard("refersToSwitch", {e_tsw}, 1, 1, c)
        END;
        RULE_FAIL e_r, e_tsw
            WHEN e_r : RailML3_route & e_tsw : e_r'trailingSwitchInPositions & card(e_tsw'refersToSwitch) = 1 & MU_WD(e_tsw'refersToSwitch) /: allIdsOfType("switchIL")
        COUNTEREXAMPLE
            errorReference("refersToSwitch", MU_WD(e_tsw'refersToSwitch), "switchIL", e_r'xmlLineNumber)
        END;
        RULE_FAIL e_r, e_tsw, c
            WHEN e_r : RailML3_route & e_tsw : e_r'trailingSwitchInPositions & c = card(e_tsw'inPosition) & c /= 1
        COUNTEREXAMPLE
            errorCard("inPosition", {e_tsw}, 1, 1, c)
        END;
        RULE_FAIL e_r, e_spdt, c
            WHEN e_r : RailML3_route & e_spdt : e_r'switchPositionsInDepartureTrack & c = card(e_spdt'refersToSwitch) & c /= 1
        COUNTEREXAMPLE
            errorCard("refersToSwitch", {e_spdt}, 1, 1, c)
        END;
        RULE_FAIL e_r, e_spdt
            WHEN e_r : RailML3_route & e_spdt : e_r'switchPositionsInDepartureTrack & card(e_spdt'refersToSwitch) = 1 & MU_WD(e_spdt'refersToSwitch) /: allIdsOfType("switchIL")
        COUNTEREXAMPLE
            errorReference("refersToSwitch", MU_WD(e_spdt'refersToSwitch), "switchIL", e_r'xmlLineNumber)
        END;
        RULE_FAIL e_r, e_spdt, c
            WHEN e_r : RailML3_route & e_spdt : e_r'switchPositionsInDepartureTrack & c = card(e_spdt'inPosition) & c /= 1
        COUNTEREXAMPLE
            errorCard("inPosition", {e_spdt}, 1, 1, c)
        END;
        RULE_FORALL e
            WHERE e : RailML3_route & card(RailML3_routes) = 1
            EXPECT e'pId = MU_WD(RailML3_routes)'recId
        COUNTEREXAMPLE
            errorParent("route", "routes", e'xmlLineNumber)
        END
    END;

    COMPUTATION set_ROUTE
    DEPENDS_ON_COMPUTATION set_NET_ELEMENT, set_NET_RELATION, set_SIGNAL, set_IL_DERAILER, set_IL_MOVABLE_CROSSING, set_IL_SWITCH, set_SPOT_LOCATION, set_TVD_SECTIONS
    BODY
        DEFINE RailML3_IL_ROUTE_FORCED_SWITCH_POSITIONS
        TYPE allIdsOfType("route") +-> (RailML3_IS_SWITCH_IDS +-> (allIdsOfType("switchIL") +-> RailML3_IL_SWITCH_POSITIONS))
        VALUE 
            { i_r, sig_pos | i_r : allIdsOfType("route")
                & sig_pos = 
                    { i_sw, positions | i_sw : RailML3_IS_SWITCH_IDS
                        & #e_r.(e_r : RailML3_route & i_r = MU(e_r'Id)
                            & positions =
                                { i_sw_il, sw_pos | #e_ftsw.(
                                    e_ftsw : e_r'facingSwitchInPositions \/ e_r'trailingSwitchInPositions \/ e_r'switchPositionsInDepartureTrack
                                    & i_sw = RailML3_IL_SWITCH_REFERS_TO(MU_WD(e_ftsw'refersToSwitch))
                                    & i_sw_il = MU(e_ftsw'refersToSwitch) & IF e_ftsw'isNegated = FALSE THEN sw_pos = MU_WD(e_ftsw'inPosition) ELSE sw_pos = negatedSwitchPosition(MU_WD(e_ftsw'inPosition)) END
                                ) }
                            & positions /= {}
                        )
                    }
                & sig_pos /= {}
            }
        END;
        DEFINE RailML3_IL_ROUTE_ENTRY
            TYPE allIdsOfType("route") --> ((allIdsOfType("bufferStop") \/ RailML3_IS_OPENEND_IDS \/ allIdsOfType("signalIL")) * (allIdsOfType("netElement") * REAL * RailML3_IS_DIRECTION))
            VALUE 
                { i_r, entry | #(e_r, ref_entry, ne_entry).(e_r : RailML3_route & i_r = MU_WD(e_r'Id) & ref_entry = MU_WD(MU_WD(e_r'routeEntry)'refersTo)
                    & ne_entry : IF ref_entry : allIdsOfType("bufferStop") \/ RailML3_IS_OPENEND_IDS
                            THEN (dom(RailML3_IS_SPOT_LOCATIONS(ref_entry)) * {direction_normal, direction_reverse}) /\ dom(RailML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS)
                            ELSE //ELSIF ref_entry : allIdsOfType("switchIL") THEN
                                RailML3_IS_SPOT_LOCATIONS(RailML3_IL_SIGNAL_REFERS_TO(ref_entry))
                        END
                    & entry = ref_entry |-> ne_entry
                )}
        END;
        DEFINE RailML3_IL_ROUTE_EXIT
            TYPE allIdsOfType("route") --> ((allIdsOfType("bufferStop") \/ RailML3_IS_OPENEND_IDS \/ allIdsOfType("signalIL")) * (allIdsOfType("netElement") * REAL * RailML3_IS_DIRECTION))
            VALUE 
                { i_r, exit | #(e_r, ref_exit, ne_exit).(e_r : RailML3_route & i_r = MU_WD(e_r'Id) & ref_exit = MU_WD(MU_WD(e_r'routeExit)'refersTo)
                    & ne_exit : IF ref_exit : allIdsOfType("bufferStop") \/ RailML3_IS_OPENEND_IDS
                            THEN (dom(RailML3_IS_SPOT_LOCATIONS(ref_exit)) * {direction_normal, direction_reverse}) /\ ran(RailML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS)
                            ELSE //ELSIF ref_entry : allIdsOfType("switchIL") THEN
                                RailML3_IS_SPOT_LOCATIONS(RailML3_IL_SIGNAL_REFERS_TO(ref_exit))
                        END
                    & exit = ref_exit |-> ne_exit
                )}
        END;
        DEFINE RailML3_IL_ROUTE_NXT
            TYPE allIdsOfType("route") --> ((allIdsOfType("netElement") * REAL * RailML3_IS_DIRECTION) >+> (allIdsOfType("netElement") * REAL * RailML3_IS_DIRECTION))
            VALUE 
                %i_r.(i_r : allIdsOfType("route") |
                    { nxt | #(inner_nxt, ne_entry, ne_exit).(
                        ne_entry = prj2(RailML3_IL_ROUTE_ENTRY(i_r))
                        & ne_exit = prj2(RailML3_IL_ROUTE_EXIT(i_r))
                        & inner_nxt = (railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1~[{ne_exit}] <| RailML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS |> railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1[{ne_entry}])
                            - { r | #(i_sw, pos).(
                                    i_r : dom(RailML3_IL_ROUTE_FORCED_SWITCH_POSITIONS)
                                    & i_sw : dom(RailML3_IL_ROUTE_FORCED_SWITCH_POSITIONS(i_r))
                                    & pos : dom(RailML3_IL_SWITCH_BRANCHES(i_sw))
                                    & RailML3_IL_ROUTE_FORCED_SWITCH_POSITIONS(i_r)(i_sw) /<: pos
                                    & r : (RailML3_IL_SWITCH_BRANCHES(i_sw)(pos))
                                )
                            } // should only be one position per switch, is validated in validation step
                        & nxt : closure(inner_nxt)[{ne_entry}] <| inner_nxt |> closure1(inner_nxt)[{ne_entry}]
                        & IF prj1(nxt) /= ne_entry THEN inner_nxt~[{prj1(nxt)}] - {prj2(nxt)} /= {} ELSE btrue END // remove switch branches fitting conditions but not on route
                        & IF prj2(nxt) /= ne_exit THEN inner_nxt[{prj2(nxt)}] - {prj1(nxt)} /= {} ELSE btrue END // remove switch branches fitting conditions but not on route 
                    ) }
                )
        END;
        DEFINE RailML3_IL_ROUTE_BLOCKS
            TYPE (allIdsOfType("netElement") * REAL * RailML3_IS_DIRECTION) <->> allIdsOfType("route")
            VALUE { b, r | r : dom(RailML3_IL_ROUTE_NXT) & b : dom(RailML3_IL_ROUTE_NXT(r)) \/ ran(RailML3_IL_ROUTE_NXT(r)) \/ ran(RailML3_IL_ROUTE_ENTRY[{r}]) \/ ran(RailML3_IL_ROUTE_EXIT[{r}]) }
        END;
        DEFINE RailML3_IL_ROUTE_CROSSING_POSITIONS
            TYPE allIdsOfType("route") +-> (RailML3_IS_MOVABLE_CROSSING_IDS +-> (allIdsOfType("movableCrossing") * RailML3_IL_CROSSING_POSITIONS))
            VALUE
                { i_r, cr_pos | i_r : allIdsOfType("route")
                    & cr_pos = { i_cr, position | i_cr : RailML3_IS_MOVABLE_CROSSING_IDS
                        & position : dom({ pos, branch |
                                pos : dom(RailML3_IL_MOVABLE_CROSSING_BRANCHES(i_cr))
                                & branch : RailML3_IL_MOVABLE_CROSSING_BRANCHES(i_cr)(pos) /\ RailML3_IL_ROUTE_NXT(i_r) })
                    }
                    & cr_pos /= {}
                }
        END;
        DEFINE RailML3_IL_ROUTE_DERAILERS // no positions needed -> clearly they should all be in passablePosition
            TYPE allIdsOfType("route") +-> FIN(allIdsOfType("derailerIS"))
            VALUE fnc({ i_r, der | i_r : allIdsOfType("route") & der : allIdsOfType("derailerIS") & #bl.(bl : RailML3_IS_DERAILER_NOT_PASSABLE(der) /\ RailML3_IL_ROUTE_NXT(i_r)) })
        END;
        DEFINE RailML3_IL_ROUTE_SWITCH_POSITIONS
            TYPE allIdsOfType("route") +-> (RailML3_IS_SWITCH_IDS +-> (allIdsOfType("switchIL") +-> RailML3_IL_SWITCH_POSITIONS))
            VALUE
                { i_r, sw_pos | i_r : allIdsOfType("route")
                    & sw_pos = { i_sw, positions | i_sw : RailML3_IS_SWITCH_IDS
                        & positions = 
                            union(dom({ pos, branch |
                                pos : dom(RailML3_IL_SWITCH_BRANCHES(i_sw))
                                & branch : RailML3_IL_SWITCH_BRANCHES(i_sw)(pos) /\ RailML3_IL_ROUTE_NXT(i_r) }))
                        & positions /= {}
                    }
                    & sw_pos /= {}
                }
        END;
        DEFINE RailML3_IL_ROUTE_RELEASE_GROUPS
            TYPE allIdsOfType("route") +-> FIN(allIdsOfType("routeReleaseGroupAhead") \/ allIdsOfType("routeReleaseGroupRear"))
            VALUE { i_r, rg | #e_r.(e_r : RailML3_route & i_r = MU_WD(e_r'Id) & rg = e_r'hasReleaseGroups ) }
        END;
        DEFINE RailML3_IL_ROUTE_OVERLAPS
            TYPE allIdsOfType("route") +-> FIN(allIdsOfType("overlap"))
            VALUE { i_r, o | #(e_r).(e_r : RailML3_route & i_r = MU_WD(e_r'Id) & o = MU_WD(e_r'routeExit)'hasOverlaps ) }
        END;
        DEFINE RailML3_IL_ROUTE_ADDITIONAL_RELATIONS
            TYPE allIdsOfType("route") +-> FIN(allIdsOfType("routeRelation"))
            VALUE { i_r, rr | #(e_r).(e_r : RailML3_route & i_r = MU_WD(e_r'Id) & rr = dom(e_r'additionalRelations) ) }
        END;
        DEFINE RailML3_IL_ROUTE_LOCKS_AUTOMATICALLY
            TYPE allIdsOfType("route") --> BOOL
            VALUE { i_r, la | i_r : allIdsOfType("route") & la = IF #e_r.(e_r : RailML3_route & i_r = MU_WD(e_r'Id) & e_r'locksAutomatically = TRUE) THEN TRUE ELSE FALSE END } 
        END;
        DEFINE RailML3_IL_ROUTE_TVD_SECTIONS
            TYPE allIdsOfType("route") +-> FIN(allIdsOfType("tvdSection"))
            VALUE { i_r, i_tvd | #e_r.(e_r = elementOfId(RailML3_route, i_r) & i_r : dom(RailML3_IL_ROUTE_NXT)
                & i_tvd = e_r'hasTvdSections \/ { i | i : dom(RailML3_IL_TVD_SECTIONS) & RailML3_IL_TVD_SECTIONS(i) /\ RailML3_IL_ROUTE_NXT(i_r) /= {} } & i_tvd /= {} ) }
        END;
        DEFINE RailML3_IL_ACTIVATION_SECTION_TVD_SECTIONS
            TYPE allIdsOfType("routeActivationSection") --> FIN(allIdsOfType("tvdSection"))
            VALUE { i_as, i_tvd | #(e_r,e_as).(e_r : RailML3_route & e_as : e_r'routeActivationSections & i_as : e_as'Id & i_tvd = e_as'activationSections - allIdsOfType("routeActivationSection")) }
        END;
        DEFINE RailML3_IL_ROUTE_ACTIVATION_SECTIONS
            TYPE allIdsOfType("route") +-> FIN(allIdsOfType("tvdSection"))
            VALUE
                { i_r, i_tvd | #e_r.(e_r = elementOfId(RailML3_route, i_r) & i_r : dom(RailML3_IL_ROUTE_NXT)
                    & IF e_r'routeActivationSections /= {} THEN
                        #e_as.(e_as : e_r'routeActivationSections
                            & i_tvd = IF card(e_as'Id) = 0 & card(e_as'activationSections) = 1 & MU_WD(e_as'activationSections) : allIdsOfType("routeActivationSection")
                                THEN RailML3_IL_ACTIVATION_SECTION_TVD_SECTIONS(MU_WD(e_as'activationSections))                            
                                ELSE e_as'activationSections END
                        )
                    ELSE
                        i_tvd = { i_t | i_t : allIdsOfType("tvdSection") & prj1(prj2(RailML3_IL_ROUTE_ENTRY(i_r))) : dom(dom(RailML3_IL_TVD_SECTIONS(i_t))) } // infer from ROUTE_FST if no activationSection provided
                    END
                    & i_tvd /= {}
                ) }
        END
    END;

    RULE validate_route
    DEPENDS_ON_COMPUTATION set_ROUTE, set_IL_ROUTE_RELATION
    BODY
        RULE_FORALL e_r, i_r
            WHERE e_r : RailML3_route & i_r = MU_WD(e_r'Id) & i_r : dom(RailML3_IL_ROUTE_ENTRY) & i_r : dom(RailML3_IL_ROUTE_EXIT)
            EXPECT prj1(RailML3_IL_ROUTE_ENTRY(i_r)) /= prj1(RailML3_IL_ROUTE_EXIT(i_r)) & prj2(RailML3_IL_ROUTE_ENTRY(i_r)) /= prj2(RailML3_IL_ROUTE_EXIT(i_r))
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: Path for route could not be initialised - routeEntry and routeExit are the same", e_r'xmlLineNumber, i_r)
        END;
        RULE_FORALL e_r, i_r
            WHERE e_r : RailML3_route & i_r = MU_WD(e_r'Id)
            EXPECT i_r : dom(RailML3_IL_ROUTE_ENTRY) & i_r : dom(RailML3_IL_ROUTE_EXIT) & RailML3_IL_ROUTE_NXT(i_r) /= {}
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: Path for route could not be initialised - check that forced switch positions, routeEntry and routeExit match the topology", e_r'xmlLineNumber, i_r)
        END;
        // route is empty => possibly forced switch positions wrong - checked below:
        RULE_FORALL e_r, i_r, i_sw
            WHERE e_r : RailML3_route & i_r = MU_WD(e_r'Id) & i_r : dom(RailML3_IL_ROUTE_FORCED_SWITCH_POSITIONS) & i_sw : dom(RailML3_IL_ROUTE_FORCED_SWITCH_POSITIONS(i_r))
            EXPECT i_r : dom(RailML3_IL_ROUTE_SWITCH_POSITIONS) & i_sw : dom(RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)) & RailML3_IL_ROUTE_FORCED_SWITCH_POSITIONS(i_r)(i_sw) <: RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)(i_sw)
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: Forced switch position for switch '~w' does not match the route path", e_r'xmlLineNumber, i_r, i_sw)
        END;
        RULE_FORALL e_r, i_r, i_sw_il
            WHERE e_r : RailML3_route & i_r = MU_WD(e_r'Id) & i_r : dom(RailML3_IL_ROUTE_FORCED_SWITCH_POSITIONS) & i_sw_il : dom(union(ran(RailML3_IL_ROUTE_FORCED_SWITCH_POSITIONS(i_r))))
            EXPECT card(union(ran(RailML3_IL_ROUTE_FORCED_SWITCH_POSITIONS(i_r)))[{i_sw_il}]) = 1
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: Multiple forced switch positions specified for (interlocking) switch '~w'", e_r'xmlLineNumber, i_r, i_sw_il)
        END;
        // additional routeRelations match to forced positions by route
        // additional derailer positions:
        RULE_FORALL e_r, i_r, i_rr, i_der
            WHERE e_r : RailML3_route & i_r = MU_WD(e_r'Id) & i_rr : dom(RailML3_IL_ROUTE_RELATION_MUST_DERAILER_POSITIONS) /\ union(RailML3_IL_ROUTE_ADDITIONAL_RELATIONS[{i_r}]) & i_der : union(RailML3_IL_ROUTE_DERAILERS[{i_r}])
            EXPECT ran(union(RailML3_IL_ROUTE_RELATION_MUST_DERAILER_POSITIONS(i_rr)[RailML3_IL_REQUIRE_PROVING_TYPES * {FALSE}])[{i_der}]) = {position_passablePosition}
                & ran(union(RailML3_IL_ROUTE_RELATION_MUST_DERAILER_POSITIONS(i_rr)[RailML3_IL_REQUIRE_PROVING_TYPES * {TRUE}])[{i_der}]) = {position_derailingPosition}
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: Route uses additional route relation '~w', which specifies a mismatching must position for derailer '~w'", e_r'xmlLineNumber, i_r, i_rr, i_der)
        END;
        // additional switch positions:
        RULE_FORALL e_r, i_r, i_rr, i_sw
            WHERE e_r : RailML3_route & i_r = MU_WD(e_r'Id) & i_rr : dom(RailML3_IL_ROUTE_RELATION_MUST_SWITCH_POSITIONS) /\ union(RailML3_IL_ROUTE_ADDITIONAL_RELATIONS[{i_r}]) & i_sw : dom(union(RailML3_IL_ROUTE_SWITCH_POSITIONS[{i_r}]))
            EXPECT union(union(RailML3_IL_ROUTE_RELATION_MUST_SWITCH_POSITIONS(i_rr)[RailML3_IL_REQUIRE_PROVING_TYPES * {FALSE}])[{i_sw}]) <: RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)(i_sw)
                & !pos.(pos : union(union(RailML3_IL_ROUTE_RELATION_MUST_SWITCH_POSITIONS(i_rr)[RailML3_IL_REQUIRE_PROVING_TYPES * {TRUE}])[{i_sw}]) => pos /: RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)(i_sw) )
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: Route uses additional route relation '~w', which specifies a mismatching must position for switch '~w'", e_r'xmlLineNumber, i_r, i_rr, i_sw)
        END;
        // Inspired by Abrial's interlocking model (two properties moved to route warnings (allow overlapping routes)) :
        RULE_FORALL r, b WHERE (r,b) : {r,b| #i.((r,(i,b)) : RailML3_IL_ROUTE_ENTRY) }~ 
            EXPECT (r,b) : RailML3_IL_ROUTE_BLOCKS
        COUNTEREXAMPLE STRING_FORMAT("routeEntry ~w /: RailML3_IL_ROUTE_BLOCKS", (r,b))
        END;
        RULE_FORALL r, b WHERE (r,b) : {r,b| #i.((r,(i,b)) : RailML3_IL_ROUTE_EXIT) }~ 
            EXPECT (r,b) : RailML3_IL_ROUTE_BLOCKS
        COUNTEREXAMPLE STRING_FORMAT("routeExit ~w /: RailML3_IL_ROUTE_BLOCKS", (r,b))
        END;
        RULE_FORALL e_r, i_r
            WHERE e_r : RailML3_route & i_r = MU_WD(e_r'Id) & i_r : dom(RailML3_IL_ROUTE_ENTRY) & i_r : dom(RailML3_IL_ROUTE_EXIT)
            EXPECT RailML3_IL_ROUTE_NXT(i_r) : (RailML3_IL_ROUTE_BLOCKS~)[{i_r}] \ {prj2(RailML3_IL_ROUTE_EXIT(i_r))} >->> (RailML3_IL_ROUTE_BLOCKS~)[{i_r}] \ {prj2(RailML3_IL_ROUTE_ENTRY(i_r))}
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: Path of route is not a total bijection of its inner route blocks", e_r'xmlLineNumber, i_r)
        END        
    END;
    RULE warnings_route
    DEPENDS_ON_COMPUTATION set_ROUTE
    ERROR_TYPES 2
    BODY
        RULE_FAIL e_r
            WHEN e_r : elementsOfType("route") & "processingDelay" /: dom(e_r'attributes)
        COUNTEREXAMPLE
            warningDefaultValue("processingDelay", "1000", STRING_TO_INT(e_r'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_r
            WHEN e_r : elementsOfType("route") & "proceedAspectDelay" /: dom(e_r'attributes)
        COUNTEREXAMPLE
            warningDefaultValue("proceedAspectDelay", "1000", STRING_TO_INT(e_r'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_r
            WHEN e_r : elementsOfType("route") & "signalClosureDelay" /: dom(e_r'attributes)
        COUNTEREXAMPLE
            warningDefaultValue("signalClosureDelay", "1000", STRING_TO_INT(e_r'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_r
            WHEN e_r : elementsOfType("route") & "approachReleaseDelay" /: dom(e_r'attributes)
        COUNTEREXAMPLE
            warningDefaultValue("approachReleaseDelay", "1000", STRING_TO_INT(e_r'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_r
            WHEN e_r : elementsOfType("route") & "residualRouteReleaseDelay" /: dom(e_r'attributes)
        COUNTEREXAMPLE
            warningDefaultValue("residualRouteReleaseDelay", "1000", STRING_TO_INT(e_r'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_as
            WHEN e_as : elementsOfType("routeActivationSection") & "delayForLock" /: dom(e_as'attributes)
        COUNTEREXAMPLE
            warningDefaultValue("delayForLock", "1000", STRING_TO_INT(e_as'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_as
            WHEN e_as : elementsOfType("routeActivationSection") & "automaticReleaseDelay" /: dom(e_as'attributes)
        COUNTEREXAMPLE
            warningDefaultValue("automaticReleaseDelay", "1000", STRING_TO_INT(e_as'meta("xmlLineNumber")))
        END;
        RULE_FAIL r, s, e_r, e_s, rtbl
        WHEN
            e_r : RailML3_route & MU_WD(e_r'Id) = r & e_s : RailML3_route & MU_WD(e_s'Id) = s
            & {r,s} <: allIdsOfType("route")  & {r,s} <: dom(RailML3_IL_ROUTE_ENTRY) & {r,s} <: dom(RailML3_IL_ROUTE_EXIT) & r /= s
            & {prj2(RailML3_IL_ROUTE_ENTRY(s)) |-> prj2(RailML3_IL_ROUTE_EXIT(r)), prj2(RailML3_IL_ROUTE_ENTRY(r)) |-> prj2(RailML3_IL_ROUTE_EXIT(r))} <: railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1
            & rtbl = (RailML3_IL_ROUTE_BLOCKS~)[{s}] \ {prj2(RailML3_IL_ROUTE_ENTRY(s)),prj2(RailML3_IL_ROUTE_EXIT(s))}
            & ( prj2(RailML3_IL_ROUTE_ENTRY(r)) : rtbl or  prj2(RailML3_IL_ROUTE_EXIT(r)) : rtbl )
        ERROR_TYPE 2
        COUNTEREXAMPLE
            STRING_FORMAT("[Lines {~w,~w}, ids {'~w','~w'}]: Routes are overlapping", e_r'xmlLineNumber, e_s'xmlLineNumber, r, s)
        END;
        RULE_FAIL e_r, i_r, i_tvd
            WHEN e_r : RailML3_route & i_r = MU_WD(e_r'Id) & i_tvd : e_r'hasTvdSections & i_tvd /: { i | i : dom(RailML3_IL_TVD_SECTIONS) & RailML3_IL_TVD_SECTIONS(i) /\ RailML3_IL_ROUTE_NXT(i_r) /= {} }
        ERROR_TYPE 2
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: TvdSection '~w' is declared as part of the route, but this could not be inferred from the route (possibly it is a section that should be defined as an overlap)", e_r'xmlLineNumber, i_r, i_tvd)
        END
    END;
    // END ROUTES

    // BEGIN SIGNALS_IL
    COMPUTATION set_signalsIL
    DEPENDS_ON_RULE is_valid_assetsForInterlocking
    BODY
        DEFINE RailML3_signalsIL
            TYPE FIN(RailML3_IL_generic_Type)
            VALUE genericILType("signalsIL")
        END
    END;
    RULE is_valid_signalsIL
    DEPENDS_ON_COMPUTATION set_signalsIL
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_signalsIL) & c /: 0..card(RailML3_assetsForInterlocking) // (0..1), 0 if no assetsForInterlocking
        COUNTEREXAMPLE
            IF card(RailML3_assetsForInterlocking) > 0 
                THEN errorCard("signalsIL", RailML3_assetsForInterlocking, 0, 1, c)
                ELSE errorCard("signalsIL", RailML3_assetsForInterlocking, 0, 0, c)
            END
        END;
        RULE_FAIL e
        WHEN
            e : RailML3_signalsIL & !e_ass.(e_ass : RailML3_assetsForInterlocking => e'pId /= e_ass'recId)
        COUNTEREXAMPLE
            errorParent("signalsIL", "assetsForInterlocking", e'xmlLineNumber)
        END
    END;

    COMPUTATION set_signalIL
    DEPENDS_ON_RULE is_valid_signalsIL
    DEPENDS_ON_COMPUTATION set_SIGNAL
    BODY
        DEFINE RailML3_signalIL
            TYPE FIN(RailML3_IL_signalIL_Type)
            VALUE dom({e, e_sig | e_sig : elementsOfType("signalIL")
                & e = rec(
                        recId: e_sig'recId,
                        pId: e_sig'pId,
                        xmlLineNumber: STRING_TO_INT(e_sig'meta("xmlLineNumber")),
                        Id: e_sig'attributes[{"id"}],
                        releaseSpeed: IF "releaseSpeed" : dom(e_sig'attributes) THEN {STRING_TO_REAL(e_sig'attributes("releaseSpeed"))} ELSE {} END,
                        malfunctionSpeed: IF "malfunctionSpeed" : dom(e_sig'attributes) THEN {STRING_TO_REAL(e_sig'attributes("malfunctionSpeed"))} ELSE {} END,
                        approachSpeed: IF "approachSpeed" : dom(e_sig'attributes) THEN {STRING_TO_REAL(e_sig'attributes("approachSpeed"))} ELSE {} END,
                        passingSpeed: IF "passingSpeed" : dom(e_sig'attributes) THEN {STRING_TO_REAL(e_sig'attributes("passingSpeed"))} ELSE {} END,
                        function: IF "function" : dom(e_sig'attributes) THEN {TYPED_STRING_TO_ENUM(RailML3_IL_SIGNAL_FUNCTION_TYPES, "function_"^e_sig'attributes("function"))} ELSE {} END,
                        isNotWired: 
                            IF version = {v3_2} & "isNotWired" : dom(e_sig'attributes) & e_sig'attributes("isNotWired") = "true" THEN TRUE
                            ELSIF version = {v3_1} & "isVirtual" : dom(e_sig'attributes) & e_sig'attributes("isVirtual") = "true" THEN TRUE
                            ELSE FALSE END,                        
                        refersTo: dom({ i_A, e_A | e_A : childsOfElementType( "refersTo", e_sig'recId) & i_A : e_A'attributes[{"ref"}] })
                    ) })
        END
    END;
    RULE is_valid_signalIL
    DEPENDS_ON_COMPUTATION set_signalIL
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_signalIL) & IF card(RailML3_signalsIL) = 1 THEN c = 0 ELSE c /= 0 END // (1..*), 0 if no signalsIL
        COUNTEREXAMPLE
            IF card(RailML3_signalsIL) = 1 
                THEN errorCardOnlyLowerBound("signalIL", RailML3_signalsIL, 1, c)
                ELSE errorCard("signalIL", RailML3_signalIL, 0, 0, c)
            END
        END;
        RULE_FAIL e
            WHEN e : RailML3_signalIL & (card(e'Id) /= 1 or (card(e'Id) = 1 & MU_WD(e'Id) = ""))
        COUNTEREXAMPLE
            errorAttribute("id", "signalIL", e'xmlLineNumber)
        END;
        RULE_FAIL e_sig, c
            WHEN e_sig : RailML3_signalIL & c = card(e_sig'refersTo) & c /: 0..1
        COUNTEREXAMPLE
            errorCard("refersTo", {e_sig}, 0, 1, c)
        END;
        RULE_FAIL e_sig, e_data
            WHEN e_sig : RailML3_signalIL & e_data : childsOfElementType("refersTo", e_sig'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "refersTo", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_sig
            WHEN e_sig : RailML3_signalIL & card(e_sig'refersTo) = 1 & MU_WD(e_sig'refersTo) /: allIdsOfType("signalIS")
        COUNTEREXAMPLE
            errorReference("refersTo", MU_WD(e_sig'refersTo), "signalIS", e_sig'xmlLineNumber)
        END;
        RULE_FORALL e
            WHERE e : RailML3_signalIL & card(RailML3_signalsIL) = 1
            EXPECT e'pId = MU_WD(RailML3_signalsIL)'recId
        COUNTEREXAMPLE
            errorParent("signalIL", "signalsIL", e'xmlLineNumber)
        END
    END;

    COMPUTATION set_IL_SIGNAL
    DEPENDS_ON_RULE is_valid_signalIL
    BODY
        DEFINE RailML3_IL_SIGNAL_REFERS_TO
            TYPE allIdsOfType("signalIL") >-> allIdsOfType("signalIS") // total injection - some signals do not have interlocking objects (unclear if this is correct?)
            VALUE { i_sig_il, i_sig | #e_sig_il.(e_sig_il : RailML3_signalIL & i_sig_il = MU_WD(e_sig_il'Id) & i_sig : e_sig_il'refersTo ) }
        END;
        DEFINE RailML3_IL_SIGNAL_CONTROLLED
            TYPE FIN(allIdsOfType("signalIS"))
            VALUE dom({ i_sig, i_sig_il | i_sig : allIdsOfType("signalIS") & i_sig = RailML3_IL_SIGNAL_REFERS_TO(i_sig_il) })
        END;
        DEFINE RailML3_IL_SIGNAL_END_OF_CONTROL_SECTION
            TYPE RailML3_IL_SIGNAL_CONTROLLED --> FIN(allIdsOfType("bufferStop") \/ RailML3_IL_SIGNAL_CONTROLLED \/ RailML3_IS_OPENEND_IDS)
            VALUE %i_sig.( i_sig : RailML3_IL_SIGNAL_CONTROLLED |
                    { eocs | #(sloc_sig, sloc_eocs).(eocs : allIdsOfType("bufferStop") \/ RailML3_IL_SIGNAL_CONTROLLED \/ RailML3_IS_OPENEND_IDS & sloc_eocs : RailML3_IS_SPOT_LOCATIONS(eocs)
                        & sloc_sig : RailML3_IS_SPOT_LOCATIONS(i_sig)
                        & sloc_sig |-> sloc_eocs : railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1
                        & sloc_sig |-> sloc_eocs : closure1(union(RailML3_IS_SPOT_LOCATIONS[RailML3_IL_SIGNAL_CONTROLLED - {i_sig}]) <<| (railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1~[{sloc_eocs}] <| RailML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS |> railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1[{sloc_sig}]))
                    )}
                )
        END;
        DEFINE RailML3_IL_SIGNAL_CONTROL_SECTIONS
            TYPE RailML3_IL_SIGNAL_CONTROLLED --> ((allIdsOfType("bufferStop") \/ RailML3_IL_SIGNAL_CONTROLLED \/ RailML3_IS_OPENEND_IDS) +-> ((allIdsOfType("netElement") * REAL * RailML3_IS_DIRECTION) <-> (allIdsOfType("netElement") * REAL * RailML3_IS_DIRECTION)) )
            VALUE %i_sig.( i_sig : RailML3_IL_SIGNAL_CONTROLLED |
                    %sig_exit.(sig_exit : RailML3_IL_SIGNAL_END_OF_CONTROL_SECTION(i_sig) |
                        { nxt | #(sloc_entry, sloc_exit).(
                            sloc_entry : RailML3_IS_SPOT_LOCATIONS(i_sig)
                            & sig_exit : RailML3_IL_SIGNAL_END_OF_CONTROL_SECTION(i_sig)
                            & sloc_exit : RailML3_IS_SPOT_LOCATIONS(sig_exit)
                            & sloc_entry |-> sloc_exit : railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1
                            & LET NXT BE NXT = railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1~[{sloc_exit}] <| RailML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS |> railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1[{sloc_entry}]
                            IN {sloc_entry |-> prj1(nxt), prj2(nxt) |-> sloc_exit} <: closure1(union(RailML3_IS_SPOT_LOCATIONS[RailML3_IL_SIGNAL_CONTROLLED - {i_sig}]) <<| NXT)
                            & nxt : NXT END
                        )}
                    )
                )
        END;
        DEFINE RailML3_IL_SIGNAL_CONTROL_TVD_SECTIONS
            TYPE RailML3_IL_SIGNAL_CONTROLLED --> (( allIdsOfType("bufferStop") \/ RailML3_IL_SIGNAL_CONTROLLED \/ RailML3_IS_OPENEND_IDS) +-> FIN(allIdsOfType("tvdSection")) )
            VALUE %i_sig.(i_sig : RailML3_IL_SIGNAL_CONTROLLED |
                    %sig_exit.(sig_exit : RailML3_IL_SIGNAL_END_OF_CONTROL_SECTION(i_sig) |
                        // tvdSections completely included of the controlled path
                        { i_tvd | i_tvd : allIdsOfType("tvdSection") & RailML3_IL_TVD_SECTIONS(i_tvd) <: RailML3_IL_SIGNAL_CONTROL_SECTIONS(i_sig)(sig_exit) }
                        \/
                        // tvdSection containing the exit signal of the controlled path (overlapping entry section is usually occupied by requesting train) 
                        dom({ i_tvd, sig_sloc | i_tvd : allIdsOfType("tvdSection")
                            & sig_sloc : RailML3_IS_SPOT_LOCATIONS(sig_exit) & sig_sloc : dom(RailML3_IL_TVD_SECTIONS(i_tvd)) \/ ran(RailML3_IL_TVD_SECTIONS(i_tvd))
                            & !sig_entry_sloc.(sig_entry_sloc : RailML3_IS_SPOT_LOCATIONS(i_sig) => sig_entry_sloc /: dom(RailML3_IL_TVD_SECTIONS(i_tvd)) \/ ran(RailML3_IL_TVD_SECTIONS(i_tvd)) )
                        })
                    )
                )
        END
    END;

    RULE validate_signalIL
    DEPENDS_ON_COMPUTATION set_IL_SIGNAL
    BODY
        RULE_FORALL e_sig, i_sig, i_sigs_exit
            WHERE e_sig : RailML3_signalIL & i_sig = MU_WD(e_sig'Id) & i_sig : RailML3_IL_SIGNAL_CONTROLLED & i_sigs_exit = RailML3_IL_SIGNAL_END_OF_CONTROL_SECTION(i_sig)
            EXPECT dom(RailML3_IL_SIGNAL_CONTROL_SECTIONS(i_sig)) = i_sigs_exit & dom(RailML3_IL_SIGNAL_CONTROL_TVD_SECTIONS(i_sig)) = i_sigs_exit
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: Signal: Possible ends of its corresponding control section are inferred as ~w, but control section paths or tvdSections could not be correctly inferred", e_sig'xmlLineNumber, i_sig, i_sigs_exit)
        END
    END;
    // END SIGNALS_IL

    // BEGIN SWITCHES
    COMPUTATION set_switchesIL
    DEPENDS_ON_RULE is_valid_assetsForInterlocking
    BODY
        DEFINE RailML3_switchesIL
            TYPE FIN(RailML3_IL_generic_Type)
            VALUE genericILType("switchesIL")
        END
    END;
    RULE is_valid_switchesIL
    DEPENDS_ON_COMPUTATION set_switchesIL
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_switchesIL) & c /: 0..card(RailML3_assetsForInterlocking) // (0..1), 0 if no assetsForInterlocking
        COUNTEREXAMPLE
            IF card(RailML3_assetsForInterlocking) > 0 
                THEN errorCard("switchesIL", RailML3_assetsForInterlocking, 0, 1, c)
                ELSE errorCard("switchesIL", RailML3_assetsForInterlocking, 0, 0, c)
            END
        END;
        RULE_FAIL e
        WHEN
            e : RailML3_switchesIL & !e_ass.(e_ass : RailML3_assetsForInterlocking => e'pId /= e_ass'recId)
        COUNTEREXAMPLE
            errorParent("switchesIL", "assetsForInterlocking", e'xmlLineNumber)
        END
    END;

    COMPUTATION set_switchIL
    DEPENDS_ON_RULE is_valid_switchesIL
    DEPENDS_ON_COMPUTATION set_NET_ELEMENT, set_SWITCH, set_TRACK
    BODY
        DEFINE RailML3_switchIL
            TYPE FIN(RailML3_IL_switchIL_Type)
            VALUE dom({e, e_sw | e_sw : elementsOfType("switchIL")
                & e = rec(
                        recId: e_sw'recId,
                        pId: e_sw'pId,
                        xmlLineNumber: STRING_TO_INT(e_sw'meta("xmlLineNumber")),
                        Id: e_sw'attributes[{"id"}],
                        preferredPosition: IF "preferredPosition" : dom(e_sw'attributes) THEN {TYPED_STRING_TO_ENUM(RailML3_IL_SWITCH_POSITIONS, "position_"^e_sw'attributes("preferredPosition"))} ELSE {} END,
                        returnsToPreferredPosition : IF "returnsToPreferredPosition" : dom(e_sw'attributes) & e_sw'attributes("returnsToPreferredPosition") = "true" THEN TRUE ELSE FALSE END,
                        isKeyLocked : IF "isKeyLocked" : dom(e_sw'attributes) & e_sw'attributes("isKeyLocked") = "true" THEN TRUE ELSE FALSE END,
                        maxThrowTime : IF "maxThrowTime" : dom(e_sw'attributes) THEN readDuration(e_sw'attributes("maxThrowTime")) ELSIF "typicalThrowTime" : dom(e_sw'attributes) THEN readDuration(e_sw'attributes("typicalThrowTime")) + 1000 ELSE 2000 END,
                        typicalThrowTime : IF "typicalThrowTime" : dom(e_sw'attributes) THEN readDuration(e_sw'attributes("typicalThrowTime")) ELSIF "maxThrowTime" : dom(e_sw'attributes) THEN min({readDuration(e_sw'attributes("maxThrowTime")) - 1000, 1000}) ELSE 1000 END,
                        refersTo: dom({ i_A, e_A | e_A : childsOfElementType( "refersTo", e_sw'recId) & i_A : e_A'attributes[{"ref"}] }),
                        branchLeft: dom({ i_A, e_A | e_A : childsOfElementType( "branchLeft", e_sw'recId) & i_A : e_A'attributes[{"ref"}] }),
                        branchRight: dom({ i_A, e_A | e_A : childsOfElementType( "branchRight", e_sw'recId) & i_A : e_A'attributes[{"ref"}] }),
                        branchTip: dom({ i_A, e_A | e_A : childsOfElementType( "branchTip", e_sw'recId) & i_A : e_A'attributes[{"ref"}] }),
                        hasGaugeClearanceMarkers: dom({ i_A, e_A | e_A : childsOfElementType( "hasGaugeClearanceMarker", e_sw'recId) & i_A : e_A'attributes[{"ref"}] }),
                        hasFoulingTrainDetectors: dom({ i_A, e_A | e_A : childsOfElementType( "hasFoulingTrainDetector", e_sw'recId) & i_A : e_A'attributes[{"ref"}] }),
                        hasTvdSection: dom({ i_A, e_A | e_A : childsOfElementType( "hasTvdSection", e_sw'recId) & i_A : e_A'attributes[{"ref"}] }),
                        relatedMovableElement: dom({ i_A, e_A | e_A : childsOfElementType( "relatedMovableElement", e_sw'recId) & i_A : e_A'attributes[{"ref"}] }),
                        hasPositionRestriction:
                            dom({ i_A, e_A | e_A : childsOfElementType( "hasPositionRestriction", e_sw'recId)
                                & i_A = rec(
                                    xmlLineNumber : STRING_TO_INT(e_A'meta("xmlLineNumber")),
                                    restrictedPosition : IF "restrictedPosition" : dom(e_A'attributes) THEN {TYPED_STRING_TO_ENUM(RailML3_IL_SWITCH_POSITIONS, "position_"^e_A'attributes("restrictedPosition"))} ELSE {} END,
                                    relatedDerailerInPosition :
                                        dom({ a, c | c : childsOfElementType( "relatedDerailerInPosition", e_A'recId)
                                            & #c2.(c2 : childsOfElementType( "refersToDerailer", c'recId)
                                            & a = rec(
                                                xmlLineNumber : STRING_TO_INT(c'meta("xmlLineNumber")),
                                                refersToDerailer : c2'attributes[{"ref"}],
                                                inPosition : IF "inPosition" : dom(c'attributes) THEN {TYPED_STRING_TO_ENUM(RailML3_IL_DERAILER_POSITIONS, "position_"^c'attributes("inPosition"))} ELSE {} END,
                                                isNegated: IF "isNegated" : dom(c'attributes) & c'attributes("isNegated") = "true" THEN TRUE ELSE FALSE END
                                        ))}),
                                    relatedSwitchInPosition :
                                        dom({ a, c | c : childsOfElementType( "relatedSwitchInPosition", e_A'recId)
                                            & #c2.(c2 : childsOfElementType( "refersToSwitch", c'recId)
                                            & a = rec(
                                                xmlLineNumber : STRING_TO_INT(c'meta("xmlLineNumber")),
                                                refersToSwitch : c2'attributes[{"ref"}],
                                                inPosition : IF "inPosition" : dom(c'attributes) THEN {TYPED_STRING_TO_ENUM(RailML3_IL_SWITCH_POSITIONS, "position_"^c'attributes("inPosition"))} ELSE {} END,
                                                isNegated: IF "isNegated" : dom(c'attributes) & c'attributes("isNegated") = "true" THEN TRUE ELSE FALSE END
                                        ))})
                                )
                            })
                    ) })
        END
    END;
    RULE is_valid_switchIL
    DEPENDS_ON_COMPUTATION set_switchIL
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_switchIL) & IF card(RailML3_switchesIL) = 1 THEN c = 0 ELSE c /= 0 END // (1..*), 0 if no switchesIL
        COUNTEREXAMPLE
            IF card(RailML3_switchesIL) = 1 
                THEN errorCardOnlyLowerBound("switchIL", RailML3_switchesIL, 1, c)
                ELSE errorCard("switchIL", RailML3_switchIL, 0, 0, c)
            END
        END;
        RULE_FAIL e
            WHEN e : RailML3_switchIL & (card(e'Id) /= 1 or (card(e'Id) = 1 & MU_WD(e'Id) = ""))
        COUNTEREXAMPLE
            errorAttribute("id", "switchIL", e'xmlLineNumber)
        END;
        RULE_FAIL e_sw, c
            WHEN e_sw : RailML3_switchIL & c = card(e_sw'refersTo) & c /: 1..2
        COUNTEREXAMPLE
            errorCard("refersTo", {e_sw}, 1, 2, c)
        END;
        RULE_FAIL e_sw, e_data
            WHEN e_sw : RailML3_switchIL & e_data : childsOfElementType("refersTo", e_sw'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "refersTo", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_sw
            WHEN e_sw : RailML3_switchIL & card(e_sw'refersTo) = 1 & MU_WD(e_sw'refersTo) /: union(allIdsOfType[{"crossing","switchIS"}]) // crossing for RailOscope
        COUNTEREXAMPLE
            errorReference("refersTo", MU_WD(e_sw'refersTo), "switchIS", e_sw'xmlLineNumber)
        END;
        RULE_FAIL e_sw, c
            WHEN e_sw : RailML3_switchIL & c = card(e_sw'branchLeft) & c /= 1
        COUNTEREXAMPLE
            errorCard("branchLeft", {e_sw}, 1, 1, c)
        END;
        RULE_FAIL e_sw, e_data
            WHEN e_sw : RailML3_switchIL & e_data : childsOfElementType("branchLeft", e_sw'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "branchLeft", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_sw, c
            WHEN e_sw : RailML3_switchIL & c = card(e_sw'branchRight) & c /= 1
        COUNTEREXAMPLE
            errorCard("branchRight", {e_sw}, 1, 1, c)
        END;
        RULE_FAIL e_sw, e_data
            WHEN e_sw : RailML3_switchIL & e_data : childsOfElementType("branchRight", e_sw'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "branchRight", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_sw, e_data
            WHEN e_sw : RailML3_switchIL & e_data : childsOfElementType("branchTip", e_sw'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "branchTip", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_sw, c
            WHEN e_sw : RailML3_switchIL & c = card(e_sw'hasGaugeClearanceMarkers) & c > 2
        COUNTEREXAMPLE
            errorCard("hasGaugeClearanceMarker", {e_sw}, 0, 2, c)
        END;
        RULE_FAIL e_sw, e_data
            WHEN e_sw : RailML3_switchIL & e_data : childsOfElementType("hasGaugeClearanceMarker", e_sw'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "hasGaugeClearanceMarker", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_sw, e_tde, i_tde, type
            WHEN e_sw : RailML3_switchIL & i_tde : e_sw'hasGaugeClearanceMarkers & e_tde : RailML3_trainDetectionElement & i_tde = MU_WD(e_tde'Id) & type : e_tde'type & type /= trainDetectionElement_clearancePoint 
        COUNTEREXAMPLE
           errorValue("hasGaugeClearanceMarker", "clearancePoint", STRING_SPLIT(TO_STRING(type), "_")(2), e_sw'xmlLineNumber)
        END;
        RULE_FAIL e_sw, e_data
            WHEN e_sw : RailML3_switchIL & e_data : childsOfElementType("hasFoulingTrainDetector", e_sw'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "hasFoulingTrainDetector", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_sw, c
            WHEN e_sw : RailML3_switchIL & c = card(e_sw'hasTvdSection) & c > 1
        COUNTEREXAMPLE
            errorCard("hasTvdSection", {e_sw}, 0, 1, c)
        END;
        RULE_FAIL e_sw, e_data
            WHEN e_sw : RailML3_switchIL & e_data : childsOfElementType("hasTvdSection", e_sw'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "hasTvdSection", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_sw, c
            WHEN e_sw : RailML3_switchIL & c = card(e_sw'relatedMovableElement) & c > 1
        COUNTEREXAMPLE
            errorCard("relatedMovableElement", {e_sw}, 0, 1, c)
        END;
        RULE_FAIL e_sw, e_data
            WHEN e_sw : RailML3_switchIL & e_data : childsOfElementType("relatedMovableElement", e_sw'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "relatedMovableElement", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_sw, c
            WHEN e_sw : RailML3_switchIL & c = card(e_sw'hasPositionRestriction) & c > 1
        COUNTEREXAMPLE
            errorCard("hasPositionRestriction", {e_sw}, 0, 1, c)
        END;
        RULE_FAIL e_pr, c
            WHEN #e_sw.(e_sw : RailML3_switchIL & e_pr : e_sw'hasPositionRestriction & c = card(e_pr'restrictedPosition) & c /= 1)
        COUNTEREXAMPLE
            errorAttribute("restrictedPosition", "hasPositionRestriction", e_pr'xmlLineNumber)
        END;
        RULE_FAIL e_pr, c
            WHEN #e_sw.(e_sw : RailML3_switchIL & e_pr : e_sw'hasPositionRestriction & c = card(e_pr'relatedDerailerInPosition) & c > 1)
        COUNTEREXAMPLE
            errorCard("relatedDerailerInPosition", {e_pr}, 0, 1, c)
        END;
        RULE_FAIL e_pr, c
            WHEN #e_sw.(e_sw : RailML3_switchIL & e_pr : e_sw'hasPositionRestriction & c = card(e_pr'relatedSwitchInPosition) & c > 1)
        COUNTEREXAMPLE
            errorCard("relatedSwitchInPosition", {e_pr}, 0, 1, c)
        END;
        RULE_FAIL e_rdp, c
            WHEN #(e_sw, e_pr).(e_sw : RailML3_switchIL & e_pr : e_sw'hasPositionRestriction & e_rdp : e_pr'relatedDerailerInPosition & c = card(e_rdp'inPosition) & c /= 1)
        COUNTEREXAMPLE
            errorAttribute("inPosition", "relatedDerailerInPosition", e_rdp'xmlLineNumber)
        END;
        RULE_FAIL e_sw, e_pr, e_rdp, c
            WHEN e_sw : RailML3_switchIL & e_pr : e_sw'hasPositionRestriction & e_rdp : e_pr'relatedDerailerInPosition & c = card(e_rdp'refersToDerailer) & c /= 1
        COUNTEREXAMPLE
            errorCard("refersToDerailer", {e_rdp}, 1, 1, c)
        END;
        RULE_FAIL e_sw, e_pr, e_rdp
            WHEN e_sw : RailML3_switchIL & e_pr : e_sw'hasPositionRestriction & e_rdp : e_pr'relatedDerailerInPosition & card(e_rdp'refersToDerailer) = 1 & MU_WD(e_rdp'refersToDerailer) /: allIdsOfType("derailerIL")
        COUNTEREXAMPLE
            errorReference("refersToDerailer", MU_WD(e_rdp'refersToDerailer), "derailerIL", e_rdp'xmlLineNumber)
        END;
        RULE_FAIL e_rsp, c
            WHEN #(e_sw, e_pr).(e_sw : RailML3_switchIL & e_pr : e_sw'hasPositionRestriction & e_rsp : e_pr'relatedSwitchInPosition & c = card(e_rsp'inPosition) & c /= 1)
        COUNTEREXAMPLE
            errorAttribute("inPosition", "relatedDerailerInPosition", e_rsp'xmlLineNumber)
        END;
        RULE_FAIL e_sw, e_pr, e_rsp, c
            WHEN e_sw : RailML3_switchIL & e_pr : e_sw'hasPositionRestriction & e_rsp : e_pr'relatedSwitchInPosition & c = card(e_rsp'refersToSwitch) & c /= 1
        COUNTEREXAMPLE
            errorCard("refersToSwitch", {e_rsp}, 1, 1, c)
        END;
        RULE_FAIL e_sw, e_pr, e_rsp
            WHEN e_sw : RailML3_switchIL & e_pr : e_sw'hasPositionRestriction & e_rsp : e_pr'relatedSwitchInPosition & card(e_rsp'refersToSwitch) = 1 & MU_WD(e_rsp'refersToSwitch) /: allIdsOfType("switchIL")
        COUNTEREXAMPLE
            errorReference("refersToSwitch", MU_WD(e_rsp'refersToSwitch), "switchIL", e_rsp'xmlLineNumber)
        END;
        RULE_FORALL e
            WHERE e : RailML3_switchIL & card(RailML3_switchesIL) = 1
            EXPECT e'pId = MU_WD(RailML3_switchesIL)'recId
        COUNTEREXAMPLE
            errorParent("switchIL", "switchesIL", e'xmlLineNumber)
        END
    END;

    COMPUTATION set_IL_SWITCH
    DEPENDS_ON_RULE is_valid_movableCrossing, is_valid_derailerIL, is_valid_switchIL
    DEPENDS_ON_COMPUTATION set_NET_RELATION, set_NET_ELEMENT, set_SWITCH, set_TRACK
    BODY
        DEFINE RailML3_IL_SWITCH_REFERS_TO
            TYPE allIdsOfType("switchIL") --> (allIdsOfType("crossing") \/ RailML3_IS_SWITCH_IDS) // total function - switch crossings can have multiple IL switches (no injection) and not all crossings have a switchIL (no surjection)
            VALUE { i_sw_il, i_sw | #e_sw_il.(e_sw_il : RailML3_switchIL & MU_WD(e_sw_il'Id) = i_sw_il & i_sw : e_sw_il'refersTo ) }
        END;
        DEFINE RailML3_IL_SWITCH_BRANCHES
            TYPE RailML3_IS_SWITCH_IDS --> ((allIdsOfType("switchIL") +-> RailML3_IL_SWITCH_POSITIONS) +-> ((allIdsOfType("netElement") * REAL * RailML3_IS_DIRECTION) <-> (allIdsOfType("netElement") * REAL * RailML3_IS_DIRECTION)))
            VALUE
                %i_sw.( i_sw : RailML3_IS_SWITCH_IDS |
                    %pos.( #permutations.(permutations = RailML3_IL_SWITCH_REFERS_TO~[{i_sw}] * RailML3_IL_SWITCH_POSITIONS
                        & pos <: permutations & pos /= {} & card(dom(pos)) = card(pos) & card(pos) = card(dom(permutations)) ) |

                            { b1,b2 | #(ne_start, ne_branch).(
                                b1 |-> b2 : RailML3_IS_SWITCH_BRANCHES(i_sw)
                                & (b1 |-> b2 = ne_start |-> ne_branch or b1 |-> b2 = ne_branch |-> ne_start)

                                & IF card(dom(pos)) = 2 THEN // for switch crossings
                                #(e1, i1, p1, e2, i2, p2, branch_right1, branch_left1, branch_right2, branch_left2).((i1, p1) : pos & (i2, p2) : pos
                                    & e1 : RailML3_switchIL & i_sw : e1'refersTo & i1 = MU_WD(e1'Id) & e2 : RailML3_switchIL & i_sw : e2'refersTo & i2 = MU_WD(e2'Id) & i1 /= i2
                                    & branch_right1 = MU_WD(e1'branchRight) & branch_left1 = MU_WD(e1'branchLeft) & branch_right2 = MU_WD(e2'branchRight) & branch_left2 = MU_WD(e2'branchLeft)
                                    & IF p1 = position_left & p2 = position_left THEN
                                        ne_start : IF branch_left1 : allIdsOfType("netElement") THEN {branch_left1} ELSE (RailML3_IS_TRACKS(branch_left1) \/ RailML3_IS_TRACKS(branch_left1)~)[{i_sw}] END *{0.0,1.0}*{direction_normal,direction_reverse}
                                        & ne_branch : IF branch_left2 : allIdsOfType("netElement") THEN {branch_left2} ELSE (RailML3_IS_TRACKS(branch_left2) \/ RailML3_IS_TRACKS(branch_left2)~)[{i_sw}] END *{0.0,1.0}*{direction_normal,direction_reverse}
                                    ELSE
                                        IF p1 = position_left & p2 = position_right THEN
                                            ne_start : IF branch_left1 : allIdsOfType("netElement") THEN {branch_left1} ELSE (RailML3_IS_TRACKS(branch_left1) \/ RailML3_IS_TRACKS(branch_left1)~)[{i_sw}] END *{0.0,1.0}*{direction_normal,direction_reverse}
                                            & ne_branch : IF branch_right2 : allIdsOfType("netElement") THEN {branch_right2} ELSE (RailML3_IS_TRACKS(branch_right2) \/ RailML3_IS_TRACKS(branch_right2)~)[{i_sw}] END *{0.0,1.0}*{direction_normal,direction_reverse}
                                        ELSE
                                            IF p1 = position_right & p2 = position_right THEN
                                                ne_start : IF branch_right1 : allIdsOfType("netElement") THEN {branch_right1} ELSE (RailML3_IS_TRACKS(branch_right1) \/ RailML3_IS_TRACKS(branch_right1)~)[{i_sw}] END *{0.0,1.0}*{direction_normal,direction_reverse}
                                                & ne_branch : IF branch_right2 : allIdsOfType("netElement") THEN {branch_right2} ELSE (RailML3_IS_TRACKS(branch_right2) \/ RailML3_IS_TRACKS(branch_right2)~)[{i_sw}] END *{0.0,1.0}*{direction_normal,direction_reverse}
                                            ELSE
                                                bfalse
                                            END
                                        END
                                    END )
                                ELSE // single switches
                                    IF card(dom(pos)) = 1 THEN
                                        #(e1, i1, p1, branch_right, branch_left).((i1, p1) : pos
                                            & e1 : RailML3_switchIL & i_sw : e1'refersTo & i1 = MU_WD(e1'Id) & branch_right = MU_WD(e1'branchRight) & branch_left = MU_WD(e1'branchLeft)
                                            & IF p1 = position_right THEN
                                                IF branch_right /: allIdsOfType("netElement") & card((RailML3_IS_TRACKS(branch_right) \/ RailML3_IS_TRACKS(branch_right)~)[{i_sw}]) = 2 THEN // switch tip track = branch track
                                                    ne_start |-> ne_branch : (RailML3_IS_TRACK_ASSOCIATED_NET_ELEMENTS(branch_right) \/ inverseDirectedRelation(RailML3_IS_TRACK_ASSOCIATED_NET_ELEMENTS(branch_right)))
                                                ELSE
                                                    btrue
                                                END
                                                & ( ne_start : IF branch_right : allIdsOfType("netElement") THEN {branch_right} ELSE (RailML3_IS_TRACKS(branch_right) \/ RailML3_IS_TRACKS(branch_right)~)[{i_sw}] END *{0.0,1.0}*{direction_normal,direction_reverse}
                                                    or ne_branch : IF branch_right : allIdsOfType("netElement") THEN {branch_right} ELSE (RailML3_IS_TRACKS(branch_right) \/ RailML3_IS_TRACKS(branch_right)~)[{i_sw}] END *{0.0,1.0}*{direction_normal,direction_reverse} )
                                            ELSE
                                                IF branch_left /: allIdsOfType("netElement") & card((RailML3_IS_TRACKS(branch_left) \/ RailML3_IS_TRACKS(branch_left)~)[{i_sw}]) = 2 THEN // switch tip track = branch track
                                                    ne_start |-> ne_branch : (RailML3_IS_TRACK_ASSOCIATED_NET_ELEMENTS(branch_left) \/ inverseDirectedRelation(RailML3_IS_TRACK_ASSOCIATED_NET_ELEMENTS(branch_left)))
                                                ELSE
                                                    btrue
                                                END
                                                & ( ne_start : IF branch_left : allIdsOfType("netElement") THEN {branch_left} ELSE (RailML3_IS_TRACKS(branch_left) \/ RailML3_IS_TRACKS(branch_left)~)[{i_sw}] END *{0.0,1.0}*{direction_normal,direction_reverse}
                                                    or ne_branch : IF branch_left : allIdsOfType("netElement") THEN {branch_left} ELSE (RailML3_IS_TRACKS(branch_left) \/ RailML3_IS_TRACKS(branch_left)~)[{i_sw}] END *{0.0,1.0}*{direction_normal,direction_reverse} )
                                            END
                                        )
                                    ELSE
                                        bfalse
                                    END
                                END
                            )}
                    )
                )
        END;
        DEFINE RailML3_IL_SWITCH_POSITION_RESTRICTIONS
            TYPE (allIdsOfType("switchIL") * RailML3_IL_SWITCH_POSITIONS) +-> struct(derailer: allIdsOfType("derailerIL") +-> RailML3_IL_DERAILER_POSITIONS, switch: allIdsOfType("switchIL") +-> RailML3_IL_SWITCH_POSITIONS)
            VALUE
                { i_sw, restr | #(e_sw, e_pr, rder_pos, rsw_pos, rder, rsw).(e_sw : RailML3_switchIL & i_sw = MU_WD(e_sw'Id) |-> MU_WD(e_pr'restrictedPosition)
                    & e_pr : e_sw'hasPositionRestriction
                    & IF card(e_pr'relatedDerailerInPosition) = 1 THEN
                        IF MU_WD(e_pr'relatedDerailerInPosition)'isNegated = FALSE THEN rder_pos = MU_WD(MU_WD(e_pr'relatedDerailerInPosition)'inPosition) ELSE rder_pos = negatedDerailerPosition(MU_WD(MU_WD(e_pr'relatedDerailerInPosition)'inPosition)) END
                        & rder = {MU_WD(MU_WD(e_pr'relatedDerailerInPosition)'refersToDerailer) |-> rder_pos}
                    ELSE
                        rder = {}
                    END
                    & IF card(e_pr'relatedSwitchInPosition) = 1 THEN
                        IF MU_WD(e_pr'relatedSwitchInPosition)'isNegated = FALSE THEN rsw_pos = MU_WD(MU_WD(e_pr'relatedSwitchInPosition)'inPosition) ELSE rsw_pos = negatedSwitchPosition(MU_WD(MU_WD(e_pr'relatedSwitchInPosition)'inPosition)) END
                        & rsw = {MU_WD(MU_WD(e_pr'relatedSwitchInPosition)'refersToSwitch) |-> rsw_pos}
                    ELSE
                        rsw = {}
                    END
                    & restr = rec( derailer: rder, switch: rsw )
                ) }
        END;
        DEFINE RailML3_IL_SWITCH_IS_KEY_LOCKED
            TYPE RailML3_IS_SWITCH_IDS --> BOOL
            VALUE { i_sw, ikl | i_sw : RailML3_IS_SWITCH_IDS & ikl = IF #e_sw.(e_sw : RailML3_switchIL & i_sw = MU_WD(e_sw'refersTo) & e_sw'isKeyLocked = TRUE) THEN TRUE ELSE FALSE END } 
        END;
        DEFINE RailML3_IL_SWITCH_PREFERRED_POSITION
            TYPE allIdsOfType("switchIL") +-> RailML3_IL_SWITCH_POSITIONS
            VALUE { i_sw, pref | i_sw : allIdsOfType("switchIL") & #e_sw.(e_sw : RailML3_switchIL & i_sw = MU_WD(e_sw'Id) & pref : e_sw'preferredPosition) } 
        END;
        DEFINE RailML3_IL_SWITCH_RETURNS_TO_PREFERRED_POSITION
            TYPE allIdsOfType("switchIL") --> BOOL
            VALUE { i_sw, ikl | i_sw : allIdsOfType("switchIL") & ikl = IF #e_sw.(e_sw : RailML3_switchIL & i_sw = MU_WD(e_sw'Id) & e_sw'returnsToPreferredPosition = TRUE) THEN TRUE ELSE FALSE END } 
        END;
        DEFINE RailML3_IL_SWITCH_HAS_TVD_SECTION
            TYPE RailML3_IS_SWITCH_IDS +-> FIN(allIdsOfType("tvdSection"))
            VALUE { i_sw, tvds | #e_sw.(e_sw : RailML3_switchIL & i_sw : e_sw'refersTo /\ RailML3_IS_SWITCH_IDS & tvds = e_sw'hasTvdSection & tvds /= {}) } 
        END;
        DEFINE RailML3_IL_SWITCH_HAS_FOOLING_TRAIN_DETECTORS
            TYPE RailML3_IS_SWITCH_IDS +-> FIN(allIdsOfType("trainDetectionElement"))
            VALUE { i_sw, ftd | #e_sw.(e_sw : RailML3_switchIL & i_sw : e_sw'refersTo /\ RailML3_IS_SWITCH_IDS & ftd = e_sw'hasFoulingTrainDetectors & ftd /= {}) } 
        END;
        DEFINE RailML3_IL_SWITCH_RELATED_MOVABLE_ELEMENT
            TYPE RailML3_IS_SWITCH_IDS +-> (RailML3_IS_MOVABLE_CROSSING_IDS \/ allIdsOfType("derailerIS") \/ RailML3_IS_SWITCH_IDS)
            VALUE 
                { i_sw, rme | #(e_sw, rme_il).(e_sw : RailML3_switchIL & i_sw = MU_WD(e_sw'refersTo) & i_sw : RailML3_IS_SWITCH_IDS & rme_il : e_sw'relatedMovableElement
                    & IF rme_il : allIdsOfType("movableCrossing") THEN rme : elementOfId(RailML3_movableCrossing, rme_il)'refersTo
                    ELSE IF rme_il : allIdsOfType("derailerIL") THEN rme : elementOfId(RailML3_derailerIL, rme_il)'refersTo
                        ELSE IF rme_il : allIdsOfType("switchIL") THEN rme : elementOfId(RailML3_switchIL, rme_il)'refersTo
                            ELSE bfalse END
                        END
                    END
                ) }
        END;
        DEFINE RailML3_IL_SWITCH_MAX_THROW_TIMES
            TYPE RailML3_IS_SWITCH_IDS --> NATURAL
            VALUE { i_sw, mtt | i_sw : RailML3_IS_SWITCH_IDS & card(RailML3_switchIL) /= 0 & mtt = min({ time | #e_sw.(e_sw : RailML3_switchIL & i_sw : e_sw'refersTo & time = e_sw'maxThrowTime) }) } 
        END;
        DEFINE RailML3_IL_SWITCH_TYPICAL_THROW_TIMES
            TYPE RailML3_IS_SWITCH_IDS --> NATURAL
            VALUE { i_sw, ttt | i_sw : RailML3_IS_SWITCH_IDS & card(RailML3_switchIL) /= 0 & ttt = max({ time | #e_sw.(e_sw : RailML3_switchIL & i_sw : e_sw'refersTo & time = e_sw'typicalThrowTime) }) } 
        END
    END;

    RULE validate_switchIL
    DEPENDS_ON_COMPUTATION set_IL_SWITCH
    BODY
        RULE_FAIL e_sw, i_sw
            WHEN e_sw : RailML3_switchIL & i_sw = MU_WD(e_sw'Id) & RailML3_IL_SWITCH_RETURNS_TO_PREFERRED_POSITION(i_sw) = TRUE & i_sw /: dom(RailML3_IL_SWITCH_PREFERRED_POSITION)
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: Switch should return to preferred position, but no preferred position is defined", e_sw'xmlLineNumber, i_sw)
        END;
        RULE_FORALL e_sw, i_sw, i_sw_is, branch
            WHERE e_sw : RailML3_switchIL & i_sw = MU_WD(e_sw'Id) & i_sw_is : e_sw'refersTo /\ RailML3_IS_SWITCH_IDS & i_sw_is : RailML3_IS_SWITCH_IDS & branch : union(ran(RailML3_IL_SWITCH_BRANCHES(i_sw_is)))
            EXPECT branch : RailML3_IS_SWITCH_BRANCHES(i_sw_is)
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: Switch branch (~w) is not defined on infrastructure side for referenced switch '~w'", e_sw'xmlLineNumber, i_sw, branch, i_sw_is)
        END;
        RULE_FORALL e_sw, i_sw, i_sw_is
            WHERE e_sw : RailML3_switchIL & i_sw = MU_WD(e_sw'Id) & i_sw_is : e_sw'refersTo /\ RailML3_IS_SWITCH_IDS & RailML3_IS_SWITCH_TYPE(i_sw_is) = switch_singleSwitchCrossing
            EXPECT #sw_pos.(sw_pos : dom(RailML3_IL_SWITCH_POSITION_RESTRICTIONS) & prj1(sw_pos) = i_sw & dom(RailML3_IL_SWITCH_POSITION_RESTRICTIONS(sw_pos)'switch) = RailML3_IL_SWITCH_REFERS_TO~[RailML3_IL_SWITCH_RELATED_MOVABLE_ELEMENT[{i_sw_is}]])
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: Switch of type singleSwitchCrossing must have a position restriction on its related interlocking switch to avoid ambiguity, but none or an invalid one (possibly not using correct related movable element) is defined", e_sw'xmlLineNumber, i_sw)
        END;
        RULE_FORALL e_sw, i_sw, i_sw_is, i_der
            WHERE e_sw : RailML3_switchIL & i_sw = MU_WD(e_sw'Id) & i_sw_is = MU_WD(e_sw'refersTo) & i_der : RailML3_IL_SWITCH_RELATED_MOVABLE_ELEMENT[{i_sw_is}] /\ allIdsOfType("derailerIS")
            EXPECT #sw_pos.(sw_pos : dom(RailML3_IL_SWITCH_POSITION_RESTRICTIONS) & prj1(sw_pos) = i_sw & dom(RailML3_IL_SWITCH_POSITION_RESTRICTIONS(sw_pos)'derailer) = RailML3_IL_DERAILER_REFERS_TO~[{i_der}])
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: Switch with relatedMovableElement '~w' of type derailer must have a position restriction on it, but none or an invalid one (possibly not using correct related movable element) is defined", e_sw'xmlLineNumber, i_sw, i_der)
        END
    END;
    RULE warnings_switchIL
    DEPENDS_ON_COMPUTATION set_IL_SWITCH
    ERROR_TYPES 2
    BODY
        RULE_FAIL e_sw, e_sw_imp
            WHEN e_sw : elementsOfType("switchIL") & "maxThrowTime" /: dom(e_sw'attributes) & e_sw_imp : RailML3_switchIL & MU_WD(e_sw_imp'Id) = e_sw'attributes("id")
        COUNTEREXAMPLE
            warningDefaultValue("maxThrowTime", TO_STRING(e_sw_imp'maxThrowTime), STRING_TO_INT(e_sw'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_sw, e_sw_imp
            WHEN e_sw : elementsOfType("switchIL") & "typicalThrowTime" /: dom(e_sw'attributes) & e_sw_imp : RailML3_switchIL & MU_WD(e_sw_imp'Id) = e_sw'attributes("id")
        COUNTEREXAMPLE
            warningDefaultValue("typicalThrowTime", TO_STRING(e_sw_imp'typicalThrowTime), STRING_TO_INT(e_sw'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_sw, i_sw, i_tvd
            WHEN e_sw : RailML3_switchIS & i_sw = MU_WD(e_sw'Id) & i_sw : RailML3_IS_SWITCH_IDS & i_tvd : union(RailML3_IL_SWITCH_HAS_TVD_SECTION[{i_sw}]) & RailML3_IL_TVD_SECTIONS(i_tvd) /\ RailML3_IS_SWITCH_BRANCHES(i_sw) = {}
        ERROR_TYPE 2
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: TvdSection '~w' is declared as related to the switch, but this could not be inferred from its branches", e_sw'xmlLineNumber, i_sw, i_tvd)
        END;
        RULE_FAIL e_sw
            WHEN e_sw : RailML3_switchIL & card(e_sw'refersTo) = 1 & MU_WD(e_sw'refersTo) : allIdsOfType("crossing")
        ERROR_TYPE 2
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: switchIL refersTo crossing '~w' and will be ignored", e_sw'xmlLineNumber, MU_WD(e_sw'Id), MU_WD(e_sw'refersTo))
        END/*;
        RULE_FAIL e_sw, i_sw, i_tde, sloc
            WHEN e_sw : RailML3_switchIS & i_sw = MU_WD(e_sw'Id) & i_sw : RailML3_IS_SWITCH_IDS & i_tde : union(RailML3_IL_SWITCH_HAS_FOOLING_TRAIN_DETECTORS[{i_sw}]) & sloc : RailML3_IS_SPOT_LOCATIONS(i_tde)
                & sloc /: dom(RailML3_IS_SWITCH_BRANCHES(i_sw)) \/ ran(RailML3_IS_SWITCH_BRANCHES(i_sw))
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: TrainDetectionElement '~w' is declared as foolingTrainDetector of the switch, but it is not located on one of its branches", e_sw'xmlLineNumber, i_sw, i_tde)
        END*/
    END;
    // END SWITCHES

    // BEGIN TVD_SECTIONS
    COMPUTATION set_tvdSections
    DEPENDS_ON_RULE is_valid_assetsForInterlocking
    BODY
        DEFINE RailML3_tvdSections
            TYPE FIN(RailML3_IL_generic_Type)
            VALUE genericILType("tvdSections")
        END
    END;
    RULE is_valid_tvdSections
    DEPENDS_ON_COMPUTATION set_tvdSections
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_tvdSections) & c /: 0..card(RailML3_assetsForInterlocking) // (0..1), 0 if no assetsForInterlocking
        COUNTEREXAMPLE
            IF card(RailML3_assetsForInterlocking) > 0 
                THEN errorCard("tvdSections", RailML3_assetsForInterlocking, 0, 1, c)
                ELSE errorCard("tvdSections", RailML3_assetsForInterlocking, 0, 0, c)
            END
        END;
        RULE_FAIL e
        WHEN
            e : RailML3_tvdSections & !e_ass.(e_ass : RailML3_assetsForInterlocking => e'pId /= e_ass'recId)
        COUNTEREXAMPLE
            errorParent("tvdSections", "assetsForInterlocking", e'xmlLineNumber)
        END
    END;

    COMPUTATION set_tvdSection
    DEPENDS_ON_RULE is_valid_tvdSections
    DEPENDS_ON_COMPUTATION set_BORDER
    BODY
        DEFINE RailML3_tvdSection
            TYPE FIN(RailML3_IL_tvdSection_Type)
            VALUE dom({e, e_tvd | e_tvd : elementsOfType("tvdSection")
                & e = rec(
                        recId: e_tvd'recId,
                        pId: e_tvd'pId,
                        xmlLineNumber: STRING_TO_INT(e_tvd'meta("xmlLineNumber")),
                        Id: e_tvd'attributes[{"id"}],
                        isBerthingTrack: IF "isBerthingTrack" : dom(e_tvd'attributes) & e_tvd'attributes("isBerthingTrack") = "true" THEN TRUE ELSE FALSE END,
                        technology: IF "technology" : dom(e_tvd'attributes) THEN {TYPED_STRING_TO_ENUM(RailML3_IL_TVD_SECTION_TECHNOLOGY_TYPES, "technology_"^e_tvd'attributes("technology"))} ELSE {} END,
                        hasDemarcatingBufferstops: dom({ i_A, e_A | e_A : childsOfElementType( "hasDemarcatingBufferstop", e_tvd'recId) & i_A : e_A'attributes[{"ref"}] }),
                        hasDemarcatingTraindetectors: dom({ i_A, e_A | e_A : childsOfElementType( "hasDemarcatingTraindetector", e_tvd'recId) & i_A : e_A'attributes[{"ref"}] })
                    ) })
        END
    END;
    RULE is_valid_tvdSection
    DEPENDS_ON_COMPUTATION set_tvdSection
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_tvdSection) & IF card(RailML3_tvdSections) = 1 THEN c = 0 ELSE c /= 0 END // (1..*), 0 if no tvdSections
        COUNTEREXAMPLE
            IF card(RailML3_tvdSections) = 1 
                THEN errorCardOnlyLowerBound("tvdSection", RailML3_tvdSections, 1, c)
                ELSE errorCard("tvdSection", RailML3_tvdSection, 0, 0, c)
            END
        END;
        RULE_FAIL e
            WHEN e : RailML3_tvdSection & (card(e'Id) /= 1 or (card(e'Id) = 1 & MU_WD(e'Id) = ""))
        COUNTEREXAMPLE
            errorAttribute("id", "tvdSection", e'xmlLineNumber)
        END;
        RULE_FAIL e_tvd, c
            WHEN e_tvd : RailML3_tvdSection & c = card(e_tvd'hasDemarcatingBufferstops) & c /: 0..2
        COUNTEREXAMPLE
            errorCard("hasDemarcatingBufferstop", {e_tvd}, 0, 2, c)
        END;
        RULE_FAIL e_tvd, e_data
            WHEN e_tvd : RailML3_tvdSection & e_data : childsOfElementType("hasDemarcatingBufferstop", e_tvd'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "hasDemarcatingBufferstop", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FAIL e_tvd, e_data
            WHEN e_tvd : RailML3_tvdSection & e_data : childsOfElementType("hasDemarcatingTraindetector", e_tvd'recId) & ("ref" /: dom(e_data'attributes) or "ref" |-> "" : e_data'attributes)
        COUNTEREXAMPLE
            errorAttribute("ref", "hasDemarcatingTraindetector", STRING_TO_INT(e_data'meta("xmlLineNumber")))
        END;
        RULE_FORALL e
            WHERE e : RailML3_tvdSection & card(RailML3_tvdSections) = 1
            EXPECT e'pId = MU_WD(RailML3_tvdSections)'recId
        COUNTEREXAMPLE
            errorParent("tvdSection", "tvdSections", e'xmlLineNumber)
        END
    END;

    COMPUTATION set_TVD_SECTIONS
    DEPENDS_ON_RULE is_valid_tvdSection
    DEPENDS_ON_COMPUTATION set_NET_ELEMENT, set_NET_RELATION, set_NET_RELATION_SUBSEQUENT_LOCATIONS, set_SPOT_LOCATION
    BODY
        DEFINE RailML3_IL_TVD_SECTIONS
            TYPE allIdsOfType("tvdSection") --> ((allIdsOfType("netElement") * REAL * RailML3_IS_DIRECTION) <-> (allIdsOfType("netElement") * REAL * RailML3_IS_DIRECTION))
            VALUE
                %i_tvd.(i_tvd : allIdsOfType("tvdSection") |
                    union({ r | #(e_tvd, i1, i2, ne_entry, ne_exit, openends).(
                        e_tvd : RailML3_tvdSection & i_tvd = MU_WD(e_tvd'Id)
                        & openends =
                            dom({ oe, sloc_oe | oe : RailML3_IS_OPENEND_IDS & sloc_oe : RailML3_IS_SPOT_LOCATIONS(oe)                        
                                & #(dme_start, sloc_dme_start).(
                                    dme_start : e_tvd'hasDemarcatingTraindetectors \/ e_tvd'hasDemarcatingBufferstops
                                    & sloc_dme_start : RailML3_IS_SPOT_LOCATIONS(dme_start)
                                    & sloc_dme_start |-> sloc_oe : railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1

                                    & IF (e_tvd'hasDemarcatingTraindetectors \/ e_tvd'hasDemarcatingBufferstops) - {dme_start} /= {} THEN
                                        #(dme_dir, sloc_dme_dir).(dme_dir : (e_tvd'hasDemarcatingTraindetectors \/ e_tvd'hasDemarcatingBufferstops) - {dme_start}
                                            & sloc_dme_dir : RailML3_IS_SPOT_LOCATIONS(dme_dir)
                                            & sloc_dme_start |-> sloc_dme_dir : railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1
                                        )
                                        or !(dme_dir, sloc_dme_dir).(dme_dir : (e_tvd'hasDemarcatingTraindetectors \/ e_tvd'hasDemarcatingBufferstops)
                                                & sloc_dme_dir : RailML3_IS_SPOT_LOCATIONS(dme_dir)
                                            => sloc_dme_dir |-> sloc_oe : railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1
                                        )
                                    ELSE btrue END
                                    & not( #(tde, sloc_tde).(tde : allIdsOfType("trainDetectionElement") & sloc_tde : RailML3_IS_SPOT_LOCATIONS(tde)
                                        & {sloc_dme_start |-> sloc_tde, sloc_tde |-> sloc_oe} <: railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1 ) 
                                    )
                                )
                            })
                        & i1 : e_tvd'hasDemarcatingTraindetectors \/ e_tvd'hasDemarcatingBufferstops \/ openends
                        & i2 : e_tvd'hasDemarcatingTraindetectors \/ e_tvd'hasDemarcatingBufferstops \/ openends
                        & i1 /= i2
                        & ne_entry : { ne, dir | #sloc.(sloc : RailML3_IS_SPOT_LOCATIONS(i1) & ne = prj1(sloc) & IF i1 /: allIdsOfType("trainDetectionElement") & prj2(prj1(sloc)) : {0.0,1.0} THEN dir : {direction_normal, direction_reverse} ELSE dir = prj2(sloc) END) }
                        & ne_exit : { ne, dir | #sloc.(sloc : RailML3_IS_SPOT_LOCATIONS(i2) & ne = prj1(sloc) & IF i2 /: allIdsOfType("trainDetectionElement") & prj2(prj1(sloc)) : {0.0,1.0} THEN dir : {direction_normal, direction_reverse} ELSE dir = prj2(sloc) END) }
                        & r = railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1~[{ne_exit}] <| RailML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS |> railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1[{ne_entry}]
                    ) })
                )
        END;
        DEFINE RailML3_IL_TVD_SECTION_BERTHING_TRACKS
            TYPE allIdsOfType("tvdSection") --> BOOL
            VALUE %i_tvd.(i_tvd : allIdsOfType("tvdSection") | elementOfId(RailML3_tvdSection, i_tvd)'isBerthingTrack )
        END;
        DEFINE RailML3_IL_TVD_SECTION_DEMARCATING_ELEMENTS
            TYPE allIdsOfType("tvdSection") --> FIN(allIdsOfType("bufferStop") \/ RailML3_IS_OPENEND_IDS \/ allIdsOfType("trainDetectionElement"))
            VALUE %i_tvd.(i_tvd : allIdsOfType("tvdSection") | elementOfId(RailML3_tvdSection, i_tvd)'hasDemarcatingBufferstops \/ elementOfId(RailML3_tvdSection, i_tvd)'hasDemarcatingTraindetectors )
        END
    END;
    
    RULE validate_tvdSection
    DEPENDS_ON_COMPUTATION set_TVD_SECTIONS
    BODY
        RULE_FAIL e_tvd
            WHEN e_tvd : RailML3_tvdSection & ( card(e_tvd'hasDemarcatingBufferstops \/ e_tvd'hasDemarcatingTraindetectors) = 0 or ( card(e_tvd'hasDemarcatingBufferstops) = 1 & card(e_tvd'hasDemarcatingTraindetectors) = 0 ) )
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: each tvdSection must have at least 1 demarcating train detector or at least 2 demarcating elements in case of mixed types or bufferstops only", e_tvd'xmlLineNumber, MU_WD(e_tvd'Id))
        END;
        RULE_FAIL e_tvd, i_tvd
            WHEN e_tvd : RailML3_tvdSection & i_tvd = MU_WD(e_tvd'Id) & RailML3_IL_TVD_SECTIONS(i_tvd) = {}
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: path of tvdSection could not be initialised - check that demarcating elements are correct or in case of a single TDE that it is directly connected to an openEnd without any intermediate TDEs", e_tvd'xmlLineNumber, i_tvd)
        END
    END;
    RULE warnings_tvdSection
    DEPENDS_ON_COMPUTATION set_TVD_SECTIONS
    ERROR_TYPES 2
    BODY
        RULE_FAIL WHEN bfalse COUNTEREXAMPLE "" END; // to implement error type 1
        RULE_FAIL e_tvd, i_tvd, i_oe
            WHEN e_tvd : RailML3_tvdSection & i_tvd = MU_WD(e_tvd'Id) & i_oe : RailML3_IS_OPENEND_IDS & i_oe /: e_tvd'hasDemarcatingBufferstops
                & #sloc.(sloc : RailML3_IS_SPOT_LOCATIONS(i_oe) & sloc : dom(RailML3_IL_TVD_SECTIONS(i_tvd)) \/ ran(RailML3_IL_TVD_SECTIONS(i_tvd)) )
        ERROR_TYPE 2
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: tvdSection has 1 demarcating element, second was inferred as openEnd with id '~w'", e_tvd'xmlLineNumber, i_tvd, i_oe)
        END;
        RULE_FAIL e_tvd, i_tvd, i_dem, sloc, nxt
            WHEN e_tvd : RailML3_tvdSection & i_tvd = MU_WD(e_tvd'Id) & i_dem : e_tvd'hasDemarcatingTraindetectors \/ e_tvd'hasDemarcatingBufferstops & sloc : RailML3_IS_SPOT_LOCATIONS(i_dem) & nxt = RailML3_IL_TVD_SECTIONS(i_tvd) 
                & sloc : dom(nxt) & sloc : ran(nxt)
        ERROR_TYPE 2
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: tvdSection is declared to have demarcating element '~w', but it is located within the section", e_tvd'xmlLineNumber, i_tvd, i_dem)
        END;
        RULE_FAIL i_tvd, e_ne, i_ne, all_tvd
            WHEN i_tvd : allIdsOfType("tvdSection") & e_ne : RailML3_netElement & i_ne = MU_WD(e_ne'Id) & i_ne : RailML3_IS_NET_RESOURCES_MICRO_LEVEL & all_tvd = union(ran(RailML3_IL_TVD_SECTIONS)) & i_ne /: dom(dom(dom(all_tvd) \/ ran(all_tvd)))
        ERROR_TYPE 2
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: netElement is not part of any tvdSection", e_ne'xmlLineNumber, i_ne)
        END;
        RULE_FAIL i_tvd1, i_tvd2
            WHEN {i_tvd1, i_tvd2} <: dom(RailML3_IL_TVD_SECTIONS) & i_tvd1 /= i_tvd2 & RailML3_IL_TVD_SECTIONS(i_tvd1) /\ RailML3_IL_TVD_SECTIONS(i_tvd2) /= {} & [i_tvd1, i_tvd2] = SORT({i_tvd1, i_tvd2}) // to avoid that each pair is returned twice
        ERROR_TYPE 2
        COUNTEREXAMPLE
            STRING_FORMAT("[ids {'~w','~w'}]: tvdSections are overlapping", i_tvd1, i_tvd2)
        END
    END;
    // END TVD_SECTIONS
    // END ASSETS_FOR_INTERLOCKINGS

    // BEGIN SIGNAL_BOXES
    COMPUTATION set_signalBoxes
    DEPENDS_ON_RULE is_valid_interlocking
    BODY
        DEFINE RailML3_signalBoxes
            TYPE FIN(RailML3_IL_generic_Type)
            VALUE genericILType("signalBoxes")
        END
    END;
    RULE is_valid_signalBoxes
    DEPENDS_ON_COMPUTATION set_signalBoxes
    BODY
        RULE_FAIL c
            WHEN c = card(RailML3_signalBoxes) & c /: 0..card(RailML3_interlocking) // (0..1), 0 if no interlocking
        COUNTEREXAMPLE 
            errorCard("signalBoxes", RailML3_signalBoxes, 0, card(RailML3_interlocking), c)
        END;
        RULE_FORALL e
            WHERE e : RailML3_signalBoxes & card(RailML3_interlocking) = 1
            EXPECT e'pId = MU_WD(RailML3_interlocking)'recId
        COUNTEREXAMPLE 
            errorParent("signalBoxes", "interlocking", e'xmlLineNumber)
        END
    END;

    COMPUTATION set_signalBox
    DEPENDS_ON_RULE is_valid_signalBoxes
    BODY
        DEFINE RailML3_signalBox
            TYPE FIN(RailML3_IL_signalBox_Type)
            VALUE dom({e, e_sb | e_sb : elementsOfType("signalBox")
                & e = rec(
                        recId: e_sb'recId,
                        pId: e_sb'pId,
                        xmlLineNumber: STRING_TO_INT(e_sb'meta("xmlLineNumber")),
                        Id: e_sb'attributes[{"id"}],
                        implementsSignalplans: dom({ a,c | c : childsOfElementType("implementsSignalplan", e_sb'recId)
                                & a = rec(
                                    xmlLineNumber : STRING_TO_INT(c'meta("xmlLineNumber")),
                                    aspectRelations : dom({ i_A, e_A | e_A : childsOfElementType( "aspectRelation", c'recId)
                                            & i_A = rec(
                                                xmlLineNumber : STRING_TO_INT(e_A'meta("xmlLineNumber")),
                                                Id : e_A'attributes[{"id"}],
                                                passingSpeed : IF "passingSpeed" : dom(e_A'attributes) & STRING_IS_NUMBER(e_A'attributes("passingSpeed")) THEN {STRING_TO_REAL(e_A'attributes("passingSpeed"))} ELSE {} END,
                                                expectingSpeed : IF "expectingSpeed" : dom(e_A'attributes) & STRING_IS_NUMBER(e_A'attributes("expectingSpeed")) THEN {STRING_TO_REAL(e_A'attributes("expectingSpeed"))} ELSE {} END,
                                                endSectionTime : IF "endSectionTime" : dom(e_A'attributes) THEN readDuration(e_A'attributes("endSectionTime")) ELSE 1000 END,
                                                appliesToRoutes : dom({ i_B, e_B | e_B : childsOfElementType("appliesToRoute", e_A'recId) & i_B : e_B'attributes[{"ref"}] }),
                                                distantAspects :
                                                    dom({ i_B, e_B | e_B : childsOfElementType("distantAspect", e_A'recId)
                                                        & i_B = rec(
                                                            xmlLineNumber : STRING_TO_INT(e_B'meta("xmlLineNumber")),
                                                            isNegated : IF "isNegated" : dom(e_B'attributes) & e_B'attributes("isNegated") = "true" THEN TRUE ELSE FALSE END,
                                                            refersToSignal : dom({ i_C, e_C | e_C : childsOfElementType( "refersToSignal", e_B'recId) & i_C : e_C'attributes[{"ref"}] }),
                                                            showsAspects : dom({ i_C, e_C | e_C : childsOfElementType( "showsAspect", e_B'recId) & i_C : e_C'attributes[{"ref"}] })
                                                        )
                                                    }),
                                                masterAspect :
                                                    dom({ i_B, e_B | e_B : childsOfElementType("masterAspect", e_A'recId)
                                                        & i_B = rec(
                                                            xmlLineNumber : STRING_TO_INT(e_B'meta("xmlLineNumber")),
                                                            isNegated : IF "isNegated" : dom(e_B'attributes) & e_B'attributes("isNegated") = "true" THEN TRUE ELSE FALSE END,
                                                            refersToSignal : dom({ i_C, e_C | e_C : childsOfElementType( "refersToSignal", e_B'recId) & i_C : e_C'attributes[{"ref"}] }),
                                                            showsAspects : dom({ i_C, e_C | e_C : childsOfElementType( "showsAspect", e_B'recId) & i_C : e_C'attributes[{"ref"}] })
                                                        )
                                                    }),
                                                slaveAspect :
                                                    dom({ i_B, e_B | e_B : childsOfElementType("slaveAspect", e_A'recId)
                                                        & i_B = rec(
                                                            xmlLineNumber : STRING_TO_INT(e_B'meta("xmlLineNumber")),
                                                            isNegated : IF "isNegated" : dom(e_B'attributes) & e_B'attributes("isNegated") = "true" THEN TRUE ELSE FALSE END,
                                                            refersToSignal : dom({ i_C, e_C | e_C : childsOfElementType( "refersToSignal", e_B'recId) & i_C : e_C'attributes[{"ref"}] }),
                                                            showsAspects : dom({ i_C, e_C | e_C : childsOfElementType( "showsAspect", e_B'recId) & i_C : e_C'attributes[{"ref"}] })
                                                        )
                                                    })
                                            )
                                        })
                                )
                            })
                    ) })
        END
    END;
    RULE is_valid_signalBox
    DEPENDS_ON_COMPUTATION set_signalBox
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_signalBox) & IF card(RailML3_signalBoxes) = 1 THEN c = 0 ELSE c /= 0 END // (1..*), 0 if no signalBoxes
        COUNTEREXAMPLE
            IF card(RailML3_signalBoxes) = 1 
                THEN errorCardOnlyLowerBound("signalBox", RailML3_signalBoxes, 1, c)
                ELSE errorCard("signalBox", RailML3_signalBox, 0, 0, c)
            END
        END;
        RULE_FAIL e
            WHEN e : RailML3_signalBox & (card(e'Id) /= 1 or (card(e'Id) = 1 & MU_WD(e'Id) = ""))
        COUNTEREXAMPLE
            errorAttribute("id", "signalBox", e'xmlLineNumber)
        END;
        RULE_FAIL e_sb, c
            WHEN e_sb : RailML3_signalBox & c = card(e_sb'implementsSignalplans) & c = 0
        COUNTEREXAMPLE
            errorCardOnlyLowerBound("implementsSignalplan", {e_sb}, 1, c)
        END;
        RULE_FAIL e_sb, e_isp, c
            WHEN e_sb : RailML3_signalBox & e_isp : e_sb'implementsSignalplans & c = card(e_isp'aspectRelations) & c = 0
        COUNTEREXAMPLE
            errorCardOnlyLowerBound("aspectRelation", {e_isp}, 1, c)
        END;
        RULE_FAIL e_sb, e_isp, e_asp_rel
            WHEN e_sb : RailML3_signalBox & e_isp : e_sb'implementsSignalplans & e_asp_rel : e_isp'aspectRelations & (card(e_asp_rel'Id) /= 1 or (card(e_asp_rel'Id) = 1 & MU_WD(e_asp_rel'Id) = ""))
        COUNTEREXAMPLE
            errorAttribute("id", "aspectRelation", e_asp_rel'xmlLineNumber)
        END;
        RULE_FAIL e_sb, e_isp, e_asp_rel, e_ds, c
            WHEN e_sb : RailML3_signalBox & e_isp : e_sb'implementsSignalplans & e_asp_rel : e_isp'aspectRelations & e_ds : e_asp_rel'distantAspects & c = card(e_ds'refersToSignal) & c /= 1
        COUNTEREXAMPLE
            errorCard("refersToSignal", {e_ds}, 1, 1, c)
        END;
        RULE_FAIL e_sb, e_isp, e_asp_rel, e_ds
            WHEN e_sb : RailML3_signalBox & e_isp : e_sb'implementsSignalplans & e_asp_rel : e_isp'aspectRelations & e_ds : e_asp_rel'distantAspects & card(e_ds'refersToSignal) = 1 & MU_WD(e_ds'refersToSignal) /: allIdsOfType("signalIL")
        COUNTEREXAMPLE
            errorReference("refersToSignal", MU_WD(e_ds'refersToSignal), "signalIL", e_ds'xmlLineNumber)
        END;
        RULE_FAIL e_sb, e_isp, e_asp_rel, e_ds, c
            WHEN e_sb : RailML3_signalBox & e_isp : e_sb'implementsSignalplans & e_asp_rel : e_isp'aspectRelations & e_ds : e_asp_rel'distantAspects & c = card(e_ds'showsAspects) & c = 0
        COUNTEREXAMPLE
            errorCardOnlyLowerBound("showsAspect", {e_ds}, 1, c)
        END;
        RULE_FAIL e_sb, e_isp, e_asp_rel, c
            WHEN e_sb : RailML3_signalBox & e_isp : e_sb'implementsSignalplans & e_asp_rel : e_isp'aspectRelations & c = card(e_asp_rel'masterAspect) & c > 1
        COUNTEREXAMPLE
            errorCard("masterAspect", {e_asp_rel}, 0, 1, c)
        END;
        RULE_FAIL e_sb, e_isp, e_asp_rel, e_ms, c
            WHEN e_sb : RailML3_signalBox & e_isp : e_sb'implementsSignalplans & e_asp_rel : e_isp'aspectRelations & e_ms : e_asp_rel'masterAspect & c = card(e_ms'refersToSignal) & c /= 1
        COUNTEREXAMPLE
            errorCard("refersToSignal", {e_ms}, 1, 1, c)
        END;
        RULE_FAIL e_sb, e_isp, e_asp_rel, e_ms
            WHEN e_sb : RailML3_signalBox & e_isp : e_sb'implementsSignalplans & e_asp_rel : e_isp'aspectRelations & e_ms : e_asp_rel'masterAspect & card(e_ms'refersToSignal) = 1 & MU_WD(e_ms'refersToSignal) /: allIdsOfType("signalIL")
        COUNTEREXAMPLE
            errorReference("refersToSignal", MU_WD(e_ms'refersToSignal), "signalIL", e_ms'xmlLineNumber)
        END;
        RULE_FAIL e_sb, e_isp, e_asp_rel, e_ms, c
            WHEN e_sb : RailML3_signalBox & e_isp : e_sb'implementsSignalplans & e_asp_rel : e_isp'aspectRelations & e_ms : e_asp_rel'masterAspect & c = card(e_ms'showsAspects) & c = 0
        COUNTEREXAMPLE
            errorCardOnlyLowerBound("showsAspect", {e_ms}, 1, c)
        END;
        RULE_FAIL e_sb, e_isp, e_asp_rel, c
            WHEN e_sb : RailML3_signalBox & e_isp : e_sb'implementsSignalplans & e_asp_rel : e_isp'aspectRelations & c = card(e_asp_rel'slaveAspect) & c > 1
        COUNTEREXAMPLE
            errorCard("slaveAspect", {e_asp_rel}, 0, 1, c)
        END;
        RULE_FAIL e_sb, e_isp, e_asp_rel, e_ss, c
            WHEN e_sb : RailML3_signalBox & e_isp : e_sb'implementsSignalplans & e_asp_rel : e_isp'aspectRelations & e_ss : e_asp_rel'slaveAspect & c = card(e_ss'refersToSignal) & c /= 1
        COUNTEREXAMPLE
            errorCard("refersToSignal", {e_ss}, 1, 1, c)
        END;
        RULE_FAIL e_sb, e_isp, e_asp_rel, e_ss
            WHEN e_sb : RailML3_signalBox & e_isp : e_sb'implementsSignalplans & e_asp_rel : e_isp'aspectRelations & e_ss : e_asp_rel'slaveAspect & card(e_ss'refersToSignal) = 1 & MU_WD(e_ss'refersToSignal) /: allIdsOfType("signalIL")
        COUNTEREXAMPLE
            errorReference("refersToSignal", MU_WD(e_ss'refersToSignal), "signalIL", e_ss'xmlLineNumber)
        END;
        RULE_FAIL e_sb, e_isp, e_asp_rel, e_ss, c
            WHEN e_sb : RailML3_signalBox & e_isp : e_sb'implementsSignalplans & e_asp_rel : e_isp'aspectRelations & e_ss : e_asp_rel'slaveAspect & c = card(e_ss'showsAspects) & c = 0
        COUNTEREXAMPLE
            errorCardOnlyLowerBound("showsAspect", {e_ss}, 1, c)
        END;
        RULE_FORALL e
            WHERE e : RailML3_specificInfrastructureManager & card(RailML3_specificInfrastructureManagers) = 1
            EXPECT e'pId = MU_WD(RailML3_specificInfrastructureManagers)'recId
        COUNTEREXAMPLE
            errorParent("specificInfrastructureManager", "RailML3_specificInfrastructureManagers", e'xmlLineNumber)
        END
    END;

    COMPUTATION set_IL_SIGNAL_BOX
    DEPENDS_ON_RULE is_valid_specificInfrastructureManager, validate_route
    DEPENDS_ON_COMPUTATION set_IL_SPECIFIC_INFRASTRUCTURE_MANAGER, set_IL_SIGNAL
    BODY
        DEFINE RailML3_IL_ASPECT_RELATION_APPLIES_TO_ROUTES
            TYPE allIdsOfType("aspectRelation") +-> FIN(allIdsOfType("route"))
            VALUE { i_asp, i_r | #(e_sb,e_isp,e_asp).(e_sb : RailML3_signalBox & e_isp : e_sb'implementsSignalplans & e_asp : e_isp'aspectRelations
                    & i_asp = MU_WD(e_asp'Id) & i_r = e_asp'appliesToRoutes
                )}
        END;
        // explicit signalplans from file
        DEFINE RailML3_IL_ASPECT_RELATION_SIGNAL_ASPECTS
            TYPE allIdsOfType("aspectRelation") -->
                struct(
                    master: allIdsOfType("signalIL") +-> FIN(RailML3_IL_SIGNAL_GENERIC_ASPECTS),
                    slave: allIdsOfType("signalIL") +-> FIN(RailML3_IL_SIGNAL_GENERIC_ASPECTS),
                    distant: allIdsOfType("signalIL") +-> FIN(RailML3_IL_SIGNAL_GENERIC_ASPECTS)
                )
            VALUE
                { i_asp_rel, asp_rel | #(e_sb,e_isp,e_asp_rel).(e_sb : RailML3_signalBox & e_isp : e_sb'implementsSignalplans & e_asp_rel : e_isp'aspectRelations
                    & i_asp_rel = MU_WD(e_asp_rel'Id)
                    & asp_rel = rec(
                        master: { i_sig, asp | #e_asp.(e_asp : e_asp_rel'masterAspect & i_sig = MU_WD(e_asp'refersToSignal) & asp = RailML3_IL_SPECIFIC_INFRASTRUCTURE_MANAGER_GENERIC_ASPECT_OF_ID[e_asp'showsAspects] )},
                        slave: { i_sig, asp | #e_asp.(e_asp : e_asp_rel'slaveAspect & i_sig = MU_WD(e_asp'refersToSignal) & asp = RailML3_IL_SPECIFIC_INFRASTRUCTURE_MANAGER_GENERIC_ASPECT_OF_ID[e_asp'showsAspects] )},
                        distant: { i_sig, asp | #e_asp.(e_asp : e_asp_rel'distantAspects & i_sig = MU_WD(e_asp'refersToSignal) & asp = RailML3_IL_SPECIFIC_INFRASTRUCTURE_MANAGER_GENERIC_ASPECT_OF_ID[e_asp'showsAspects] )}
                    )
                )}
        END;
        DEFINE RailML3_IL_ASPECT_RELATION_SIGNAL_ASPECTS_INFERRED_FROM_ROUTE
            TYPE allIdsOfType("route") +->
                FIN(struct(
                    master: allIdsOfType("signalIL") +-> FIN(RailML3_IL_SIGNAL_GENERIC_ASPECTS),
                    slave: allIdsOfType("signalIL") +-> FIN(RailML3_IL_SIGNAL_GENERIC_ASPECTS),
                    distant: allIdsOfType("signalIL") +-> FIN(RailML3_IL_SIGNAL_GENERIC_ASPECTS)
                ))
            VALUE
                fnc({ i_r, asp_rel | #(i_sig_entry, i_sig_exit, i_sigs, ms_asp, dist_asp).(                    
                    i_r : dom(RailML3_IL_ROUTE_NXT) - union(ran(RailML3_IL_ASPECT_RELATION_APPLIES_TO_ROUTES))
                    & i_sig_entry = prj1(RailML3_IL_ROUTE_ENTRY(i_r))
                    & i_sig_exit = prj1(RailML3_IL_ROUTE_EXIT(i_r))
                    & i_sigs = { i | i : allIdsOfType("signalIL") & RailML3_IS_SPOT_LOCATIONS(RailML3_IL_SIGNAL_REFERS_TO(i)) <: dom(RailML3_IL_ROUTE_NXT(i_r)) \/ ran(RailML3_IL_ROUTE_NXT(i_r)) } //& RailML3_IS_SIGNAL_IS_TRAIN_MOVEMENT_SIGNAL(RailML3_IL_SIGNAL_REFERS_TO(i)) = TRUE }
                        - {i_sig_entry, i_sig_exit}
                    & ( ms_asp = {i_sig_exit |-> {aspect_proceed}} or ms_asp = {i_sig_exit |-> {aspect_closed}} )
                    & dist_asp :
                        { asp_rels |
                            asp_rels <: i_sigs * {{aspect_proceed}, {aspect_closed}}
                            & card(asp_rels) = card(i_sigs)
                            & card(dom(asp_rels)) = card(asp_rels)
                            & !(i,a).( i |-> a : asp_rels & a = {aspect_proceed} => !(i_prev, a_prev).(i_prev |-> a_prev : asp_rels & !(s,s_prev).(s_prev : RailML3_IS_SPOT_LOCATIONS(RailML3_IL_SIGNAL_REFERS_TO(i_prev)) & s : RailML3_IS_SPOT_LOCATIONS(RailML3_IL_SIGNAL_REFERS_TO(i)) => s_prev |-> s : closure1(RailML3_IL_ROUTE_NXT(i_r))) => a_prev = {aspect_proceed}))
                            & ( ms_asp = {i_sig_exit |-> {aspect_proceed}} & i_sigs /= {} => ran(asp_rels) = {{aspect_proceed}} )
                        }
                    & asp_rel = rec(
                        master: IF i_sig_exit : allIdsOfType("signalIL") THEN ms_asp ELSE {} END,
                        slave: IF i_sig_entry : allIdsOfType("signalIL") & i_sig_exit : allIdsOfType("bufferStop") & dist_asp = {} THEN {i_sig_entry |-> {aspect_caution}} ELSIF i_sig_entry : allIdsOfType("signalIL") THEN {i_sig_entry |-> {aspect_proceed}} ELSE {} END,
                        distant: dist_asp
                    )
                    //& i_sigs /<: dom(union(ran(RailML3_IL_ASPECT_RELATION_SIGNAL_ASPECTS)))
                )})
        END;
        DEFINE RailML3_IL_SIGNAL_NOT_CONTROLLED_BY_SIGNALPLAN
            TYPE FIN(allIdsOfType("signalIS"))
            VALUE dom({ i_sig, i_sig_il | i_sig : allIdsOfType("signalIS") & i_sig = RailML3_IL_SIGNAL_REFERS_TO(i_sig_il)//& RailML3_IS_SIGNAL_IS_TRAIN_MOVEMENT_SIGNAL(i_sig) = TRUE
                    & ( !r.( r : ran(RailML3_IL_ASPECT_RELATION_SIGNAL_ASPECTS) \/ union(ran(RailML3_IL_ASPECT_RELATION_SIGNAL_ASPECTS_INFERRED_FROM_ROUTE)) => i_sig_il /: dom(r'master \/ r'slave \/ r'distant) )
                        or
                        #end.(end : union(RailML3_IL_SIGNAL_END_OF_CONTROL_SECTION[{i_sig}])
                            & !(NXT,sloc).(NXT : ran(RailML3_IL_ROUTE_NXT) & sloc : union(RailML3_IS_SPOT_LOCATIONS[{end}]) => sloc /: dom(NXT) \/ ran(NXT) ) )
                    )
                })
        END
    END;

    RULE warnings_signalBox
    DEPENDS_ON_COMPUTATION set_IL_SIGNAL_BOX
    ERROR_TYPES 2
    BODY
        RULE_FAIL e_asp_rel
            WHEN e_asp_rel : elementsOfType("aspectRelation") & "endSectionTime" /: dom(e_asp_rel'attributes)
        COUNTEREXAMPLE
            warningDefaultValue("endSectionTime", "1000", STRING_TO_INT(e_asp_rel'meta("xmlLineNumber")))
        END;
        RULE_FORALL e_sb, e_isp, e_asp_rel, i_asp_rel, master_asp
            WHERE e_sb : RailML3_signalBox & e_isp : e_sb'implementsSignalplans & e_asp_rel : e_isp'aspectRelations & i_asp_rel = MU_WD(e_asp_rel'Id) & master_asp = RailML3_IL_ASPECT_RELATION_SIGNAL_ASPECTS(i_asp_rel)'master
            EXPECT #sp.(sp : ran(RailML3_IL_ASPECT_RELATION_SIGNAL_ASPECTS) & sp'slave = master_asp)
        ERROR_TYPE 2
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: Aspect relation uses master aspect ~w, but there is no aspect relation with the same slave aspect for connecting both relations", e_asp_rel'xmlLineNumber, i_asp_rel, master_asp)
        END;
        RULE_FAIL e_sb, e_isp, e_asp_rel, e_asp, exp_speed
            WHEN e_sb : RailML3_signalBox & e_isp : e_sb'implementsSignalplans & e_asp_rel : e_isp'aspectRelations
                & e_asp : e_asp_rel'distantAspects \/ e_asp_rel'masterAspect \/ e_asp_rel'slaveAspect & {aspect_closed} <: RailML3_IL_SPECIFIC_INFRASTRUCTURE_MANAGER_GENERIC_ASPECT_OF_ID[e_asp'showsAspects]
                & exp_speed : e_asp_rel'expectingSpeed & exp_speed > 0.0
        ERROR_TYPE 2
        COUNTEREXAMPLE
            STRING_FORMAT("[Line ~w, id '~w']: Signalplan contains at least one aspect_closed, but expecting speed is ~w > 0", e_asp_rel'xmlLineNumber, MU_WD(e_asp_rel'Id), exp_speed)
        END
    END;
    // END SIGNAL_BOXES

    // BEGIN SPECIFIC_INFRASTRUCTURE_MANAGERS
    COMPUTATION set_specificInfrastructureManagers
    DEPENDS_ON_RULE is_valid_interlocking
    BODY
        DEFINE RailML3_specificInfrastructureManagers
            TYPE FIN(RailML3_IL_generic_Type)
            VALUE IF version = {v3_2} THEN genericILType("specificInfrastructureManagers") ELSE genericILType("specificIMs") END
        END
    END;
    RULE is_valid_specificInfrastructureManagers
    DEPENDS_ON_COMPUTATION set_specificInfrastructureManagers
    BODY
        RULE_FAIL c
            WHEN c = card(RailML3_specificInfrastructureManagers) & c /: 0..card(RailML3_interlocking) // (0..1), 0 if no interlocking
        COUNTEREXAMPLE 
            errorCard("specificInfrastructureManagers", RailML3_specificInfrastructureManagers, 0, card(RailML3_interlocking), c)
        END;
        RULE_FORALL e
            WHERE e : RailML3_specificInfrastructureManagers & card(RailML3_interlocking) = 1
            EXPECT e'pId = MU_WD(RailML3_interlocking)'recId
        COUNTEREXAMPLE 
            errorParent("specificInfrastructureManagers", "interlocking", e'xmlLineNumber)
        END
    END;

    COMPUTATION set_specificInfrastructureManager
    DEPENDS_ON_RULE is_valid_specificInfrastructureManagers
    BODY
        DEFINE RailML3_specificInfrastructureManager
            TYPE FIN(RailML3_IL_specificInfrastructureManager_Type)
            VALUE dom({e, e_sim | e_sim : IF version = {v3_2} THEN elementsOfType("specificInfrastructureManager") ELSE elementsOfType("specificIM") END
                & e = rec(
                        recId: e_sim'recId,
                        pId: e_sim'pId,
                        xmlLineNumber: STRING_TO_INT(e_sim'meta("xmlLineNumber")),
                        Id: e_sim'attributes[{"id"}],
                        usesTypes: dom({ a,c | c : childsOfElementType("usesTypes", e_sim'recId)
                                & a = rec(
                                    xmlLineNumber : STRING_TO_INT(c'meta("xmlLineNumber")),
                                    hasAspects : dom({ i_A, e_A | e_A : childsOfElementType( "hasAspect", c'recId)
                                            & i_A = rec(
                                                xmlLineNumber : STRING_TO_INT(e_A'meta("xmlLineNumber")),
                                                Id : e_A'attributes[{"id"}],
                                                genericAspect : IF "genericAspect" : dom(e_A'attributes) THEN {TYPED_STRING_TO_ENUM(RailML3_IL_SIGNAL_GENERIC_ASPECTS, "aspect_"^e_A'attributes("genericAspect"))} ELSE {} END
                                            )
                                        })
                                )
                            })
                    ) })
        END
    END;
    RULE is_valid_specificInfrastructureManager
    DEPENDS_ON_COMPUTATION set_specificInfrastructureManager
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_specificInfrastructureManager) & IF card(RailML3_specificInfrastructureManagers) = 1 THEN c = 0 ELSE c /= 0 END // (1..*), 0 if no specificInfrastructureManagers
        COUNTEREXAMPLE
            IF card(RailML3_specificInfrastructureManagers) = 1 
                THEN errorCardOnlyLowerBound("specificInfrastructureManager", RailML3_specificInfrastructureManagers, 1, c)
                ELSE errorCard("specificInfrastructureManager", RailML3_specificInfrastructureManager, 0, 0, c)
            END
        END;
        RULE_FAIL e
            WHEN version = {v3_2} & e : RailML3_specificInfrastructureManager & (card(e'Id) /= 1 or (card(e'Id) = 1 & MU_WD(e'Id) = ""))
        COUNTEREXAMPLE
            errorAttribute("id", "specificInfrastructureManager", e'xmlLineNumber)
        END;
        RULE_FAIL e_sim, c
            WHEN e_sim : RailML3_specificInfrastructureManager & c = card(e_sim'usesTypes) & c /= 1
        COUNTEREXAMPLE
            errorCard("usesTypes", {e_sim}, 1, 1, c)
        END;
        RULE_FAIL e_sim, e_ut, e_asp
            WHEN e_sim : RailML3_specificInfrastructureManager & e_ut : e_sim'usesTypes & e_asp : e_ut'hasAspects & (card(e_asp'Id) /= 1 or card(e_asp'Id) = 1 & MU_WD(e_asp'Id) = "")
        COUNTEREXAMPLE
            errorAttribute("id", "hasAspect", e_asp'xmlLineNumber)
        END;
        RULE_FAIL e_sim, e_ut, e_asp
            WHEN e_sim : RailML3_specificInfrastructureManager & e_ut : e_sim'usesTypes & e_asp : e_ut'hasAspects & card(e_asp'genericAspect) /= 1
        COUNTEREXAMPLE
            errorAttribute("id", "genericAspect", e_asp'xmlLineNumber)
        END;
        RULE_FAIL e_sim, e_ut, c
            WHEN e_sim : RailML3_specificInfrastructureManager & e_ut : e_sim'usesTypes & c = card(e_ut'hasAspects) & c < 2
        COUNTEREXAMPLE
            errorCardOnlyLowerBound("hasAspect", {e_ut}, 2, c)
        END;
        RULE_FORALL e
            WHERE e : RailML3_specificInfrastructureManager & card(RailML3_specificInfrastructureManagers) = 1
            EXPECT e'pId = MU_WD(RailML3_specificInfrastructureManagers)'recId
        COUNTEREXAMPLE
            errorParent("specificInfrastructureManager", "RailML3_specificInfrastructureManagers", e'xmlLineNumber)
        END
    END;    

    COMPUTATION set_IL_SPECIFIC_INFRASTRUCTURE_MANAGER
    DEPENDS_ON_RULE is_valid_specificInfrastructureManager
    BODY        
        DEFINE RailML3_IL_SPECIFIC_INFRASTRUCTURE_MANAGER_GENERIC_ASPECT_OF_ID
            TYPE allIdsOfType("hasAspect") --> RailML3_IL_SIGNAL_GENERIC_ASPECTS
            VALUE { i_asp, asp | #(e_sim, e_ut,e_asp).(e_sim : RailML3_specificInfrastructureManager & e_ut : e_sim'usesTypes & e_asp : e_ut'hasAspects & i_asp = MU_WD(e_asp'Id) & asp = MU_WD(e_asp'genericAspect)) }
        END
    END
    // END SPECIFIC_INFRASTRUCTURE_MANAGERS
END//MACHINE