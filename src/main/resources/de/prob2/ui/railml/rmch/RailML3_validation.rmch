/* RailML3 Validation Rules
------------------------------
Using this machine, custom rules can be added for validation.
The recommended and easiest way to add custom rules is to use the generated validation machine by 'RailML3_printMachines.mch',
which contains the example rule defined below and can be extended as desired.
------------------------------
Use the internal representation of this machine for inclusion in 'RailML_import.mch'.
Necessary adaptions:
    - change machine name to 'RailML3_validation_flat'
    (- add '/ *@desc memo * /' after ABSTRACT_CONSTANT elementsOfType for memoization)
    - comment out file = '<path>' in PROPERTIES
*/
RULES_MACHINE RailML3_validation
REFERENCES RailML3_readFile, RailML3_CO, RailML3_IS, RailML3_IL
DEFINITIONS
    "CHOOSE.def";
    "LibraryMath.def";
    "LibraryMeta.def";
    "LibraryReals.def";

    errorCard(TypeAsString, Set, MinNr, MaxNr, ActualNr) == 
        STRING_FORMAT("[Lines ~w]: expected min. ~w and max. ~w elements of type '"^TypeAsString^"', but were ~w", dom({ nr, e | e : Set & nr = e'xmlLineNumber }), MinNr, MaxNr, ActualNr);
    errorCardOnlyLowerBound(TypeAsString, Set, MinNr, ActualNr) == 
        STRING_FORMAT("[Lines ~w]: expected min. ~w elements of type '"^TypeAsString^"', but were ~w", dom({ nr, e | e : Set & nr = e'xmlLineNumber }), MinNr, ActualNr);
    errorAttribute(AttrNameAsString, TypeAsString, lineNr) ==
        STRING_FORMAT("[Line ~w]: expected obligatory attribute '"^AttrNameAsString^"' for element '"^TypeAsString^"' is missing", lineNr);
    errorParent(TypeAsString, ParentTypeAsString, lineNr) == 
        STRING_FORMAT("[Line ~w]: expected parent of type '"^ParentTypeAsString^"' for type '"^TypeAsString^"'", lineNr);
    errorParentMultipleTypes(TypeAsString, SetOfParentTypesAsString, lineNr) == 
        STRING_FORMAT("[Line ~w]: expected parent of types '~w' for type '"^TypeAsString^"'", lineNr, SetOfParentTypesAsString);
    errorType(ElementTypeAsString, ExpectedTypeAsString, ActualElementAsString, lineNr) == 
        STRING_FORMAT("[Line ~w]: expected '"^ElementTypeAsString^"' of type '"^ExpectedTypeAsString^"', but was '"^ActualElementAsString^"'", lineNr);

// only for flat machine:
    "LibraryProB.def";
    "LibraryXML.def";
    "LibraryRegex.def";
    "LibraryStrings.def";
    "LibraryIO.def";

    distanceBetween(a,b) ==
        min(
            dom({ l, nxt | #r.(r = ( railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1[{a}] /\ railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1~[{b}] ) \/ {a, b}
                & nxt = r <| RailML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS |> r
                //& nxt : dom(RailML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS) >+> ran(RailML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS)
                //& a |-> b : closure1(nxt)
                & l = SIGMA(c).( c : nxt & prj1(prj1(prj1(c))) = prj1(prj1(prj2(c))) & prj1(prj1(prj1(c))) : dom(RailML3_IS_NET_ELEMENT_LENGTHS) & RailML3_IS_NET_ELEMENT_LENGTHS(prj1(prj1(prj1(c)))) /= -1.0 | RABS(prj2(prj1(prj1(c))) - prj2(prj1(prj2(c)))) * RailML3_IS_NET_ELEMENT_LENGTHS(prj1(prj1(prj1(c)))) )
            )})
        );

    EBO_maximum_speed_per_curve_radius(radius, superelevation) ==
        RSQRT(RABS(radius)/11.8 * (superelevation + 130.0)); // http://www.gesetze-im-internet.de/ebo/__40.html, "Ueberhoehungsfehlbetrag" here chosen as 130 mm
OPERATIONS
    RULE EBO_CheckSwitchSpeeds
    DEPENDS_ON_RULE is_valid_switchIS
    BODY
        RULE_FORALL
            e_sw, b_lb, b_lj, b_rb, b_rj//, b_s, b_t
        WHERE
            e_sw : RailML3_switchIS
            // left branch, branching speed, if available
            & b_lb = bool( #(left, r_l, bs_l).( IF card(e_sw'leftBranch) = 1 THEN left = MU(e_sw'leftBranch) ELSE 1=1 END
                    & IF card(left'radius) = 1 THEN r_l = MU(left'radius) ELSE 1=1 END
                    & IF card(left'branchingSpeed) = 1 THEN bs_l = MU(left'branchingSpeed) ELSE 1=1 END
                    & (r_l = 0.0 or bs_l <= EBO_maximum_speed_per_curve_radius(r_l,0.0)) ) )
            // left branch, joining speed, if available
            & b_lj = bool( #(left, r_l, js_l).( IF card(e_sw'leftBranch) = 1 THEN left = MU(e_sw'leftBranch) ELSE 1=1 END
                    & IF card(left'radius) = 1 THEN r_l = MU(left'radius) ELSE 1=1 END
                    & IF card(left'joiningSpeed) = 1 THEN js_l = MU(left'joiningSpeed) ELSE 1=1 END
                    & (r_l = 0.0 or js_l <= EBO_maximum_speed_per_curve_radius(r_l,0.0)) ) )
            // right branch, branching speed, if available
            & b_rb = bool( #(right, r_r, bs_r).( IF card(e_sw'rightBranch) = 1 THEN right = MU(e_sw'rightBranch) ELSE 1=1 END
                    & IF card(right'radius) = 1 THEN r_r = MU(right'radius) ELSE 1=1 END
                    & IF card(right'branchingSpeed) = 1 THEN bs_r = MU(right'branchingSpeed) ELSE 1=1 END
                    & (r_r = 0.0 or bs_r <= EBO_maximum_speed_per_curve_radius(r_r,0.0)) ) )
            // right branch, joining speed, if available
            & b_rj = bool( #(right, r_r, js_r).( IF card(e_sw'rightBranch) = 1 THEN right = MU(e_sw'rightBranch) ELSE 1=1 END
                    & IF card(right'radius) = 1 THEN r_r = MU(right'radius) ELSE 1=1 END
                    & IF card(right'joiningSpeed) = 1 THEN js_r = MU(right'joiningSpeed) ELSE 1=1 END
                    & (r_r = 0.0 or js_r <= EBO_maximum_speed_per_curve_radius(r_r,0.0)) ) )
        EXPECT
            b_lb = TRUE & b_lj = TRUE & b_rb = TRUE & b_rj = TRUE
        COUNTEREXAMPLE
            "[EBO_CheckSwitchSpeeds] Switch id "^MU(e_sw'Id)^" has invalid speed(s):"^
            IF b_lb = FALSE
                THEN STRING_FORMAT(" [branching speed of left branch is ~w, but expected <= ~w] ", MU(MU(e_sw'leftBranch)'branchingSpeed), EBO_maximum_speed_per_curve_radius(MU(MU(e_sw'leftBranch)'radius),0.0))
                ELSE ""
            END
            ^
            IF b_lj = FALSE
                THEN STRING_FORMAT(" [joining speed of left branch is ~w, but expected <= ~w] ", MU(MU(e_sw'leftBranch)'joiningSpeed), EBO_maximum_speed_per_curve_radius(MU(MU(e_sw'leftBranch)'radius),0.0))
                ELSE ""
            END
            ^
            IF b_rb = FALSE
                THEN STRING_FORMAT(" [branching speed of right branch is ~w, but expected <= ~w] ", MU(MU(e_sw'rightBranch)'branchingSpeed), EBO_maximum_speed_per_curve_radius(MU(MU(e_sw'rightBranch)'radius),0.0))
                ELSE ""
            END
            ^
            IF b_rj = FALSE
                THEN STRING_FORMAT(" [joining speed of right branch is ~w, but expected <= ~w] ", MU(MU(e_sw'rightBranch)'joiningSpeed), EBO_maximum_speed_per_curve_radius(MU(MU(e_sw'rightBranch)'radius),0.0))
                ELSE ""
            END
        END
    END;
    RULE MinDistanceOfTDEs // requires all netElements to have an attribute length
    BODY
        RULE_FORALL i_tde1, i_tde2, sloc1, sloc2, dist
            WHERE {i_tde1, i_tde2} <: allIdsOfType("trainDetectionElement") & i_tde1 /= i_tde2
                & sloc1 : RailML3_IS_SPOT_LOCATIONS(i_tde1) & sloc2 : RailML3_IS_SPOT_LOCATIONS(i_tde2) & sloc1 |-> sloc2 : railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1
                & !i_ne.(i_ne : dom(RailML3_IS_NET_ELEMENT_LENGTHS) /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL => RailML3_IS_NET_ELEMENT_LENGTHS(i_ne) /= -1.0)
                & not(#(i_tde3, sloc3).(i_tde3 : allIdsOfType("trainDetectionElement") & sloc3 : RailML3_IS_SPOT_LOCATIONS(i_tde3) & sloc1 |-> sloc3 : railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1 & sloc3 |-> sloc2 : railML3_IS_NET_RELATION_SUBSEQUENT_LOCATIONS_closure1))
                & dist = distanceBetween(sloc1, sloc2)
            EXPECT dist > 21.0
        COUNTEREXAMPLE
            STRING_FORMAT("Distance between trainDetectionElements ~w and ~w is ~w (<= 21.0)", i_tde1, i_tde2, dist)
        END
    END
END//MACHINE