/*
RailML3 Common Rules
------------------------------
Reads RailML3 common from XML "data" in "RailML_readFile.rmch" and creates a new set per element type by a computation.
The type of the set is specific for each element type. Types are specified in "RailML3_CO_Types.def".
Childs with finite cardinality (e.g. (0..1), (1..1) or (0..2)) or properties which can be listed easily (e.g. string refs in a set (0..*))
are included in their parent; others stored as types separatly.
Necessary rules that must hold for valid RailML data are checked on this sets. They only check the pure railML schematic rules;
specific constraints for B are validated in RailML_validation.mch.
Sets for animation are created after successful validation of the data.

The general procedure for each element type is:
    - Computation "set_xyz":
        Search data for all elements of type "xyz" -> Compute RailML_xyz of B-type RailML3_IS_xyz_Type to guarantee correct types of attributes
    - Rule is_valid_xyz:
        Validation of the correct cardinality of the elements themselves and of the attributes
        Validate whether the element xyz has the correct parent element; if successful, xyz is fully validated
    - Rule warnings_xyz
        When a default value was set for a not available attribute and the default value is not part of the railML schema a warning should be prompted
    - Computation(s) set_IS_XYZ(_IDS):
        Convert selected data into a structure that is used for animation.
*/
RULES_MACHINE RailML3_CO
REFERENCES RailML3_readFile
SETS
    RailML3_CO_GENERIC_TYPES = {positioning, speedProfiles};

    // Attribute Types:
    RailML3_CO_SPEED_PROFILE_ACTUATIONS = {actuation_active, actuation_none, actuation_passive, actuation_rollCompensation};
    RailML3_CO_SPEED_PROFILE_AIR_BRAKE_APPLICATION_POSITIONS = {airBrakeApplicationPosition_P, airBrakeApplicationPosition_R, airBrakeApplicationPosition_G};
    RailML3_CO_SPEED_PROFILE_BRAKE_TYPES = {brakeType_none, brakeType_compressedAirBrake, brakeType_vacuumAirBrake,
        brakeType_cableBrake, brakeType_parkingBrake, brakeType_handBrake};
    RailML3_CO_SPEED_PROFILE_TRAIN_TYPES = {trainType_all, trainType_freight, trainType_mixed, trainType_passenger};
    RailML3_CO_SPEED_PROFILE_INFLUENCES = {influence_decreasing, influence_increasing}
DEFINITIONS
    "CHOOSE.def";
    "LibraryStrings.def";
    "RailML3_CO_Types.def";
    
    elementOfId(Set, eId) == MU( { e | e : Set & eId = MU(e'Id)} );

    genericCOType(TypeAsString) == 
        dom({e, e_g | e_g : elementsOfType(TypeAsString)
                    & e = rec(
                            recId:e_g'recId,
                            pId:e_g'pId,
                            xmlLineNumber:STRING_TO_INT(e_g'meta("xmlLineNumber")),
                            type:TYPED_STRING_TO_ENUM(RailML3_CO_GENERIC_TYPES, TypeAsString)
                        ) });

    errorCard(TypeAsString, Set, MinNr, MaxNr, ActualNr) == 
        STRING_FORMAT("[Lines ~w]: expected min. ~w and max. ~w elements of type '"^TypeAsString^"', but were ~w", dom({ nr, e | e : Set & nr = e'xmlLineNumber }), MinNr, MaxNr, ActualNr);
    errorCardOnlyLowerBound(TypeAsString, Set, MinNr, ActualNr) == 
        STRING_FORMAT("[Lines ~w]: expected min. ~w elements of type '"^TypeAsString^"', but were ~w", dom({ nr, e | e : Set & nr = e'xmlLineNumber }), MinNr, ActualNr);
    errorAttribute(AttrNameAsString, TypeAsString, lineNr) ==
        STRING_FORMAT("[Line ~w]: expected obligatory attribute '"^AttrNameAsString^"' for element '"^TypeAsString^"' is missing", lineNr);
    errorParent(TypeAsString, ParentTypeAsString, lineNr) == 
        STRING_FORMAT("[Line ~w]: expected parent of type '"^ParentTypeAsString^"' for type '"^TypeAsString^"'", lineNr);
    errorParentMultipleTypes(TypeAsString, SetOfParentTypesAsString, lineNr) == 
        STRING_FORMAT("[Line ~w]: expected parent of types '~w' for type '"^TypeAsString^"'", lineNr, SetOfParentTypesAsString);
    errorType(ElementTypeAsString, ExpectedTypeAsString, ActualElementAsString, lineNr) == 
        STRING_FORMAT("[Line ~w]: expected '"^ElementTypeAsString^"' of type '"^ExpectedTypeAsString^"', but was '"^ActualElementAsString^"'", lineNr)
OPERATIONS
    COMPUTATION set_common
    DEPENDS_ON_COMPUTATION read_file
    BODY
        DEFINE RailML3_common
            TYPE FIN(RailML3_common_Type)
            VALUE dom({e, e_co | e_co : elementsOfType("common")
                & e = rec(recId:e_co'recId, pId:e_co'pId, xmlLineNumber:STRING_TO_INT(e_co'meta("xmlLineNumber")), Id:e_co'attributes[{"id"}]) })
        END
    END;
    RULE is_valid_common
    DEPENDS_ON_COMPUTATION set_common
    BODY
        RULE_FAIL c
            WHEN c = card(RailML3_common) & c > 1
        COUNTEREXAMPLE 
            errorCard("common", RailML3_common, 0, 1, c)
        END;
        RULE_FAIL e
            WHEN e : RailML3_common & (card(e'Id) /= 1 or (card(e'Id) = 1 & MU_WD(e'Id) = ""))
        COUNTEREXAMPLE
            errorAttribute("id", "common", e'xmlLineNumber)
        END;
        RULE_FAIL e
            WHEN e : RailML3_common & e'pId /= 1
        COUNTEREXAMPLE 
            errorParent("common", "railML", e'xmlLineNumber)
        END
    END;

    COMPUTATION set_name
    DEPENDS_ON_COMPUTATION read_file
    BODY
        DEFINE RailML_name
            TYPE FIN(RailML3_CO_name_Type)
            VALUE dom({e,e_n | e_n : elementsOfType("name")
                & e = rec(
                        recId : e_n'recId, 
                        pId : e_n'pId,                        
                        xmlLineNumber : STRING_TO_INT(e_n'meta("xmlLineNumber")),
                        name : e_n'attributes[{"name"}],
                        language : e_n'attributes[{"language"}],
                        refersTo : data(e_n'pId)'attributes("id")
                    ) })
        END
    END;
    RULE is_valid_name
    DEPENDS_ON_COMPUTATION set_name
    BODY
        RULE_FAIL e
            WHEN e : RailML_name & (card(e'name) /= 1 or card(e'name) = 1 & MU_WD(e'name) = "")
        COUNTEREXAMPLE
            errorAttribute("name", "name", e'xmlLineNumber)
        END;
        RULE_FAIL e
            WHEN e : RailML_name & card(e'language) /= 1
        COUNTEREXAMPLE
            errorAttribute("language", "name", e'xmlLineNumber)
        END;
        RULE_FORALL e, valid_parents
            WHERE e : RailML_name
                & valid_parents = {"alternative", "announcement", "approvedBy", "areaElementProjection", "balise", "baliseGroup", "border", "bufferStop", "category",
                    "checkedBy", "commercialTrain", "concessionaire", "contractor", "crossesElement", "crossing", "customer", "derailerIS", "detector", "electrificationSection",
                    "elementState", "ellipticalProjection", "etcsArea", "etcsLevelTransition", "genericArea", "geometricPositioningSystem", "geometryPoint", "gradientCurve",
                    "hasHmiIndication", "hasOperatorCommand", "holiday", "horizontalCurve", "infrastructureManager", "infrastructureState", "infrastructureVisualization", "keeper",
                    "keyLockIS", "levelCrossingIS", "line", "linearElementProjection", "linearPositioningSystem", "loadingGauge", "manufacturer", "mediaCategory", "mileageChange",
                    "netElement", "netRelation", "network", "networkResource", "operationalPoint", "operationalTrain", "operationalUndertaking", "operator", "organizationalUnit",
                    "overCrossing", "owner", "passengerTextInfo", "phase", "platform", "platformEdge", "project", "radioBlockCentreBorder", "railwayUndertaking", "reserve",
                    "restrictionArea", "revisedBy", "revision", "screenPositioningSystem", "serviceSection", "signalIS", "speedProfile", "speedSection", "spotElementProjection",
                    "stoppingPlace", "switchIS", "timetableScenario", "track", "trackBed", "trackGauge", "trainDetectionElement", "trainProtectionElement", "trainRadio",
                    "transportService", "tunnelGateIS", "underCrossing", "usesSymbol", "validity", "vehicleManufacturer", "vehicleOperator", "visualization", "weightLimit" }
            EXPECT data(e'pId)'element : valid_parents
        COUNTEREXAMPLE
            errorParentMultipleTypes("name", TO_STRING(valid_parents), e'xmlLineNumber)
        END
    END;

    COMPUTATION set_CO_NAME
    DEPENDS_ON_RULE is_valid_name
    BODY
        DEFINE RailML3_CO_NAMES
            TYPE (STRING * STRING) +-> STRING
            VALUE { i, n | #e_n.(e_n : RailML_name & i = e_n'refersTo |-> MU_WD(e_n'language) & n = MU_WD(e_n'name) )}
        END
    END;

    // BEGIN SPEED_PROFILES
    COMPUTATION set_speedProfiles
    DEPENDS_ON_RULE is_valid_common
    BODY
        DEFINE RailML3_speedProfiles
            TYPE FIN(RailML3_CO_generic_Type)
            VALUE genericCOType("speedProfiles")
        END
    END;
    RULE is_valid_speedProfiles
    DEPENDS_ON_COMPUTATION set_speedProfiles
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_speedProfiles) & c /: 0..card(RailML3_common) // (0..1), 0 if no common
        COUNTEREXAMPLE
            errorCard("speedProfiles", RailML3_speedProfiles, 0, card(RailML3_common), c)
        END;
        RULE_FORALL e
            WHERE e : RailML3_speedProfiles & card(RailML3_common) = 1
            EXPECT e'pId = MU_WD(RailML3_common)'recId
        COUNTEREXAMPLE
            errorParent("speedProfiles", "common", e'xmlLineNumber)
        END
    END;

    COMPUTATION set_speedProfile
    DEPENDS_ON_RULE is_valid_speedProfiles
    BODY
        DEFINE RailML3_speedProfile
            TYPE FIN(RailML3_CO_speedProfile_Type)
            VALUE dom({e, e_sp | e_sp : elementsOfType("speedProfile")
                & e = rec(
                        recId: e_sp'recId,
                        pId: e_sp'pId,
                        xmlLineNumber: STRING_TO_INT(e_sp'meta("xmlLineNumber")),
                        Id: e_sp'attributes[{"id"}],
                        isBasicSpeedProfile: IF "isBasicSpeedProfile" : dom(e_sp'attributes) & e_sp'attributes("isBasicSpeedProfile") = "false" THEN FALSE ELSE TRUE END,
                        mVersion: IF "mVersion" : dom(e_sp'attributes) & STRING_IS_INT(e_sp'attributes("mVersion")) THEN {STRING_TO_INT(e_sp'attributes("mVersion"))} ELSE {} END,
                        influence: IF "influence" : dom(e_sp'attributes) THEN {TYPED_STRING_TO_ENUM(RailML3_CO_SPEED_PROFILE_INFLUENCES, "influence_"^e_sp'attributes("influence"))} ELSE {} END,
                        maxCantDeficiency: IF "maxCantDeficiency" : dom(e_sp'attributes) & STRING_IS_INT(e_sp'attributes("maxCantDeficiency")) THEN {STRING_TO_INT(e_sp'attributes("maxCantDeficiency"))} ELSE {} END,
                        braking: dom({ a, c | c : childsOfElementType("braking", e_sp'recId)
                            & a = rec(
                                    brakeType: IF "brakeType" : dom(c'attributes) THEN {TYPED_STRING_TO_ENUM(RailML3_CO_SPEED_PROFILE_BRAKE_TYPES, "brakeType_"^c'attributes("brakeType"))} ELSE {} END,
                                    airBrakeApplicationPosition: IF "airBrakeApplicationPosition" : dom(c'attributes) THEN {TYPED_STRING_TO_ENUM(RailML3_CO_SPEED_PROFILE_AIR_BRAKE_APPLICATION_POSITIONS, "airBrakeApplicationPosition_"^c'attributes("airBrakeApplicationPosition"))} ELSE {} END,
                                    minBrakePercentage: IF "minBrakePercentage" : dom(c'attributes) & STRING_IS_INT(c'attributes("minBrakePercentage")) THEN {STRING_TO_INT(c'attributes("minBrakePercentage"))} ELSE {} END
                                )}),
                        load: dom({ a, c | c : childsOfElementType("load", e_sp'recId)
                            & a = rec(
                                    exceedsAxleLoad: IF "exceedsAxleLoad" : dom(c'attributes) & STRING_IS_NUMBER(c'attributes("exceedsAxleLoad")) THEN {STRING_TO_REAL(c'attributes("exceedsAxleLoad"))} ELSE {} END,
                                    exceedsMeterLoad: IF "exceedsMeterLoad" : dom(c'attributes) & STRING_IS_NUMBER(c'attributes("exceedsMeterLoad")) THEN {STRING_TO_REAL(c'attributes("exceedsMeterLoad"))} ELSE {} END
                                )}),
                        tilting: dom({ a, c | c : childsOfElementType("tilting", e_sp'recId)
                            & a = rec(
                                    actuation: IF "actuation" : dom(c'attributes) THEN {TYPED_STRING_TO_ENUM(RailML3_CO_SPEED_PROFILE_ACTUATIONS, "actuation_"^c'attributes("actuation"))} ELSE {} END,
                                    maxTiltingAngle: IF "maxTiltingAngle" : dom(c'attributes) & STRING_IS_NUMBER(c'attributes("maxTiltingAngle")) THEN {STRING_TO_REAL(c'attributes("maxTiltingAngle"))} ELSE {} END
                                )}),
                        trainType: dom({ a, c | c : childsOfElementType("trainType", e_sp'recId)
                            & a = rec(
                                    type: IF "type" : dom(c'attributes) THEN {TYPED_STRING_TO_ENUM(RailML3_CO_SPEED_PROFILE_TRAIN_TYPES, "trainType_"^c'attributes("type"))} ELSE {} END,
                                    etcsTrainCategoryNumber: dom({ b, d | d : childsOfElementType("etcsSpeedProfile", c'recId)
                                            & b : IF "etcsTrainCategoryNumber" : dom(d'attributes) & STRING_IS_INT(d'attributes("etcsTrainCategoryNumber")) THEN {STRING_TO_INT(d'attributes("etcsTrainCategoryNumber"))} ELSE {} END
                                        })
                                ) })
                ) })
        END
    END;
    RULE is_valid_speedProfile
    DEPENDS_ON_COMPUTATION set_speedProfile
    BODY
        RULE_FAIL c
        WHEN
            c = card(RailML3_speedProfile) & IF card(RailML3_speedProfiles) = 1 THEN c < 1 ELSE c /= 0 END // (1..*), 0 if no speedProfiles
        COUNTEREXAMPLE
            IF card(RailML3_speedProfiles) = 1 
                THEN errorCardOnlyLowerBound("speedProfile", RailML3_speedProfile, 1, c)
                ELSE errorCard("speedProfile", RailML3_speedProfile, 0, 0, c)
            END
        END;
        RULE_FAIL e
            WHEN e : RailML3_speedProfile & (card(e'Id) /= 1 or (card(e'Id) = 1 & MU_WD(e'Id) = ""))
        COUNTEREXAMPLE
            errorAttribute("id", "speedProfile", e'xmlLineNumber)
        END;
        RULE_FAIL e_sp, c
            WHEN e_sp : RailML3_speedProfile & c = card(e_sp'braking) & c > 1
        COUNTEREXAMPLE
            errorCard("braking", {e_sp}, 0, 1, c)
        END;
        RULE_FAIL e_sp, c
            WHEN e_sp : RailML3_speedProfile & c = card(e_sp'load) & c > 1
        COUNTEREXAMPLE
            errorCard("load", {e_sp}, 0, 1, c)
        END;
        RULE_FAIL e_sp, c
            WHEN e_sp : RailML3_speedProfile & c = card(e_sp'tilting) & c > 1
        COUNTEREXAMPLE
            errorCard("tilting", {e_sp}, 0, 1, c)
        END;
        RULE_FAIL e_sp, e_tt, c
            WHEN e_sp : RailML3_speedProfile & e_tt : e_sp'trainType & c = card(e_tt'etcsTrainCategoryNumber) & c > 1
        COUNTEREXAMPLE
            errorCard("etcsTrainCategoryNumber@trainType", {e_sp}, 0, 1, c)
        END;
        RULE_FORALL e
            WHERE e : RailML3_speedProfile & card(RailML3_speedProfiles) = 1
            EXPECT e'pId = MU_WD(RailML3_speedProfiles)'recId
        COUNTEREXAMPLE
            errorParent("speedProfile", "speedProfiles", e'xmlLineNumber)
        END
    END
    // END SPEED_PROFILES

    // TODO: different linear positioning systems
END