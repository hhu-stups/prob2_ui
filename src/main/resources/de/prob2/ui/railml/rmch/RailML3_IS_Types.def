DEFINITIONS
    //-----------------------------------------------------------------------------
    // RailML 3: INFRASTRUCTURE
    // descriptions taken from https://wiki3.railml.org/wiki/IS:infrastructure
    //-----------------------------------------------------------------------------

    // dummy type for container types without IDs such as 'netElements' for 'netElement'
    RailML3_IS_generic_Type ==
        struct(
            recId : NATURAL1,
            pId : NATURAL,
            xmlLineNumber : NATURAL1,
            type : RailML3_IS_GENERIC_TYPES
        );

    // root element for railML3 infrastructure model
    RailML3_infrastructure_Type == 
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("infrastructure")) // obligatory
        );

    //---------------------------------------------------------------------------
    // TOPOLOGY:

    // The NetElement type is derived from the RailTopoModel class PositioningNetElement.
    RailML3_IS_netElement_Type == 
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("netElement")), // obligatory
            length : REAL, // optional; -1.0 if not present

            // children:
            associatedPositioningSystem : FIN(RailML3_IS_associatedPositioningSystem_Type) // (1..*)
        );

        RailML3_IS_associatedPositioningSystem_Type ==
            struct(
                // integrated in parent: netElement
                xmlLineNumber : NATURAL1,

                // attributes:
                Id : FIN(allIdsOfType("associatedPositioningSystem")), // obligatory
                // positioningSystemRef : FIN(allIdsOfType("netElement")) // optional

                // children:
                intrinsicCoordinate : FIN(RailML3_intrinsicCoordinate_Type) // (1..*)
            );

            RailML3_intrinsicCoordinate_Type ==
                struct(
                    // integrated in parent: associatedPositioningSystem
                    xmlLineNumber : NATURAL1,

                    // attributes:
                    Id : FIN(allIdsOfType("intrinsicCoordinate")), // obligatory
                    intrinsicCoord : FIN(REAL) // obligatory
                );

    // The NetRelation type is derived from the RailTopoModel class PositionedRelation.
    RailML3_IS_netRelation_Type == 
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("netRelation")), // obligatory
            navigability : RailML3_IS_NET_RELATION_NAVIGABILITY, // optional; default: navigability_Both
            positionOnA : REAL, // optional; default: 1.0
            positionOnB : REAL, // optional; default: 0.0

            // children:
            elementA : FIN(allIdsOfType("netElement")), // (1..1)
            elementB : FIN(allIdsOfType("netElement")) // (1..1)
        );

    // The Network type is derived from the RailTopoModel class Network.
    RailML3_IS_network_Type == 
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("network")) // obligatory
        );

    RailML3_IS_level_Type == 
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("level")), // obligatory
            descriptionLevel : RailML3_IS_LEVEL_DESCRIPTIONLEVEL, // optional; default: Micro

            // children:
            networkResources : FIN(allIdsOfType("netElement") \/ allIdsOfType("netRelation")) // (0..*)
        );

    //---------------------------------------------------------------------------
    // FUNCTIONAL_INFRASTRUCTURE:

    RailML3_IS_balise_Type == 
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("balise")), // obligatory
            type : FIN(RailML3_IS_BALISE_TYPES), // optional            
            belongsToBaliseGroup : FIN(allIdsOfType("baliseGroup")), // optional
            distanceToPredecessorBaliseWithinGroup : FIN(REAL), // optional
            belongsToParent : FIN(allIdsOfType("balise")), // optional
            isBaliseGroup : BOOL, // optional, default: FALSE
            baliseGroupType : FIN(RailML3_IS_BALISE_GROUP_TYPES), // optional

            // children:
            isEurobalise : FIN(struct(positionInGroup : FIN(0..7), duplicate : FIN(RailML3_IS_EUROBALISE_DUPLICATE_TYPES), mVersion : FIN(NATURAL))) // (0..1)
        );

    RailML3_IS_baliseGroup_Type == 
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("baliseGroup")), // obligatory
            mileageDirection : FIN(RailML3_IS_MILEAGE_DIRECTIONS), // optional
            coverage : FIN(RailML3_IS_BALISE_GROUP_COVERAGES), // optional
            numberOfBalisesInGroup : FIN(NATURAL1), // optional

            // children:
            applicationTypes : FIN(RailML3_IS_BALISE_GROUP_APPLICATION_TYPES), // (1..*)
            connectedWithInfrastructureElement : FIN(struct(
                ref : FIN(union(allIdsOfType[{"signalIS", "etcsLevelTransition", "radioBlockCenterBorder", "switchIS", "bufferStop"}])),
                type : FIN(RailML3_IS_BALISE_GROUP_CONNECTION_TYPES))
            ), // (0..*)
            functionalType : FIN(struct(value : FIN(RailML3_IS_BALISE_GROUP_FUNCTIONAL_TYPES), mileageDirection : FIN(RailML3_IS_MILEAGE_DIRECTIONS))), // (0..*)
            isEurobaliseGroup : FIN(struct(countryID : FIN(INTEGER), groupID : FIN(INTEGER), usesPackage44 : FIN(INTEGER), virtualCoverageID : FIN(NATURAL), isLinked : BOOL,
                linkReactionNominal : FIN(RailML3_IS_BALISE_GROUP_LINK_REACTIONS), linkReactionReverse : FIN(RailML3_IS_BALISE_GROUP_LINK_REACTIONS), locationAccuracy : FIN(REAL), mVersion : FIN(NATURAL))) // (0..1)
        );

    // A border point is used to separate the railway network due to different reasons.
    // Typical examples are country borders, the change of owning infrastructure manager or the border of a station.
    RailML3_IS_border_Type == 
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("border")), // obligatory
            type : FIN(RailML3_IS_BORDER_TYPES), // obligatory
            isOpenEnd : BOOL, // optional; default: FALSE (by schema)
            externalRef : FIN(STRING) // optional
        );

    RailML3_IS_bufferStop_Type == 
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("bufferStop")), // obligatory
            type : FIN(RailML3_IS_BUFFERSTOP_TYPES) // optional
        );
    
    // A crossing is a place where two railway tracks intersect without the possibility to change from one track to another one (simple crossing)
    RailML3_IS_crossing_Type == 
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("crossing")), // obligatory
            straightBranch : FIN(RailML3_IS_switchISBranch_Type) // (0..2)
        );

    // Allows specifying devices used to prevent fouling (blocking or compromising) of a rail track (or collision with anything present on the track,
    // such as a person, or a train) by unauthorized movements of trains or unattended rolling stock.
    RailML3_IS_derailerIS_Type == 
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("derailerIS")), // obligatory
            derailSide : FIN(RailML3_IS_DERAIL_SIDES), // optional
            type : FIN(RailML3_IS_DERAILER_TYPES) // optional
        );

    // The OperationalPoint defines a point in the railway network that is essential for railway operation.
    // Typical examples for railway operational points are stations, block signals or stopping points. Operational points allow an interaction between the railway operator and the train driver.
    RailML3_IS_operationalPoint_Type == 
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("operationalPoint")) // obligatory
        );

    RailML3_IS_signalIS_Type == 
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("signalIS")), // obligatory
            isSwitchable : BOOL, // optional

            // children:
            isAnnouncementSignal : BOOL, // (0..1)
            // isCatenarySignal : FIN(...Type), // (0..1)
            isDangerSignal : BOOL, // (0..1)
            isEtcsSignal : BOOL, // (0..1)
            isInformationSignal : BOOL, // (0..1)
            // isLevelCrossingSignal : FIN(...Type), // (0..1)
            // isMilepost : FIN(...Type), // (0..1)
            // isSpeedSignal : FIN(struct(Signal_Type, BeginSpeedSection, EndSpeedSection)), // (0..1)
            // isStopPost : FIN(...Type), // (0..1)
            isTrainMovementSignal  : BOOL, // (0..1)
            // isTrainRadioSignal : FIN(...Type), // (0..1)
            isVehicleEquipmentSignal : BOOL, // (0..1)
            //protectedByBaliseGroups : FIN(RailML3_IS_BALISE_GROUP_IDS) // (0..*)
            signalConstruction : FIN(struct(xmlLineNumber:NATURAL1, height:FIN(REAL), positionAtTrack:FIN(RailML3_IS_SIGNAL_POSITION_AT_TRACK_TYPES), type:FIN(RailML3_IS_SIGNAL_TYPES))) // (0..1)
        );

    RailML3_IS_speedSection_Type == 
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("speedSection")), // obligatory
            maxSpeed : FIN(REAL), // optional
            isTemporary : BOOL, // optional, default: FALSE
            isSignalized : BOOL, // optional, default: TRUE
            refersToTrain : FIN(RailML3_IS_SPEED_SECTION_REFERS_TO_TRAIN_TYPES), // optional

            // children:
            validForSpeedProfiles : FIN(allIdsOfType("speedProfile")) // (0..*)
        );

    RailML3_IS_switchIS_Type == 
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("switchIS")), // obligatory
            type : FIN(RailML3_IS_SWITCH_TYPES), // optional
            continueCourse : FIN(RailML3_IS_SWITCH_COURSES), // optional
            branchCourse : FIN(RailML3_IS_SWITCH_COURSES), // optional

            // children:
            leftBranch : FIN(RailML3_IS_switchISBranch_Type), // (0..1)
            rightBranch : FIN(RailML3_IS_switchISBranch_Type), // (0..1)
            straightBranch : FIN(RailML3_IS_switchISBranch_Type), // (0..2)
            turningBranch : FIN(RailML3_IS_switchISBranch_Type) // (0..2)
        );

        // left branch of the switch as seen from switch begin (application direction) /
        // right branch of the switch as seen from switch begin (application direction) /
        // two branches describe the two possible drivable paths in a crossing /
        // only for switch crossings: turning branch
        RailML3_IS_switchISBranch_Type == 
            struct(
                // integrated in parent: switchIS
                recId : NATURAL1,
                pId : NATURAL1,
                xmlLineNumber : NATURAL1,

                // attributes:
                netRelationRef : FIN(allIdsOfType("netRelation")), // obligatory
                branchingSpeed : FIN(REAL), // optional
                joiningSpeed : FIN(REAL), // optional
                radius : FIN(REAL), // optional
                length : FIN(REAL) // optional
            );

    // A Track is defined by a railway section between two switches/crossings or between a switch/crossing and a buffer stop.
    RailML3_IS_track_Type == 
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("track")), // obligatory
            type : FIN(RailML3_IS_TRACK_TYPES), // obligatory until RML 3.2, then optional

            // children:
            trackBegin : FIN(union(allIdsOfType[{"border","bufferStop","crossing","switchIS"}])), // (0..1)
            trackEnd : FIN(union(allIdsOfType[{"border","bufferStop","crossing","switchIS"}])), // (0..1)
            lengths : FIN(REAL) // (0..*)
        );

    RailML3_IS_trainDetectionElement_Type == 
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("trainDetectionElement")), // obligatory
            type : FIN(RailML3_IS_TRAIN_DETECTION_ELEMENT_TYPES), // optional
            detectedObject : FIN(RailML3_IS_TRAIN_DETECTION_ELEMENT_DETECTED_OBJECTS), // optional

            // children:
            limitsTrainDetectionElement : FIN(allIdsOfType("trainDetectionElement")) // (0..2)
        );

    RailML3_IS_spotLocation_Type ==
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("spotLocation")), // obligatory
            netElementRef : FIN(allIdsOfType("netElement")), // obligatory
            intrinsicCoord : REAL, // optional, needed for switchIS in B!
            applicationDirection : RailML3_IS_DIRECTION, // optional
            pos : FIN(REAL), // optional

            // children:
            //linearCoordinate : FIN(RailML3_IS_linearCoordinate_Type), // (0..1)

            // additional entry for B (keep ID of parent):
            refersTo: dom(all_ids)
        );

    RailML3_IS_linearCoordinate_Type ==
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            positioningSystemRef : FIN(STRING), // IDS // obligatory
            measure : FIN(REAL), // obligatory

            // additional entry for B (keep ID of parent):
            refersTo: union(allIdsOfType[{"intrinsicCoordinate","linearLocation", "spotLocation"}])
        );

    RailML3_IS_linearLocation_Type ==
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("linearLocation")), // obligatory
            applicationDirection : RailML3_IS_DIRECTION, // optional

            // children:
            associatedNetElements : FIN(RailML3_IS_associatedNetElement_Type), // (1..*)

            // additional entry for B (keep ID of parent):
            refersTo: dom(all_ids)
        );
    
    RailML3_IS_associatedNetElement_Type ==
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            netElementRef : FIN(allIdsOfType("netElement")), // obligatory
            intrinsicCoordBegin : REAL, // optional
            intrinsicCoordEnd : REAL, // optional
            keepsOrientation: BOOL, // obligatory until RailML 3.2, then obsolete (?) discussion at https://www.railml.org/forum/index.php?t=msg&goto=3107
            sequence : FIN(NATURAL), // optional
            posBegin : FIN(REAL), // optional
            posEnd: FIN(REAL) // optional

            // children:
            // geometricCoordinateBegin (0..1), geometricCoordinateEnd (0..1), linearCoordinateBegin (0..1), linearCoordinateEnd (0..1)
        );

    //---------------------------------------------------------------------------
    // GEOMETRY:

    RailML3_IS_geometryPoint_Type ==
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("geometryPoint")), // obligatory
            radius : FIN(REAL), // optional
            gradient : FIN(REAL), // optional
            azimuth : FIN(REAL) // optional
        );

    RailML3_IS_gradientCurve_Type ==
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("gradientCurve")), // obligatory
            curveType : FIN(RailML3_IS_GRADIENT_CURVE_TYPES), // optional
            gradient : FIN(REAL), // optional
            deltaGradient : FIN(REAL), // optional
            radius : FIN(REAL), // optional
            length: FIN(REAL), // optional

            // children:
            beginsInGeometryPoint : FIN(allIdsOfType("geometryPoint")), // (0..1)
            endsInGeometryPoint : FIN(allIdsOfType("geometryPoint")) // (0..1)
        );

    RailML3_IS_horizontalCurve_Type ==
        struct(
            recId : NATURAL1,
            pId : NATURAL1,
            xmlLineNumber : NATURAL1,

            // attributes:
            Id : FIN(allIdsOfType("horizontalCurve")), // obligatory
            curveType : FIN(RailML3_IS_HORIZONTAL_CURVE_TYPES), // optional
            azimuth : FIN(REAL), // optional
            deltaAzimuth : FIN(REAL), // optional
            radius : FIN(REAL), // optional
            length: FIN(REAL), // optional

            // children:
            beginsInGeometryPoint : FIN(allIdsOfType("geometryPoint")), // (0..1)
            endsInGeometryPoint : FIN(allIdsOfType("geometryPoint")) // (0..1)
        );