DEFINITIONS
    // Definitions for VisB:
    VISB_SVG_UPDATES11 ==
        {i_e • i_e : RailML3_IS_SWITCH_IDS |
            rec(`id`: i_e^"_ellipse",
                stroke: IF i_e : dom(IS_switchsInMovement) THEN "darkorange" ELSIF i_e : dom(IL_switch_locked_routes) or IS_switch_keyLocked(i_e) = TRUE THEN "red" ELSE "black" END,
                fill: IF #i_r.(i_r : dom(IL_routes_in_res) & i_e : dom(RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)) & RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)(i_e) /<: IS_switch_states(i_e))
                        THEN "red"
                    ELSIF #i_r.(i_r : dom(IL_routes_in_res) & i_e : dom(RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)) & RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)(i_e) <: IS_switch_states(i_e))
                        THEN "green"
                    ELSE "black" END
            )
        };
    VISB_SVG_UPDATES12 ==
        {i_e • i_e : allIdsOfType("signalIS") |
            rec(`id`: i_e^"_ellipse",
                stroke: IF #i_r.(i_r : dom(IL_routes_in_res) & (i_e = prj1(RailML3_IL_ROUTE_ENTRY(i_r)) or i_e = prj1(RailML3_IL_ROUTE_EXIT(i_r)))) or i_e : dom(IL_signal_locked_by_signalplan) THEN "darkorange"
                    ELSIF i_e : IL_signal_locked THEN "red" ELSE "black" END,
                fill: IF aspect_closed : IL_signal_states(i_e) THEN "red"
                    ELSIF aspect_caution : IL_signal_states(i_e) THEN "yellow"
                    ELSE "green" END
            )
        };
    VISB_SVG_UPDATES13 ==
        {i_e • i_e : union(allIdsOfType[{"border","bufferStop","trainDetectionElement"}]) |
            rec(`id`: i_e^"_ellipse",
                visibility: IF #i_sig.( i_sig : allIdsOfType("signalIS") & RailML3_IS_SPOT_LOCATIONS(i_e) /\ RailML3_IS_SPOT_LOCATIONS(i_sig) /= {} ) THEN "hidden"
                    ELSE "visible" END
            )
        };
    VISB_SVG_UPDATES14 ==
        {i_e • i_e : allIdsOfType("derailerIS") |
            rec(`id`: i_e^"_ellipse",
                stroke: IF i_e : dom(IS_derailersInMovement) THEN "darkorange"
                    ELSIF i_e : dom(IL_derailer_locked_routes) or IS_derailer_keyLocked(i_e) = TRUE THEN "red"
                    ELSE "black" END,
                fill: IF prj2(IS_derailer_states(i_e)) = position_derailingPosition THEN "yellow"
                    ELSE "black" END
            )
        };// fill later for derailers in routes: ,  IF #i_r.(i_r : dom(IL_routes_in_res) & ((i_e : dom(RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)) & RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)(i_e) /<: IS_switch_states(i_e)) or #i_sw_il.(i_sw_il : dom(IS_switch_states(i_e)) & !branch.(branch : RailML3_IL_SWITCH_BRANCHES(i_e)(i_sw_il, IS_switch_states(i_e)(i_sw_il)) \/ RailML3_IL_SWITCH_BRANCHES(i_e)(i_sw_il, IS_switch_states(i_e)(i_sw_il))~ => branch /: RailML3_IL_ROUTE_NXT(i_r))) )) THEN "red" ELSIF #i_r.(i_r : dom(IL_routes_in_res) & i_e : dom(RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)) & RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)(i_e) <: IS_switch_states(i_e) & !i_sw_il.(i_sw_il : dom(IS_switch_states(i_e)) => #branch.(branch : RailML3_IL_SWITCH_BRANCHES(i_e)(i_sw_il, IS_switch_states(i_e)(i_sw_il)) \/ RailML3_IL_SWITCH_BRANCHES(i_e)(i_sw_il, IS_switch_states(i_e)(i_sw_il))~ & branch : RailML3_IL_ROUTE_NXT(i_r))) ) THEN "green" ELSE "black" END)});
    VISB_SVG_UPDATES15 ==
        {i_e • i_e : allIdsOfType("crossing") |
            rec(`id`: i_e^"_ellipse",
                stroke: IF i_e : dom(IS_crossingsInMovement) THEN "darkorange"
                    ELSIF i_e : dom(IL_crossing_locked_routes) or IS_crossing_keyLocked(i_e) = TRUE THEN "red"
                    ELSE "black" END
            )
        };// fill later for crossings in routes: ,  IF #i_r.(i_r : dom(IL_routes_in_res) & ((i_e : dom(RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)) & RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)(i_e) /<: IS_switch_states(i_e)) or #i_sw_il.(i_sw_il : dom(IS_switch_states(i_e)) & !branch.(branch : RailML3_IL_SWITCH_BRANCHES(i_e)(i_sw_il, IS_switch_states(i_e)(i_sw_il)) \/ RailML3_IL_SWITCH_BRANCHES(i_e)(i_sw_il, IS_switch_states(i_e)(i_sw_il))~ => branch /: RailML3_IL_ROUTE_NXT(i_r))) )) THEN "red" ELSIF #i_r.(i_r : dom(IL_routes_in_res) & i_e : dom(RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)) & RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)(i_e) <: IS_switch_states(i_e) & !i_sw_il.(i_sw_il : dom(IS_switch_states(i_e)) => #branch.(branch : RailML3_IL_SWITCH_BRANCHES(i_e)(i_sw_il, IS_switch_states(i_e)(i_sw_il)) \/ RailML3_IL_SWITCH_BRANCHES(i_e)(i_sw_il, IS_switch_states(i_e)(i_sw_il))~ & branch : RailML3_IL_ROUTE_NXT(i_r))) ) THEN "green" ELSE "black" END)});
    
    // free:
    VISB_SVG_UPDATES21 == 
        {i_e • i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |
            rec(`id`: i_e^"_lg_free_1",
                offset: IF #np.(np : ignoreDirection((union(ran(RailML3_IS_CROSSING_BRANCHES)) \/ union(ran(RailML3_IS_SWITCH_BRANCHES))) /\ IS_next) & prj1(prj2(np)) = i_e & prj2(prj2(np)) = 0.0) THEN "20%"
                    ELSE "0%" END
            )
        };
    VISB_SVG_UPDATES22 ==
        {i_e • i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |
            rec(`id`: i_e^"_lg_free_2",
                offset: IF #np.(np : ignoreDirection((union(ran(RailML3_IS_CROSSING_BRANCHES)) \/ union(ran(RailML3_IS_SWITCH_BRANCHES))) /\ IS_next) & prj1(prj2(np)) = i_e & prj2(prj2(np)) = 0.0) THEN "20%"
                    ELSE "0%" END
            )
        };
    VISB_SVG_UPDATES23 ==
        {i_e • i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |
            rec(`id`: i_e^"_lg_free_3",
                offset: IF #np.(np : ignoreDirection((union(ran(RailML3_IS_CROSSING_BRANCHES)) \/ union(ran(RailML3_IS_SWITCH_BRANCHES))) /\ IS_next) & prj1(prj2(np)) = i_e & prj2(prj2(np)) = 1.0) THEN "80%"
                    ELSE "100%" END
            )
        };
    VISB_SVG_UPDATES24 ==
        {i_e • i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |
            rec(`id`: i_e^"_lg_free_4",
                offset: IF #np.(np : ignoreDirection((union(ran(RailML3_IS_CROSSING_BRANCHES)) \/ union(ran(RailML3_IS_SWITCH_BRANCHES))) /\ IS_next) & prj1(prj2(np)) = i_e & prj2(prj2(np)) = 1.0) THEN "80%"
                    ELSE "100%" END
            )
        };
    
    // TVD sections:
    VISB_SVG_UPDATES31 ==
        UNION(i_e, route_tvd, occ_tvd).(i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL
            & route_tvd = { a | #(b, i_t, i_r).( i_r : dom(IL_routes_in_res) /\ dom(RailML3_IL_ROUTE_TVD_SECTIONS) & i_t : RailML3_IL_ROUTE_TVD_SECTIONS(i_r) & b : dom(dom(RailML3_IL_TVD_SECTIONS(i_t))) & prj1(b) = i_e & a = prj2(b) ) }
            & occ_tvd = { a | #(b, i_t).( i_t : dom(IL_occupiedTvdSections) & b : dom(dom(RailML3_IL_TVD_SECTIONS(i_t))) & prj1(b) = i_e & a = prj2(b) ) } |
                {rec(`id`: i_e^"_lg_tvd_1",
                    offset: IF occ_tvd /= {} THEN TO_STRING(min(occ_tvd)*100.0)^"%" ELSIF route_tvd /= {} THEN TO_STRING(min(route_tvd)*100.0)^"%" ELSE "0%" END
                ), rec(`id`: i_e^"_lg_tvd_2",
                    offset: IF occ_tvd /= {} THEN TO_STRING(min(occ_tvd)*100.0)^"%" ELSIF route_tvd /= {} THEN TO_STRING(min(route_tvd)*100.0)^"%" ELSE "0%" END
                ), rec(`id`: i_e^"_lg_tvd_3",
                    offset: IF occ_tvd /= {} THEN TO_STRING(max(occ_tvd)*100.0)^"%" ELSIF route_tvd /= {} THEN TO_STRING(max(route_tvd)*100.0)^"%" ELSE "100%" END
                ), rec(`id`: i_e^"_lg_tvd_4",
                    offset: IF occ_tvd /= {} THEN TO_STRING(max(occ_tvd)*100.0)^"%" ELSIF route_tvd /= {} THEN TO_STRING(max(route_tvd)*100.0)^"%" ELSE "100%" END
                )}
        );
    VISB_SVG_UPDATES32 ==
        {i_e • i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |
            rec(`id`: i_e^"_tvd_blink",
                values: IF #(i_r, i_t).(i_r : dom(IL_routes_in_res) /\ dom(RailML3_IL_ROUTE_TVD_SECTIONS) & i_t : RailML3_IL_ROUTE_TVD_SECTIONS(i_r) & i_e : dom(dom(dom(RailML3_IL_TVD_SECTIONS(i_t))))) THEN "1;0.2;1"
                    ELSE "1" END
            )
        };
    VISB_SVG_UPDATES33 ==
        {i_e • i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |
            rec(`id`: i_e^"_tvd",
                visibility: IF #i_t.(i_t : dom(IL_occupiedTvdSections) & i_e : dom(dom(dom(RailML3_IL_TVD_SECTIONS(i_t))))) or (#(i_r, i_t).(i_r : dom(IL_routes_in_res) /\ dom(RailML3_IL_ROUTE_TVD_SECTIONS) & i_t : RailML3_IL_ROUTE_TVD_SECTIONS(i_r) & i_e : dom(dom(dom(RailML3_IL_TVD_SECTIONS(i_t)))))) THEN "visible"
                    ELSE "hidden" END
            )
        };
    
    // reservation:
    VISB_SVG_UPDATES41 ==
        UNION(i_e, coord).( i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL
            & coord = {a | #(i_r, NXT, nxt).(i_r : dom(IL_routes_in_res) \/ dom(IL_res_routes)
                & NXT = RailML3_IL_ROUTE_NXT(i_r) - union(union(RailML3_IL_ROUTE_RELEASE_GROUP_AHEAD_NXT[union(IL_released_partialRoutes[{i_r}])] \/ RailML3_IL_ROUTE_RELEASE_GROUP_REAR_NXT[union(IL_released_partialRoutes[{i_r}])])[{i_r}]) & nxt : dom(NXT) \/ ran(NXT) & i_e = prj1(prj1(nxt)) & a = prj2(prj1(nxt))) } |
                    {
                        rec(`id`:i_e^"_lg_res_1", offset: IF coord /= {} THEN TO_STRING(min(coord)*100.0)^"%" ELSE "0%" END),
                        rec(`id`:i_e^"_lg_res_2", offset: IF coord /= {} THEN TO_STRING(min(coord)*100.0)^"%" ELSE "0%" END),
                        rec(`id`:i_e^"_lg_res_3", offset: IF coord /= {} THEN TO_STRING(max(coord)*100.0)^"%" ELSE "100%" END),
                        rec(`id`:i_e^"_lg_res_4", offset: IF coord /= {} THEN TO_STRING(max(coord)*100.0)^"%" ELSE "100%" END)
                    }
        );
    VISB_SVG_UPDATES42 ==
        {i_e • i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |
            rec(`id`:i_e^"_res_blink",
                values: IF #i_r.(i_r : RailML3_IL_ROUTE_IDS & i_e : dom(dom(dom(RailML3_IL_ROUTE_NXT(i_r)) \/ ran(RailML3_IL_ROUTE_NXT(i_r)))) & i_r : dom(IL_routes_in_res)) THEN "1;0.2;1"
                    ELSE "1" END
            )
        };
    VISB_SVG_UPDATES43 ==
        {i_e • i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |
            rec(`id`:i_e^"_res",
                visibility: IF #(i_r, NXT).(i_r : RailML3_IL_ROUTE_IDS & NXT = RailML3_IL_ROUTE_NXT(i_r) - union(union(RailML3_IL_ROUTE_RELEASE_GROUP_AHEAD_NXT[union(IL_released_partialRoutes[{i_r}])] \/ RailML3_IL_ROUTE_RELEASE_GROUP_REAR_NXT[union(IL_released_partialRoutes[{i_r}])])[{i_r}])
                        & i_e : dom(dom(dom(NXT) \/ ran(NXT))) & (i_r : dom(IL_routes_in_res) or i_r : dom(IL_res_routes))) THEN "visible"
                    ELSE "hidden" END
            )
        };
    
    // overlaps:
    VISB_SVG_UPDATES51 ==
        UNION(i_e, coord).( i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL
            & coord = {a | #(i_o, NXT, nxt).(i_o : dom(IL_res_overlaps) & NXT = RailML3_IL_OVERLAP_NXT(i_o) & nxt : dom(dom(NXT) \/ ran(NXT)) & i_e = prj1(nxt) & a = prj2(nxt)) } |
                {
                    rec(`id`:i_e^"_lg_ovl_1", offset: IF coord /= {} THEN TO_STRING(min(coord)*100.0)^"%" ELSE "0%" END),
                    rec(`id`:i_e^"_lg_ovl_2", offset: IF coord /= {} THEN TO_STRING(min(coord)*100.0)^"%" ELSE "0%" END),
                    rec(`id`:i_e^"_lg_ovl_3", offset: IF coord /= {} THEN TO_STRING(max(coord)*100.0)^"%" ELSE "100%" END),
                    rec(`id`:i_e^"_lg_ovl_4", offset: IF coord /= {} THEN TO_STRING(max(coord)*100.0)^"%" ELSE "100%" END)
                }
        );
    //VISB_SVG_UPDATES65 == UNION(i_e).( i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |{rec(`id`:i_e^"_res_blink",  values: IF #i_r.(i_r : RailML3_IL_ROUTE_IDS & i_e : dom(dom(RailML3_IL_ROUTE_NXT(i_r))) \/ dom(ran(RailML3_IL_ROUTE_NXT(i_r))) & i_r : dom(IL_routes_in_res)) THEN "1;0.2;1" ELSE "1" END)});
    VISB_SVG_UPDATES52 == UNION(i_e).( i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |{rec(`id`:i_e^"_ovl", visibility: IF #(i_o, NXT).(i_o : dom(IL_res_overlaps) & NXT = RailML3_IL_OVERLAP_NXT(i_o) & i_e : dom(dom(dom(NXT) \/ ran(NXT))) ) THEN "visible" ELSE "hidden" END)});
    
    // occupation:
    VISB_SVG_UPDATES61 ==
        UNION(i_e, t).( i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL & t : RS_arrivedTrains & (i_e = prj1(prj1(RS_trainFront(t))) or i_e = prj1(prj1(RS_trainBack(t)))) |
            {
                rec(`id`:i_e^"_lg_occ_1",
                    offset: IF i_e = prj1(prj1(RS_trainFront(t))) & prj2(RS_trainFront(t)) = direction_reverse THEN TO_STRING(prj2(prj1(RS_trainFront(t)))*100.0)^"%"
                        ELSIF i_e = prj1(prj1(RS_trainBack(t))) & prj2(RS_trainBack(t)) = direction_normal THEN TO_STRING(prj2(prj1(RS_trainBack(t)))*100.0)^"%"
                        ELSE "0%" END),
                rec(`id`:i_e^"_lg_occ_2",
                    offset: IF i_e = prj1(prj1(RS_trainFront(t))) & prj2(RS_trainFront(t)) = direction_reverse THEN TO_STRING(prj2(prj1(RS_trainFront(t)))*100.0)^"%"
                        ELSIF i_e = prj1(prj1(RS_trainBack(t))) & prj2(RS_trainBack(t)) = direction_normal THEN TO_STRING(prj2(prj1(RS_trainBack(t)))*100.0)^"%"
                        ELSE "0%" END),
                rec(`id`:i_e^"_lg_occ_3",
                    offset: IF i_e = prj1(prj1(RS_trainFront(t))) & prj2(RS_trainFront(t)) = direction_normal THEN TO_STRING(prj2(prj1(RS_trainFront(t)))*100.0)^"%"
                        ELSIF i_e = prj1(prj1(RS_trainBack(t))) & prj2(RS_trainBack(t)) = direction_reverse THEN TO_STRING(prj2(prj1(RS_trainBack(t)))*100.0)^"%"
                        ELSE "100%" END),
                rec(`id`:i_e^"_lg_occ_4",
                    offset: IF i_e = prj1(prj1(RS_trainFront(t))) & prj2(RS_trainFront(t)) = direction_normal THEN TO_STRING(prj2(prj1(RS_trainFront(t)))*100.0)^"%"
                        ELSIF i_e = prj1(prj1(RS_trainBack(t))) & prj2(RS_trainBack(t)) = direction_reverse THEN TO_STRING(prj2(prj1(RS_trainBack(t)))*100.0)^"%"
                        ELSE "100%" END)
            }
        );
    VISB_SVG_UPDATES62 ==
        {i_e • i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |
            rec(`id`:i_e^"_occ",
                visibility: IF i_e : dom(dom(ran(RS_trainFront) \/ ran(RS_trainBack))) or #t.(t : RS_arrivedTrains & i_e : dom(RS_trainOccupiedBlocks(t)) ) THEN "visible"
                    ELSE "hidden" END
            )
        };

    VISB_SVG_EVENTS11 == {x•x:allIdsOfType("switchIS") | rec(`id`: x, event: "IS_startChangeSwitch", predicate: ('''(#(i_sw_il1, i_sw_il2).(RailML3_IS_SWITCH_TYPE(SwitchId) = switch_doubleSwitchCrossing
        & [i_sw_il1, i_sw_il2] = SORT(dom(IS_switch_states(\"'''^x^'''\"))) & ( ( CurrState(i_sw_il1) = position_left & CurrState(i_sw_il2) = position_left & DestState(i_sw_il1) = position_left & DestState(i_sw_il2) = position_right )
            or ( CurrState(i_sw_il1) = position_left & CurrState(i_sw_il2) = position_right & DestState(i_sw_il1) = position_right & DestState(i_sw_il2) = position_left )
            or ( CurrState(i_sw_il1) = position_right & CurrState(i_sw_il2) = position_left & DestState(i_sw_il1) = position_right & DestState(i_sw_il2) = position_right )
            or ( CurrState(i_sw_il1) = position_right & CurrState(i_sw_il2) = position_right & DestState(i_sw_il1) = position_left & DestState(i_sw_il2) = position_left ) ) )
        or (RailML3_IS_SWITCH_TYPE(SwitchId) /= switch_doubleSwitchCrossing))
        & SwitchId = ''', "\""^x^"\"") )}; // includes switchCrossingsParts, but they should not have an ID in the SVG    
    VISB_SVG_EVENTS12 == {x•x:allIdsOfType("switchIS") | rec(`id`: x, event: "IS_endChangeSwitch", predicate: ("SwitchId=","\""^x^"\"") )};
    VISB_SVG_EVENTS13 == {x•x:allIdsOfType("switchIS") | rec(`id`: x, event: "IS_startChangeCoupledSwitches", predicate: "SwitchId1=\"x\" or SwitchId2=\"x\"" )};
    VISB_SVG_HOVERS1 == {x•x:allIdsOfType("switchIS") | rec(`id`: x^"_ellipse", `stroke-width`: "1.5" )};

    VISB_SVG_EVENTS21 == {x•x:allIdsOfType("derailerIS") | rec(`id`: x, event: "IS_startChangeDerailer", predicate: ("DerailerId=","\""^x^"\"") )};
    VISB_SVG_EVENTS22 == {x•x:allIdsOfType("derailerIS") | rec(`id`: x, event: "IS_endChangeDerailer", predicate: ("DerailerId=","\""^x^"\"") )};
    VISB_SVG_HOVERS2 == {x•x:allIdsOfType("derailerIS") | rec(`id`: x^"_ellipse", `stroke-width`: "1.5" )};

    VISB_SVG_EVENTS31 == {x•x:allIdsOfType("crossing") | rec(`id`: x, event: "IS_startChangeCrossing", predicate: ("CrossingId=","\""^x^"\"") )};
    VISB_SVG_EVENTS32 == {x•x:allIdsOfType("crossing") | rec(`id`: x, event: "IS_endChangeCrossing", predicate: ("CrossingId=","\""^x^"\"") )};
    VISB_SVG_HOVERS3 == {x•x:allIdsOfType("crossing") | rec(`id`: x^"_ellipse", `stroke-width`: "1.5" )};

    VISB_SVG_EVENTS41 == {x•x:allIdsOfType("signalIS") | rec(`id`: x, event: "IL_noteChangeSignalState", predicate: ("SignalId=","\""^x^"\"") )};
    VISB_SVG_HOVERS4 == {x•x:allIdsOfType("signalIS") | rec(`id`: x^"_ellipse", `stroke-width`: "1.5" )};

    //VISB_SVG_EVENTS51 == {x•x:RailML3_IS_OPENEND_IDS | rec(`id`: x, event: "RS_trainArrive" )}; // pred : position fits OE
    //VISB_SVG_EVENTS52 == {x•x:RailML3_IS_OPENEND_IDS | rec(`id`: x, event: "RS_trainLeave" )};
    //VISB_SVG_HOVERS5 == {x•x:RailML3_IS_OPENEND_IDS | rec(`id`: x^"_ellipse", `stroke-width`: "1.5" )};

    ignoreDirection(Relation) == dom({ r, cr | cr : Relation & r = prj1(prj1(cr)) |-> prj1(prj2(cr)) });
    inverseDirectedRelation(Relation) == dom({ ir, r | r : Relation & ir = prj1(prj2(r)) |-> oppositeDirection(prj2(prj2(r))) |-> (prj1(prj1(r)) |-> oppositeDirection(prj2(prj1(r)))) });
    inverseDirectedPair(Pair) == prj1(Pair) |-> oppositeDirection(prj2(Pair));
    inverseSwitchPosition(pos) == IF pos = position_left THEN position_right ELSE position_left END;
    oppositeDirection(dir) == IF dir = direction_normal THEN direction_reverse ELSE direction_normal END;

    elementOfId(Set, eId) == MU( { e | e : Set & eId = MU(e'Id)} );

    //GOAL == EBO_CheckSwitchSpeeds = "SUCCESS" & ValidateTrackLengths = "SUCCESS";
    SET_PREF_ALLOW_OPERATION_CALLS_IN_EXPRESSIONS == TRUE;
    "CHOOSE.def";
    "LibraryIO.def";
    "LibraryMath.def";
    "LibraryReals.def";
	"LibraryStrings.def";
    "SORT.def";