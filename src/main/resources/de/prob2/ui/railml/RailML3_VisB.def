DEFINITIONS
    // Definitions for VisB:
    VISB_SVG_UPDATES10 ==
        {i_e • i_e : allIdsOfType("crossing") |
            rec(`id`: i_e^"_ellipse",
                stroke: IF i_e : dom(IS_crossingsInMovement) THEN "darkorange"
                    ELSIF i_e : dom(IL_crossing_locked_routes) or IS_crossing_keyLocked(i_e) = TRUE THEN "red"
                    ELSE "black" END,
                fill: IF #i_r.(i_r : dom(IL_routes_in_res) & i_r : dom(RailML3_IL_ROUTE_CROSSING_POSITIONS) & i_e : dom(RailML3_IL_ROUTE_CROSSING_POSITIONS(i_r)) & (RailML3_IL_ROUTE_CROSSING_POSITIONS(i_r)(i_e) /= IS_crossing_states(i_e) or i_e : dom(IS_crossingsInMovement)))
                        or #i_o.(i_o : dom(IL_res_overlaps) & i_o : dom(RailML3_IL_OVERLAP_CROSSING_POSITIONS) & i_e : dom(RailML3_IL_OVERLAP_CROSSING_POSITIONS(i_o)) & (RailML3_IL_OVERLAP_CROSSING_POSITIONS(i_o)(i_e) /= IS_crossing_states(i_e) or i_e : dom(IS_crossingsInMovement)))
                        THEN "red"
                    ELSIF !i_r.(i_r : dom(IL_routes_in_res) & i_r : dom(RailML3_IL_ROUTE_CROSSING_POSITIONS) & i_e : dom(RailML3_IL_ROUTE_CROSSING_POSITIONS(i_r)) => RailML3_IL_ROUTE_CROSSING_POSITIONS(i_r)(i_e) = IS_crossing_states(i_e))
                        & !(i_o, i_r).(i_o : dom(IL_res_overlaps) /\ dom(RailML3_IL_OVERLAP_CROSSING_POSITIONS) & i_r : dom(IL_routes_in_res) /\ dom(RailML3_IL_ROUTE_OVERLAPS) & i_o : RailML3_IL_ROUTE_OVERLAPS(i_r) & i_e : dom(RailML3_IL_OVERLAP_CROSSING_POSITIONS(i_o)) => RailML3_IL_OVERLAP_CROSSING_POSITIONS(i_o)(i_e) = IS_crossing_states(i_e))
                        & ( #i_r.(i_r : dom(IL_routes_in_res) & i_r : dom(RailML3_IL_ROUTE_CROSSING_POSITIONS) & i_e : dom(RailML3_IL_ROUTE_CROSSING_POSITIONS(i_r)))
                        or #(i_o, i_r).(i_o : dom(IL_res_overlaps) /\ dom(RailML3_IL_OVERLAP_CROSSING_POSITIONS) & i_r : dom(IL_routes_in_res) /\ dom(RailML3_IL_ROUTE_OVERLAPS) & i_o : RailML3_IL_ROUTE_OVERLAPS(i_r) & i_e : dom(RailML3_IL_OVERLAP_CROSSING_POSITIONS(i_o))) )
                        THEN "green"
                    ELSE "black" END
            )
        };
    VISB_SVG_UPDATES11 ==
        {i_e • i_e : allIdsOfType("crossing") |
            rec(`id`: i_e^"_title",
                text: FORMAT_TO_STRING("~w\nState: ~w", [i_e, TO_STRING(IS_crossing_states(i_e))])
            )
        };
    VISB_SVG_UPDATES12 ==
        {i_e • i_e : allIdsOfType("derailerIS") |
            rec(`id`: i_e^"_ellipse",
                stroke: IF i_e : dom(IS_derailersInMovement) THEN "darkorange"
                    ELSIF i_e : dom(IL_derailer_locked_routes) or IS_derailer_keyLocked(i_e) = TRUE THEN "red"
                    ELSE "black" END,
                fill: IF prj2(IS_derailer_states(i_e)) = position_derailingPosition THEN "yellow"
                    ELSE "black" END
            )
        };
    VISB_SVG_UPDATES13 ==
        {i_e • i_e : allIdsOfType("derailerIS") |
            rec(`id`: i_e^"_title",
                text: FORMAT_TO_STRING("~w\nState: ~w", [i_e, TO_STRING(IS_derailer_states(i_e))])
            )
        };
    VISB_SVG_UPDATES14 ==
        {i_e • i_e : RailML3_IS_SWITCH_IDS |
            rec(`id`: i_e^"_ellipse",
                stroke: IF i_e : dom(IS_switchesInMovement) THEN "darkorange" ELSIF i_e : dom(IL_switch_locked_routes) or IS_switch_keyLocked(i_e) = TRUE THEN "red" ELSE "black" END,
                fill: IF #i_r.(i_r : dom(IL_routes_in_res) /\ dom(RailML3_IL_ROUTE_SWITCH_POSITIONS) & i_e : dom(RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)) & (RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)(i_e) /<: IS_switch_states(i_e) or i_e : dom(IS_switchesInMovement)))
                        or #i_o.(i_o : dom(IL_res_overlaps) /\ dom(RailML3_IL_OVERLAP_SWITCH_POSITIONS) & i_e : dom(RailML3_IL_OVERLAP_SWITCH_POSITIONS(i_o)) & (RailML3_IL_OVERLAP_SWITCH_POSITIONS(i_o)(i_e) /<: IS_switch_states(i_e) or i_e : dom(IS_switchesInMovement)))
                        THEN "red"
                    ELSIF !i_r.(i_r : dom(IL_routes_in_res) & i_r : dom(RailML3_IL_ROUTE_SWITCH_POSITIONS) & i_e : dom(RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)) => RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)(i_e) <: IS_switch_states(i_e))
                        & !(i_o, i_r).(i_o : dom(IL_res_overlaps) /\ dom(RailML3_IL_OVERLAP_SWITCH_POSITIONS) & i_r : dom(IL_routes_in_res) /\ dom(RailML3_IL_ROUTE_OVERLAPS) & i_o : RailML3_IL_ROUTE_OVERLAPS(i_r) & i_e : dom(RailML3_IL_OVERLAP_SWITCH_POSITIONS(i_o)) => RailML3_IL_OVERLAP_SWITCH_POSITIONS(i_o)(i_e) <: IS_switch_states(i_e))
                        & ( #i_r.(i_r : dom(IL_routes_in_res) & i_r : dom(RailML3_IL_ROUTE_SWITCH_POSITIONS) & i_e : dom(RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)))
                        or #(i_o, i_r).(i_o : dom(IL_res_overlaps) /\ dom(RailML3_IL_OVERLAP_SWITCH_POSITIONS) & i_r : dom(IL_routes_in_res) /\ dom(RailML3_IL_ROUTE_OVERLAPS) & i_o : RailML3_IL_ROUTE_OVERLAPS(i_r) & i_e : dom(RailML3_IL_OVERLAP_SWITCH_POSITIONS(i_o))) )
                        THEN "green"
                    ELSE "black" END
            )
        };
    VISB_SVG_UPDATES15 ==
        {i_e • i_e : RailML3_IS_SWITCH_IDS |
            rec(`id`: i_e^"_title",
                text: FORMAT_TO_STRING("~w (~w)\nState: ~w", [i_e, STRING_SPLIT(TO_STRING(RailML3_IS_SWITCH_TYPE(i_e)), "_")(2), TO_STRING(IS_switch_states(i_e))])
            )
        };
    VISB_SVG_UPDATES16 ==
        {i_e • i_e : RailML3_IL_SIGNAL_CONTROLLED |
            rec(`id`: i_e^"_ellipse",
                stroke: IF #i_r.(i_r : dom(IL_routes_in_res) & (i_e = prj1(RailML3_IL_ROUTE_ENTRY(i_r)) or i_e = prj1(RailML3_IL_ROUTE_EXIT(i_r)))) or i_e : IL_signal_locked THEN "darkorange"
                    ELSE "black" END,
                fill: IF aspect_closed : IL_signal_states(i_e) THEN "red"
                    ELSIF aspect_caution : IL_signal_states(i_e) THEN "yellow"
                    ELSE "green" END
            )
        };
    VISB_SVG_UPDATES17 ==
        {i_e • i_e : RailML3_IL_SIGNAL_CONTROLLED |
            rec(`id`: i_e^"_title",
                text: FORMAT_TO_STRING("~w\nAspect: ~w", [i_e, TO_STRING(IL_signal_states(i_e))])
            )
        };
    VISB_SVG_UPDATES18 ==
        {i_e • i_e : union(allIdsOfType[{"balise","border","bufferStop","levelCrossingIS","trainDetectionElement"}]) |
            rec(`id`: i_e^"_ellipse",
                visibility: IF #i_sig.( i_sig : RailML3_IL_SIGNAL_CONTROLLED & RailML3_IS_SPOT_LOCATIONS(i_e) /\ RailML3_IS_SPOT_LOCATIONS(i_sig) /= {} ) THEN "hidden" ELSE "visible" END
            )
        };
    
    
    // free:
    VISB_SVG_UPDATES20 == 
        UNION(i_e).(i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |
            {rec(`id`: i_e^"_lg_free_1",
                offset: IF #np.(np : ignoreDirection((union(ran(RailML3_IS_CROSSING_BRANCHES)) \/ union(ran(RailML3_IS_SWITCH_BRANCHES))) /\ IS_next) & prj1(prj2(np)) = i_e & prj2(prj2(np)) = 0.0) THEN "20%"
                    ELSE "0%" END
            ), rec(`id`: i_e^"_lg_free_2",
                offset: IF #np.(np : ignoreDirection((union(ran(RailML3_IS_CROSSING_BRANCHES)) \/ union(ran(RailML3_IS_SWITCH_BRANCHES))) /\ IS_next) & prj1(prj2(np)) = i_e & prj2(prj2(np)) = 0.0) THEN "20%"
                    ELSE "0%" END
            ), rec(`id`: i_e^"_lg_free_3",
                offset: IF #np.(np : ignoreDirection((union(ran(RailML3_IS_CROSSING_BRANCHES)) \/ union(ran(RailML3_IS_SWITCH_BRANCHES))) /\ IS_next) & prj1(prj2(np)) = i_e & prj2(prj2(np)) = 1.0) THEN "80%"
                    ELSE "100%" END
            ), rec(`id`: i_e^"_lg_free_4",
                offset: IF #np.(np : ignoreDirection((union(ran(RailML3_IS_CROSSING_BRANCHES)) \/ union(ran(RailML3_IS_SWITCH_BRANCHES))) /\ IS_next) & prj1(prj2(np)) = i_e & prj2(prj2(np)) = 1.0) THEN "80%"
                    ELSE "100%" END
            )}
        );
    
    // TVD sections:
    VISB_SVG_UPDATES30 ==
        UNION(i_e, route_tvd, occ_tvd).(i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL
            & route_tvd = { a | #(b, i_t, i_r).( i_r : dom(IL_routes_in_res \/ IL_res_routes) /\ dom(RailML3_IL_ROUTE_TVD_SECTIONS) & i_t : RailML3_IL_ROUTE_TVD_SECTIONS(i_r) & b : dom(dom(RailML3_IL_TVD_SECTIONS(i_t))) & prj1(b) = i_e & a = prj2(b) ) }
            & occ_tvd = { a | #(b, i_t).( i_t : dom(IL_occupiedTvdSections) & b : dom(dom(RailML3_IL_TVD_SECTIONS(i_t))) & prj1(b) = i_e & a = prj2(b) ) } |
                {rec(`id`: i_e^"_lg_tvd_1",
                    offset: IF occ_tvd /= {} THEN TO_STRING(min(occ_tvd)*100.0)^"%" ELSIF route_tvd /= {} THEN TO_STRING(min(route_tvd)*100.0)^"%" ELSE "0%" END
                ), rec(`id`: i_e^"_lg_tvd_2",
                    offset: IF occ_tvd /= {} THEN TO_STRING(min(occ_tvd)*100.0)^"%" ELSIF route_tvd /= {} THEN TO_STRING(min(route_tvd)*100.0)^"%" ELSE "0%" END
                ), rec(`id`: i_e^"_lg_tvd_3",
                    offset: IF occ_tvd /= {} THEN TO_STRING(max(occ_tvd)*100.0)^"%" ELSIF route_tvd /= {} THEN TO_STRING(max(route_tvd)*100.0)^"%" ELSE "100%" END
                ), rec(`id`: i_e^"_lg_tvd_4",
                    offset: IF occ_tvd /= {} THEN TO_STRING(max(occ_tvd)*100.0)^"%" ELSIF route_tvd /= {} THEN TO_STRING(max(route_tvd)*100.0)^"%" ELSE "100%" END
                )}
        );
    VISB_SVG_UPDATES31 ==
        {i_e • i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |
            rec(`id`: i_e^"_tvd_blink",
                values: IF #(i_r, i_t).(i_r : dom(IL_routes_in_res \/ IL_res_routes) /\ dom(RailML3_IL_ROUTE_TVD_SECTIONS) & i_t : RailML3_IL_ROUTE_TVD_SECTIONS(i_r) & i_e : dom(dom(dom(RailML3_IL_TVD_SECTIONS(i_t)))) & i_t /: dom(IL_occupiedTvdSections))
                    or #(i_o, i_t).(i_o : dom(IL_res_overlaps) /\ dom(RailML3_IL_OVERLAP_TVD_SECTIONS)
                        & i_t : RailML3_IL_OVERLAP_TVD_SECTIONS(i_o)
                        & i_e : dom(dom(dom(RailML3_IL_TVD_SECTIONS(i_t))))
                        & i_t /: dom(IL_occupiedTvdSections))
                    THEN "1;0.2;1" ELSE "1" END
            )
        };
    VISB_SVG_UPDATES32 ==
        {i_e • i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |
            rec(`id`: i_e^"_tvd",
                visibility: IF #i_t.(i_t : dom(IL_occupiedTvdSections) & i_e : dom(dom(dom(RailML3_IL_TVD_SECTIONS(i_t)))))
                    or #(i_r, i_t).(i_r : dom(IL_routes_in_res \/ IL_res_routes) /\ dom(RailML3_IL_ROUTE_TVD_SECTIONS)
                        & i_t : RailML3_IL_ROUTE_TVD_SECTIONS(i_r) - ( union(RailML3_IL_ROUTE_RELEASE_GROUPS_AHEAD_TVD_SECTIONS[union(IL_released_partialRoutes[{i_r}])]) \/ union(RailML3_IL_ROUTE_RELEASE_GROUPS_REAR_TVD_SECTIONS[union(IL_released_partialRoutes[{i_r}])]) )
                        & i_e : dom(dom(dom(RailML3_IL_TVD_SECTIONS(i_t)))))
                    or #(i_o, i_t).(i_o : dom(IL_res_overlaps) /\ dom(RailML3_IL_OVERLAP_TVD_SECTIONS)
                        & i_t : RailML3_IL_OVERLAP_TVD_SECTIONS(i_o)
                        & i_e : dom(dom(dom(RailML3_IL_TVD_SECTIONS(i_t)))))                   
                    THEN "visible" ELSE "hidden" END
            )
        };
    VISB_SVG_UPDATES33 ==
        {i_e • i_e : allIdsOfType("tvdSection") |
            rec(`id`: i_e^"_title",
                text: IF i_e : dom(IL_occupiedTvdSections) THEN FORMAT_TO_STRING("~w ~w", [i_e, TO_STRING(IL_occupiedTvdSections[{i_e}])])
                    ELSE i_e END
            )
        };
    
    // reservation:
    VISB_SVG_UPDATES41 ==
        UNION(i_e, coord).( i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL
            & coord = {a | #(i_r, NXT, nxt).(i_r : dom(IL_routes_in_res) \/ dom(IL_res_routes)
                & NXT = RailML3_IL_ROUTE_NXT(i_r) - union(union(RailML3_IL_ROUTE_RELEASE_GROUP_AHEAD_NXT[union(IL_released_partialRoutes[{i_r}])] \/ RailML3_IL_ROUTE_RELEASE_GROUP_REAR_NXT[union(IL_released_partialRoutes[{i_r}])])[{i_r}]) & nxt : dom(NXT) \/ ran(NXT) & i_e = prj1(prj1(nxt)) & a = prj2(prj1(nxt))) } |
                    {
                        rec(`id`:i_e^"_lg_res_1", offset: IF coord /= {} THEN TO_STRING(min(coord)*100.0)^"%" ELSE "0%" END),
                        rec(`id`:i_e^"_lg_res_2", offset: IF coord /= {} THEN TO_STRING(min(coord)*100.0)^"%" ELSE "0%" END),
                        rec(`id`:i_e^"_lg_res_3", offset: IF coord /= {} THEN TO_STRING(max(coord)*100.0)^"%" ELSE "100%" END),
                        rec(`id`:i_e^"_lg_res_4", offset: IF coord /= {} THEN TO_STRING(max(coord)*100.0)^"%" ELSE "100%" END)
                    }
        );
    VISB_SVG_UPDATES42 ==
        {i_e • i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |
            rec(`id`:i_e^"_res_blink",
                values: IF #i_r.(i_r : allIdsOfType("route") & i_e : dom(dom(dom(RailML3_IL_ROUTE_NXT(i_r)) \/ ran(RailML3_IL_ROUTE_NXT(i_r)))) & i_r : dom(IL_routes_in_res)) THEN "1;0.2;1"
                    ELSE "1" END
            )
        };
    VISB_SVG_UPDATES43 ==
        {i_e • i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |
            rec(`id`:i_e^"_res",
                visibility: IF #(i_r, NXT).(i_r : allIdsOfType("route") & NXT = RailML3_IL_ROUTE_NXT(i_r) - union(union(RailML3_IL_ROUTE_RELEASE_GROUP_AHEAD_NXT[union(IL_released_partialRoutes[{i_r}])] \/ RailML3_IL_ROUTE_RELEASE_GROUP_REAR_NXT[union(IL_released_partialRoutes[{i_r}])])[{i_r}])
                        & i_e : dom(dom(dom(NXT) \/ ran(NXT))) & (i_r : dom(IL_routes_in_res) or i_r : dom(IL_res_routes))) THEN "visible"
                    ELSE "hidden" END
            )
        };
    
    // overlaps:
    VISB_SVG_UPDATES51 ==
        UNION(i_e, coord).( i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL
            & coord = {a | #(i_o, NXT, nxt).(i_o : dom(IL_res_overlaps) & NXT = RailML3_IL_OVERLAP_NXT(i_o) & nxt : dom(dom(NXT) \/ ran(NXT)) & i_e = prj1(nxt) & a = prj2(nxt)) } |
                {
                    rec(`id`:i_e^"_lg_ovl_1", offset: IF coord /= {} THEN TO_STRING(min(coord)*100.0)^"%" ELSE "0%" END),
                    rec(`id`:i_e^"_lg_ovl_2", offset: IF coord /= {} THEN TO_STRING(min(coord)*100.0)^"%" ELSE "0%" END),
                    rec(`id`:i_e^"_lg_ovl_3", offset: IF coord /= {} THEN TO_STRING(max(coord)*100.0)^"%" ELSE "100%" END),
                    rec(`id`:i_e^"_lg_ovl_4", offset: IF coord /= {} THEN TO_STRING(max(coord)*100.0)^"%" ELSE "100%" END)
                }
        );
    VISB_SVG_UPDATES52 ==
        {i_e • i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |
            rec(`id`:i_e^"_ovl_blink",
                values: IF #(i_r, i_o).(i_r : dom(IL_routes_in_res) /\ dom(RailML3_IL_ROUTE_OVERLAPS) & i_o : RailML3_IL_ROUTE_OVERLAPS(i_r) & i_e : dom(dom(dom(RailML3_IL_OVERLAP_NXT(i_o)) \/ ran(RailML3_IL_OVERLAP_NXT(i_o))))) THEN "1;0.2;1"
                    ELSE "1" END
            )
        };
    //VISB_SVG_UPDATES65 == UNION(i_e).( i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |{rec(`id`:i_e^"_res_blink",  values: IF #i_r.(i_r : allIdsOfType("route") & i_e : dom(dom(RailML3_IL_ROUTE_NXT(i_r))) \/ dom(ran(RailML3_IL_ROUTE_NXT(i_r))) & i_r : dom(IL_routes_in_res)) THEN "1;0.2;1" ELSE "1" END)});
    VISB_SVG_UPDATES53 == UNION(i_e).( i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |{rec(`id`:i_e^"_ovl", visibility: IF #(i_o, NXT).(i_o : dom(IL_res_overlaps) & NXT = RailML3_IL_OVERLAP_NXT(i_o) & i_e : dom(dom(dom(NXT) \/ ran(NXT))) ) THEN "visible" ELSE "hidden" END)});
    
    // occupation:
    VISB_SVG_UPDATES61 ==
        UNION(i_e, t).( i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL & t : RS_arrivedTrains & (i_e = prj1(prj1(RS_trainFront(t))) or i_e = prj1(prj1(RS_trainBack(t)))) |
            {
                rec(`id`:i_e^"_lg_occ_1",
                    offset: IF i_e = prj1(prj1(RS_trainFront(t))) & prj2(RS_trainFront(t)) = direction_reverse THEN TO_STRING(prj2(prj1(RS_trainFront(t)))*100.0)^"%"
                        ELSIF i_e = prj1(prj1(RS_trainBack(t))) & prj2(RS_trainBack(t)) = direction_normal THEN TO_STRING(prj2(prj1(RS_trainBack(t)))*100.0)^"%"
                        ELSE "0%" END),
                rec(`id`:i_e^"_lg_occ_2",
                    offset: IF i_e = prj1(prj1(RS_trainFront(t))) & prj2(RS_trainFront(t)) = direction_reverse THEN TO_STRING(prj2(prj1(RS_trainFront(t)))*100.0)^"%"
                        ELSIF i_e = prj1(prj1(RS_trainBack(t))) & prj2(RS_trainBack(t)) = direction_normal THEN TO_STRING(prj2(prj1(RS_trainBack(t)))*100.0)^"%"
                        ELSE "0%" END),
                rec(`id`:i_e^"_lg_occ_3",
                    offset: IF i_e = prj1(prj1(RS_trainFront(t))) & prj2(RS_trainFront(t)) = direction_normal THEN TO_STRING(prj2(prj1(RS_trainFront(t)))*100.0)^"%"
                        ELSIF i_e = prj1(prj1(RS_trainBack(t))) & prj2(RS_trainBack(t)) = direction_reverse THEN TO_STRING(prj2(prj1(RS_trainBack(t)))*100.0)^"%"
                        ELSE "100%" END),
                rec(`id`:i_e^"_lg_occ_4",
                    offset: IF i_e = prj1(prj1(RS_trainFront(t))) & prj2(RS_trainFront(t)) = direction_normal THEN TO_STRING(prj2(prj1(RS_trainFront(t)))*100.0)^"%"
                        ELSIF i_e = prj1(prj1(RS_trainBack(t))) & prj2(RS_trainBack(t)) = direction_reverse THEN TO_STRING(prj2(prj1(RS_trainBack(t)))*100.0)^"%"
                        ELSE "100%" END)
            }
        );
    VISB_SVG_UPDATES62 ==
        {i_e • i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |
            rec(`id`:i_e^"_occ",
                visibility: IF i_e : dom(dom(ran(RS_trainFront) \/ ran(RS_trainBack))) or #t.(t : RS_arrivedTrains & i_e : dom(RS_trainOccupiedBlocks(t)) ) THEN "visible"
                    ELSE "hidden" END
            )
        };
    VISB_SVG_UPDATES63 ==
        {i_e • i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |
            rec(`id`:i_e^"_title",
                text: IF i_e : dom(dom(ran(RS_trainFront) \/ ran(RS_trainBack))) or #t.(t : RS_arrivedTrains & i_e : dom(RS_trainOccupiedBlocks(t)) ) THEN i_e^" "^TO_STRING({ t | t : RS_arrivedTrains & i_e : dom(RS_trainOccupiedBlocks(t)) })
                    ELSE i_e END
            )
        };

    VISB_SVG_EVENTS11 == {x•x:allIdsOfType("switchIS") | rec(`id`: x, event: "IS_startChangeSwitch", predicate: ('''(#(i_sw_il1, i_sw_il2).(RailML3_IS_SWITCH_TYPE(SwitchId) = switch_doubleSwitchCrossing
        & [i_sw_il1, i_sw_il2] = SORT(dom(IS_switch_states(\"'''^x^'''\"))) & ( ( CurrState(i_sw_il1) = position_left & CurrState(i_sw_il2) = position_left & DestState(i_sw_il1) = position_left & DestState(i_sw_il2) = position_right )
            or ( CurrState(i_sw_il1) = position_left & CurrState(i_sw_il2) = position_right & DestState(i_sw_il1) = position_right & DestState(i_sw_il2) = position_left )
            or ( CurrState(i_sw_il1) = position_right & CurrState(i_sw_il2) = position_left & DestState(i_sw_il1) = position_right & DestState(i_sw_il2) = position_right )
            or ( CurrState(i_sw_il1) = position_right & CurrState(i_sw_il2) = position_right & DestState(i_sw_il1) = position_left & DestState(i_sw_il2) = position_left ) ) )
        or (RailML3_IS_SWITCH_TYPE(SwitchId) /= switch_doubleSwitchCrossing))
        & SwitchId = ''', "\""^x^"\"") )}; // includes switchCrossingsParts, but they should not have an ID in the SVG    
    VISB_SVG_EVENTS12 == {x•x:allIdsOfType("switchIS") | rec(`id`: x, event: "IS_endChangeSwitch", predicate: ("SwitchId=","\""^x^"\"") )};
    VISB_SVG_EVENTS13 == {x•x:allIdsOfType("switchIS") | rec(`id`: x, event: "IS_startChangeCoupledSwitches", predicate: "SwitchId1=\"x\" or SwitchId2=\"x\"" )};
    VISB_SVG_HOVERS1 == {x•x:allIdsOfType("switchIS") | rec(`id`: x^"_ellipse", `stroke-width`: "1.5" )};
    VISB_SVG_OBJECTS1 == {x•x:allIdsOfType("switchIS") | rec(`id`: x^"_ellipse", svg_class: "ellipse", `stroke-width`: "1.0" )};

    VISB_SVG_EVENTS21 == {x•x:allIdsOfType("derailerIS") | rec(`id`: x, event: "IS_startChangeDerailer", predicate: ("DerailerId=","\""^x^"\"") )};
    VISB_SVG_EVENTS22 == {x•x:allIdsOfType("derailerIS") | rec(`id`: x, event: "IS_endChangeDerailer", predicate: ("DerailerId=","\""^x^"\"") )};
    VISB_SVG_HOVERS2 == {x•x:allIdsOfType("derailerIS") | rec(`id`: x^"_ellipse", `stroke-width`: "1.5" )};
    VISB_SVG_OBJECTS2 == {x•x:allIdsOfType("derailerIS") | rec(`id`: x^"_ellipse", svg_class: "ellipse", `stroke-width`: "1.0" )};

    // RailML3_IS_MOVABLE_CROSSING_IDS in generated version: (variables cannot be used for EVENTS and HOVERS)
    /*VISB_SVG_EVENTS31 == {x•x:allIdsOfType("crossing") | rec(`id`: x, event: "IS_startChangeCrossing", predicate: ("CrossingId=","\""^x^"\"") )};
    VISB_SVG_EVENTS32 == {x•x:allIdsOfType("crossing") | rec(`id`: x, event: "IS_endChangeCrossing", predicate: ("CrossingId=","\""^x^"\"") )};
    VISB_SVG_HOVERS3 == {x•x:allIdsOfType("crossing") | rec(`id`: x^"_ellipse", `stroke-width`: "1.5" )};
    VISB_SVG_OBJECTS3 == {x•x:allIdsOfType("crossing") | rec(`id`: x^"_ellipse", svg_class: "ellipse", `stroke-width`: "1.0" )};*/
    VISB_SVG_EVENTS31 == {x•x:RailML3_IS_MOVABLE_CROSSING_IDS | rec(`id`: x, event: "IS_startChangeCrossing", predicate: ("CrossingId=","\""^x^"\"") )};
    VISB_SVG_EVENTS32 == {x•x:RailML3_IS_MOVABLE_CROSSING_IDS | rec(`id`: x, event: "IS_endChangeCrossing", predicate: ("CrossingId=","\""^x^"\"") )};
    VISB_SVG_HOVERS3 == {x•x:RailML3_IS_MOVABLE_CROSSING_IDS | rec(`id`: x^"_ellipse", `stroke-width`: "1.5" )};
    VISB_SVG_OBJECTS3 == {x•x:RailML3_IS_MOVABLE_CROSSING_IDS | rec(`id`: x^"_ellipse", svg_class: "ellipse", `stroke-width`: "1.0" )};

    // RailML3_IL_SIGNAL_CONTROLLED in generated version:
    /*VISB_SVG_EVENTS41 == {x•x:allIdsOfType("signalIS") | rec(`id`: x, event: "IL_noteChangeSignalState", predicate: ("SignalId=","\""^x^"\"") )};
    VISB_SVG_EVENTS42 == {x•x:allIdsOfType("signalIS") | rec(`id`: x, event: "IL_changeSignalState", predicate: ("SignalId=","\""^x^"\"") )};    
    VISB_SVG_HOVERS4 == {x•x:allIdsOfType("signalIS") | rec(`id`: x^"_ellipse", `stroke-width`: "1.5" )};
    VISB_SVG_OBJECTS4 == {x•x:allIdsOfType("signalIS") | rec(`id`: x^"_ellipse", svg_class: "ellipse", `stroke-width`: "1.0" )};*/
    VISB_SVG_EVENTS41 == {x•x:RailML3_IL_SIGNAL_CONTROLLED | rec(`id`: x, event: "IL_noteChangeSignalState", predicate: ("SignalId=","\""^x^"\"") )};
    VISB_SVG_EVENTS42 == {x•x:RailML3_IL_SIGNAL_CONTROLLED | rec(`id`: x, event: "IL_changeSignalState", predicate: ("SignalId=","\""^x^"\"") )};    
    VISB_SVG_HOVERS4 == {x•x:RailML3_IL_SIGNAL_CONTROLLED | rec(`id`: x^"_ellipse", `stroke-width`: "1.5" )};
    VISB_SVG_OBJECTS4 == {x•x:RailML3_IL_SIGNAL_CONTROLLED | rec(`id`: x^"_ellipse", svg_class: "ellipse", `stroke-width`: "1.0" )};

    // use only for generated versions:
    VISB_SVG_EVENTS51 == {x•x:RailML3_IS_OPENEND_IDS | rec(`id`: x, event: "RS_trainArrivalRequest", predicate: "prj1(Position) : dom(RailML3_IS_SPOT_LOCATIONS(\"x\"))" )};
    VISB_SVG_EVENTS52 == {x•x:RailML3_IS_OPENEND_IDS | rec(`id`: x, event: "RS_trainLeave" )}; //, predicate: "position : RailML3_IS_SPOT_LOCATIONS(\"x\")"
    VISB_SVG_HOVERS5 == {x•x:RailML3_IS_OPENEND_IDS | rec(`id`: x^"_ellipse", `stroke-width`: "1.5" )};
    VISB_SVG_OBJECTS5 == {x•x:RailML3_IS_OPENEND_IDS | rec(`id`: x^"_ellipse", svg_class: "ellipse", `stroke-width`: "1.0" )};
    // start RouteRes?