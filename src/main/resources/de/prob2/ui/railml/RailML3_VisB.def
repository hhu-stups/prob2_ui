DEFINITIONS
    "LibrarySVG.def";
    // Definitions for VisB:
    VISB_SVG_UPDATES10 ==
        {i_e • i_e : RailML3_IS_MOVABLE_CROSSING_IDS |
            rec(`id`: i_e^"_ellipse",
                stroke: IF i_e : dom(IS_crossingsInMovement) THEN "darkorange"
                    ELSIF i_e : dom(IL_crossing_locked_routes) or IS_crossing_keyLocked(i_e) = TRUE THEN "red"
                    ELSE "black" END,
                fill: IF #i_r.(i_r : dom(IL_routes_in_res) & i_r : dom(RailML3_IL_ROUTE_CROSSING_POSITIONS) & i_e : dom(RailML3_IL_ROUTE_CROSSING_POSITIONS(i_r)) & (RailML3_IL_ROUTE_CROSSING_POSITIONS(i_r)(i_e) /= IS_crossing_states(i_e) or i_e : dom(IS_crossingsInMovement)))
                        or #i_o.(i_o : dom(IL_res_overlaps) & i_o : dom(RailML3_IL_OVERLAP_CROSSING_POSITIONS) & i_e : dom(RailML3_IL_OVERLAP_CROSSING_POSITIONS(i_o)) & (RailML3_IL_OVERLAP_CROSSING_POSITIONS(i_o)(i_e) /= IS_crossing_states(i_e) or i_e : dom(IS_crossingsInMovement)))
                        THEN "red"
                    ELSIF !i_r.(i_r : dom(IL_routes_in_res) & i_r : dom(RailML3_IL_ROUTE_CROSSING_POSITIONS) & i_e : dom(RailML3_IL_ROUTE_CROSSING_POSITIONS(i_r)) => RailML3_IL_ROUTE_CROSSING_POSITIONS(i_r)(i_e) = IS_crossing_states(i_e))
                        & !(i_o, i_r).(i_o : dom(IL_res_overlaps) /\ dom(RailML3_IL_OVERLAP_CROSSING_POSITIONS) & i_r : dom(IL_routes_in_res) /\ dom(RailML3_IL_ROUTE_OVERLAPS) & i_o : RailML3_IL_ROUTE_OVERLAPS(i_r) & i_e : dom(RailML3_IL_OVERLAP_CROSSING_POSITIONS(i_o)) => RailML3_IL_OVERLAP_CROSSING_POSITIONS(i_o)(i_e) = IS_crossing_states(i_e))
                        & ( #i_r.(i_r : dom(IL_routes_in_res) & i_r : dom(RailML3_IL_ROUTE_CROSSING_POSITIONS) & i_e : dom(RailML3_IL_ROUTE_CROSSING_POSITIONS(i_r)))
                        or #(i_o, i_r).(i_o : dom(IL_res_overlaps) /\ dom(RailML3_IL_OVERLAP_CROSSING_POSITIONS) & i_r : dom(IL_routes_in_res) /\ dom(RailML3_IL_ROUTE_OVERLAPS) & i_o : RailML3_IL_ROUTE_OVERLAPS(i_r) & i_e : dom(RailML3_IL_OVERLAP_CROSSING_POSITIONS(i_o))) )
                        THEN "green"
                    ELSE "black" END
            )
        };
    VISB_SVG_UPDATES11 ==
        {i_e • i_e : RailML3_IS_MOVABLE_CROSSING_IDS |
            rec(`id`: i_e^"_title",
                text: FORMAT_TO_STRING("~w\nState: ~w", [i_e, TO_STRING(IS_crossing_states(i_e))])
            )
        };
    VISB_SVG_UPDATES12 ==
        {i_e • i_e : allIdsOfType("derailerIS") |
            rec(`id`: i_e^"_ellipse",
                stroke: IF i_e : dom(IS_derailersInMovement) THEN "darkorange"
                    ELSIF i_e : dom(IL_derailer_locked_routes) or IS_derailer_keyLocked(i_e) = TRUE THEN "red"
                    ELSE "black" END,
                fill: IF prj2(IS_derailer_states(i_e)) = position_derailingPosition THEN "yellow"
                    ELSE "black" END
            )
        };
    VISB_SVG_UPDATES13 ==
        {i_e • i_e : allIdsOfType("derailerIS") |
            rec(`id`: i_e^"_title",
                text: FORMAT_TO_STRING("~w\nState: ~w", [i_e, TO_STRING(IS_derailer_states(i_e))])
            )
        };
    VISB_SVG_UPDATES14 ==
        {i_e • i_e : RailML3_IS_SWITCH_IDS |
            rec(`id`: i_e^"_ellipse",
                stroke: IF i_e : dom(IS_switchesInMovement) THEN "darkorange" ELSIF i_e : dom(IL_switch_locked_routes) or IS_switch_keyLocked(i_e) = TRUE THEN "red" ELSE "black" END,
                fill: IF #i_r.(i_r : dom(IL_routes_in_res) /\ dom(RailML3_IL_ROUTE_SWITCH_POSITIONS) & i_e : dom(RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)) & (RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)(i_e) /<: IS_switch_states(i_e) or i_e : dom(IS_switchesInMovement)))
                        or #i_o.(i_o : dom(IL_res_overlaps) /\ dom(RailML3_IL_OVERLAP_SWITCH_POSITIONS) & i_e : dom(RailML3_IL_OVERLAP_SWITCH_POSITIONS(i_o)) & (RailML3_IL_OVERLAP_SWITCH_POSITIONS(i_o)(i_e) /<: IS_switch_states(i_e) or i_e : dom(IS_switchesInMovement)))
                        THEN "red"
                    ELSIF !i_r.(i_r : dom(IL_routes_in_res) & i_r : dom(RailML3_IL_ROUTE_SWITCH_POSITIONS) & i_e : dom(RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)) => RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)(i_e) <: IS_switch_states(i_e))
                        & !(i_o, i_r).(i_o : dom(IL_res_overlaps) /\ dom(RailML3_IL_OVERLAP_SWITCH_POSITIONS) & i_r : dom(IL_routes_in_res) /\ dom(RailML3_IL_ROUTE_OVERLAPS) & i_o : RailML3_IL_ROUTE_OVERLAPS(i_r) & i_e : dom(RailML3_IL_OVERLAP_SWITCH_POSITIONS(i_o)) => RailML3_IL_OVERLAP_SWITCH_POSITIONS(i_o)(i_e) <: IS_switch_states(i_e))
                        & ( #i_r.(i_r : dom(IL_routes_in_res) & i_r : dom(RailML3_IL_ROUTE_SWITCH_POSITIONS) & i_e : dom(RailML3_IL_ROUTE_SWITCH_POSITIONS(i_r)))
                        or #(i_o, i_r).(i_o : dom(IL_res_overlaps) /\ dom(RailML3_IL_OVERLAP_SWITCH_POSITIONS) & i_r : dom(IL_routes_in_res) /\ dom(RailML3_IL_ROUTE_OVERLAPS) & i_o : RailML3_IL_ROUTE_OVERLAPS(i_r) & i_e : dom(RailML3_IL_OVERLAP_SWITCH_POSITIONS(i_o))) )
                        THEN "green"
                    ELSE "black" END
            )
        };
    VISB_SVG_UPDATES15 ==
        {i_e • i_e : RailML3_IS_SWITCH_IDS |
            rec(`id`: i_e^"_title",
                text: FORMAT_TO_STRING("~w (~w)\nState: ~w", [i_e, STRING_SPLIT(TO_STRING(RailML3_IS_SWITCH_TYPE(i_e)), "_")(2), TO_STRING(IS_switch_states(i_e))])
            )
        };
    VISB_SVG_UPDATES16 ==
        {i_e • i_e : RailML3_IL_SIGNAL_CONTROLLED |
            rec(`id`: i_e^"_ellipse",
                stroke: IF #i_r.(i_r : dom(IL_routes_in_res) & (i_e = prj1(RailML3_IL_ROUTE_ENTRY(i_r)) or i_e = prj1(RailML3_IL_ROUTE_EXIT(i_r)))) or i_e : IL_signal_locked THEN "darkorange"
                    ELSE "black" END,
                fill: IF aspect_closed : IL_signal_states(i_e) THEN "red"
                    ELSIF aspect_caution : IL_signal_states(i_e) THEN "yellow"
                    ELSE "green" END
            )
        };
    VISB_SVG_UPDATES17 ==
        {i_e • i_e : RailML3_IL_SIGNAL_CONTROLLED |
            rec(`id`: i_e^"_title",
                text: FORMAT_TO_STRING("~w\nAspect: ~w", [i_e, TO_STRING(IL_signal_states(i_e))])
            )
        };
    VISB_SVG_UPDATES18 ==
        {i_e • i_e : union(allIdsOfType[{"balise","border","bufferStop","levelCrossingIS","trainDetectionElement"}]) |
            rec(`id`: i_e^"_ellipse",
                visibility: IF #i_sig.( i_sig : RailML3_IL_SIGNAL_CONTROLLED & RailML3_IS_SPOT_LOCATIONS(i_e) /\ RailML3_IS_SPOT_LOCATIONS(i_sig) /= {} ) THEN "hidden" ELSE "visible" END
            )
        };
    
    
    // switch branches:
    VISB_SVG_UPDATES_switchBranches == 
        { i_e • i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |
            rec(`id`: i_e^"_branches",
                `stroke-dasharray`: LET intervals BE intervals = SORT(dom({ i, b | b : ran(ignoreDirection((union(ran(RailML3_IS_CROSSING_BRANCHES)) \/ union(ran(RailML3_IS_SWITCH_BRANCHES))) /\ IS_next))
                        & ( ( prj1(b) = i_e & prj2(b) = 0.0 & i = 0 |-> 20 )
                            or ( prj1(b) = i_e & prj2(b) = 1.0 & i = 80 |-> 100 ) 
                        )}))
                    IN IF intervals /= [] THEN svg_dasharray_for_intervals(intervals) ELSE "0 100" END END
            )};
    
    // TVD sections:
    VISB_SVG_UPDATES_tvd1 ==
        {i_e • i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |
            LET coord_routes, coord_occ BE coord_routes = { a | #(i_t, i_r).( i_r : dom(IL_routes_in_res \/ IL_res_routes) /\ dom(RailML3_IL_ROUTE_TVD_SECTIONS) & i_t : RailML3_IL_ROUTE_TVD_SECTIONS(i_r) - ( union(RailML3_IL_ROUTE_RELEASE_GROUPS_AHEAD_TVD_SECTIONS[union(IL_released_partialRoutes[{i_r}])]) \/ union(RailML3_IL_ROUTE_RELEASE_GROUPS_REAR_TVD_SECTIONS[union(IL_released_partialRoutes[{i_r}])]) ) & LET path BE path = ran({i_e} <| dom(dom(RailML3_IL_TVD_SECTIONS(i_t)))) IN path /= {} & a = min(path)*100.0 |-> max(path)*100.0 END ) }
                    \/ { a | #(i_t, i_o).( i_o : dom(IL_res_overlaps) /\ dom(RailML3_IL_OVERLAP_TVD_SECTIONS) & i_t : RailML3_IL_OVERLAP_TVD_SECTIONS(i_o) & LET path BE path = ran({i_e} <| dom(dom(RailML3_IL_TVD_SECTIONS(i_t)))) IN path /= {} & a = min(path)*100.0 |-> max(path)*100.0 END ) }
                & coord_occ = { a | #(i_t).( i_t : dom(IL_occupiedTvdSections) & LET path BE path = ran({i_e} <| dom(dom(RailML3_IL_TVD_SECTIONS(i_t)))) IN path /= {} & a = min(path)*100.0 |-> max(path)*100.0 END ) }
            IN
            rec(`id`: i_e^"_tvd_blink",
                values: LET not_blink_ivs, all_ivs BE not_blink_ivs = SORT(coord_occ) & all_ivs = SORT(coord_occ \/ coord_routes)
                        IN IF not_blink_ivs /= [] THEN svg_dasharray_for_intervals(all_ivs)^";"^svg_dasharray_for_intervals(not_blink_ivs)
                            ELSIF all_ivs /= [] THEN svg_dasharray_for_intervals(all_ivs)^";0 100"
                            ELSE "0 100" END
                        END
            ) END };
            // TODO: simplify ^
    VISB_SVG_UPDATES_tvd2 ==
        {i_e • i_e : allIdsOfType("tvdSection") |
            rec(`id`: i_e^"_title",
                text: IF i_e : dom(IL_occupiedTvdSections) THEN FORMAT_TO_STRING("~w ~w", [i_e, TO_STRING(IL_occupiedTvdSections[{i_e}])])
                    ELSE i_e END
            )
        };
    
    // reservation:
    VISB_SVG_UPDATES_reservation ==
        { i_e • i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |
            rec(`id`:i_e^"_res_blink",
                values: LET intervals BE intervals = { i, r | r : dom(IL_routes_in_res) \/ dom(IL_res_routes)
                        & LET coord BE coord = dom({a, nxt | LET NXT BE NXT = RailML3_IL_ROUTE_NXT(r) - union(union((RailML3_IL_ROUTE_RELEASE_GROUP_AHEAD_NXT \/ RailML3_IL_ROUTE_RELEASE_GROUP_REAR_NXT)[union(IL_released_partialRoutes[{r}])])[{r}]) IN nxt : dom(dom(NXT) \/ ran(NXT)) & i_e = prj1(nxt) & a = prj2(nxt) END })
                            IN coord /= {} & i = min(coord)*100.0 |-> max(coord)*100.0 END }
                    IN LET not_blink_ivs, all_ivs BE not_blink_ivs = SORT(dom(intervals |> dom(IL_res_routes))) & all_ivs = SORT(dom(intervals)) 
                        IN IF not_blink_ivs /= [] THEN svg_dasharray_for_intervals(all_ivs)^";"^svg_dasharray_for_intervals(not_blink_ivs)
                            ELSIF all_ivs /= [] THEN svg_dasharray_for_intervals(all_ivs)^";0 100"
                            ELSE "0 100" END
                        END
                    END
            )};
    
    // overlaps:
    VISB_SVG_UPDATES_overlaps ==
        { i_e • i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |
            rec(`id`:i_e^"_ovl_blink",
                values: LET intervals BE intervals = { i, o | o : dom(IL_res_overlaps)
                        & LET coord BE coord = dom({a, nxt | LET NXT BE NXT = RailML3_IL_OVERLAP_NXT(o) IN nxt : dom(dom(NXT) \/ ran(NXT)) & i_e = prj1(nxt) & a = prj2(nxt) END })
                            IN coord /= {} & i = min(coord)*100.0 |-> max(coord)*100.0 END }
                    IN LET not_blink_ivs, all_ivs BE not_blink_ivs = SORT(dom(intervals |>> union(RailML3_IL_ROUTE_OVERLAPS[dom(IL_routes_in_res) /\ dom(RailML3_IL_ROUTE_OVERLAPS)]))) & all_ivs = SORT(dom(intervals)) 
                        IN IF not_blink_ivs /= [] THEN svg_dasharray_for_intervals(all_ivs)^";"^svg_dasharray_for_intervals(not_blink_ivs)
                            ELSIF all_ivs /= [] THEN svg_dasharray_for_intervals(all_ivs)^";0 100"
                            ELSE "0 100" END
                        END
                    END
            )};
    
    // occupation:
    VISB_SVG_UPDATES_occupation1 == 
        { i_e • i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |
            rec(`id`: i_e^"_occ",
                `stroke-dasharray`: LET intervals BE intervals = SORT(dom({ i, t | t : RS_arrivedTrains
                        & LET occ BE occ = RS_trainOccupiedLocations(t)[{i_e}] IN occ /= {} & i = min(occ)*100.0 |-> max(occ)*100.0 END }))
                    IN IF intervals /= [] THEN svg_dasharray_for_intervals(intervals) ELSE "0 100" END END
            )};
    VISB_SVG_UPDATES_occupation2 == 
        { i_e • i_e : allIdsOfType("netElement") /\ RailML3_IS_NET_RESOURCES_MICRO_LEVEL |
            rec(`id`:i_e^"_title", visibility: "", `stroke-dasharray`: "",
                text: LET trains BE trains = { t | t : RS_arrivedTrains & i_e : dom(RS_trainOccupiedLocations(t)) } IN IF trains /= {} THEN i_e^" "^TO_STRING(trains) ELSE i_e END END
            )};

    VISB_SVG_EVENTS11 == {x•x:allIdsOfType("switchIS") | rec(`id`: x, event: "IS_startChangeSwitch", predicate: ('''(#(i_sw_il1, i_sw_il2).(RailML3_IS_SWITCH_TYPE(SwitchId) = switch_doubleSwitchCrossing
        & [i_sw_il1, i_sw_il2] = SORT(dom(IS_switch_states(\"'''^x^'''\"))) & ( ( CurrState(i_sw_il1) = position_left & CurrState(i_sw_il2) = position_left & DestState(i_sw_il1) = position_left & DestState(i_sw_il2) = position_right )
            or ( CurrState(i_sw_il1) = position_left & CurrState(i_sw_il2) = position_right & DestState(i_sw_il1) = position_right & DestState(i_sw_il2) = position_left )
            or ( CurrState(i_sw_il1) = position_right & CurrState(i_sw_il2) = position_left & DestState(i_sw_il1) = position_right & DestState(i_sw_il2) = position_right )
            or ( CurrState(i_sw_il1) = position_right & CurrState(i_sw_il2) = position_right & DestState(i_sw_il1) = position_left & DestState(i_sw_il2) = position_left ) ) )
        or (RailML3_IS_SWITCH_TYPE(SwitchId) /= switch_doubleSwitchCrossing))
        & SwitchId = \"'''^x^"\"") )}; // includes switchCrossingsParts, but they should not have an ID in the SVG    
    VISB_SVG_EVENTS12 == {x•x:allIdsOfType("switchIS") | rec(`id`: x, event: "IS_endChangeSwitch", predicate: "SwitchId=\""^x^"\"" )};
    VISB_SVG_EVENTS13 == {x•x:allIdsOfType("switchIS") | rec(`id`: x, event: "IS_startChangeCoupledSwitches", predicate: "SwitchId1=\""^x^"\" or SwitchId2=\""^x^"\"" )};
    VISB_SVG_HOVERS1 == {x•x:allIdsOfType("switchIS") | rec(`id`: x^"_ellipse", `stroke-width`: "1.5" )};
    VISB_SVG_OBJECTS1 == {x•x:allIdsOfType("switchIS") | rec(`id`: x^"_ellipse", svg_class: "ellipse", `stroke-width`: "1.0" )};

    VISB_SVG_EVENTS21 == {x•x:allIdsOfType("derailerIS") | rec(`id`: x, event: "IS_startChangeDerailer", predicate: "DerailerId=\""^x^"\"" )};
    VISB_SVG_EVENTS22 == {x•x:allIdsOfType("derailerIS") | rec(`id`: x, event: "IS_endChangeDerailer", predicate: "DerailerId=\""^x^"\"" )};
    VISB_SVG_HOVERS2 == {x•x:allIdsOfType("derailerIS") | rec(`id`: x^"_ellipse", `stroke-width`: "1.5" )};
    VISB_SVG_OBJECTS2 == {x•x:allIdsOfType("derailerIS") | rec(`id`: x^"_ellipse", svg_class: "ellipse", `stroke-width`: "1.0" )};

    // RailML3_IS_MOVABLE_CROSSING_IDS in generated version: (variables cannot be used for EVENTS and HOVERS)
    /*VISB_SVG_EVENTS31 == {x•x:allIdsOfType("crossing") | rec(`id`: x, event: "IS_startChangeCrossing", predicate: "CrossingId=\""^x^"\"" )};
    VISB_SVG_EVENTS32 == {x•x:allIdsOfType("crossing") | rec(`id`: x, event: "IS_endChangeCrossing", predicate: "CrossingId=\""^x^"\"" )};
    VISB_SVG_HOVERS3 == {x•x:allIdsOfType("crossing") | rec(`id`: x^"_ellipse", `stroke-width`: "1.5" )};
    VISB_SVG_OBJECTS3 == {x•x:allIdsOfType("crossing") | rec(`id`: x^"_ellipse", svg_class: "ellipse", `stroke-width`: "1.0" )};*/
    VISB_SVG_EVENTS31 == {x•x:RailML3_IS_MOVABLE_CROSSING_IDS | rec(`id`: x, event: "IS_startChangeCrossing", predicate: "CrossingId=\""^x^"\"" )};
    VISB_SVG_EVENTS32 == {x•x:RailML3_IS_MOVABLE_CROSSING_IDS | rec(`id`: x, event: "IS_endChangeCrossing", predicate: "CrossingId=\""^x^"\"" )};
    VISB_SVG_HOVERS3 == {x•x:RailML3_IS_MOVABLE_CROSSING_IDS | rec(`id`: x^"_ellipse", `stroke-width`: "1.5" )};
    VISB_SVG_OBJECTS3 == {x•x:RailML3_IS_MOVABLE_CROSSING_IDS | rec(`id`: x^"_ellipse", svg_class: "ellipse", `stroke-width`: "1.0" )};

    // RailML3_IL_SIGNAL_CONTROLLED in generated version:
    /*VISB_SVG_EVENTS41 == {x•x:allIdsOfType("signalIS") | rec(`id`: x, event: "IL_noteChangeSignalState", predicate: "SignalId=\""^x^"\"" )};
    VISB_SVG_EVENTS42 == {x•x:allIdsOfType("signalIS") | rec(`id`: x, event: "IL_changeSignalState", predicate: "SignalId=\""^x^"\"" )};    
    VISB_SVG_HOVERS4 == {x•x:allIdsOfType("signalIS") | rec(`id`: x^"_ellipse", `stroke-width`: "1.5" )};
    VISB_SVG_OBJECTS4 == {x•x:allIdsOfType("signalIS") | rec(`id`: x^"_ellipse", svg_class: "ellipse", `stroke-width`: "1.0" )};*/
    VISB_SVG_EVENTS41 == {x•x:RailML3_IL_SIGNAL_CONTROLLED | rec(`id`: x, event: "IL_noteChangeSignalState", predicate: "SignalId=\""^x^"\"" )};
    VISB_SVG_EVENTS42 == {x•x:RailML3_IL_SIGNAL_CONTROLLED | rec(`id`: x, event: "IL_changeSignalState", predicate: "SignalId=\""^x^"\"" )};    
    VISB_SVG_HOVERS4 == {x•x:RailML3_IL_SIGNAL_CONTROLLED | rec(`id`: x^"_ellipse", `stroke-width`: "1.5" )};
    VISB_SVG_OBJECTS4 == {x•x:RailML3_IL_SIGNAL_CONTROLLED | rec(`id`: x^"_ellipse", svg_class: "ellipse", `stroke-width`: "1.0" )};

    // use only for generated versions:
    VISB_SVG_EVENTS51 == {x•x:RailML3_IS_OPENEND_IDS | rec(`id`: x, event: "RS_trainArrivalRequest", predicate: "prj1(Position) : dom(RailML3_IS_SPOT_LOCATIONS(\"x\"))" )};
    VISB_SVG_EVENTS52 == {x•x:RailML3_IS_OPENEND_IDS | rec(`id`: x, event: "RS_trainLeave" )}; //, predicate: "position : RailML3_IS_SPOT_LOCATIONS(\"x\")"
    VISB_SVG_HOVERS5 == {x•x:RailML3_IS_OPENEND_IDS | rec(`id`: x^"_ellipse", `stroke-width`: "1.5" )};
    VISB_SVG_OBJECTS5 == {x•x:RailML3_IS_OPENEND_IDS | rec(`id`: x^"_ellipse", svg_class: "ellipse", `stroke-width`: "1.0" )};
    // start RouteRes?